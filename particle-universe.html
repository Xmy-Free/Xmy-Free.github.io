<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子宇宙</title>
    <link rel="stylesheet" href="my-cursor.css">









<style>
        /*基础样式重置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* 全局样式 */
        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'PingFang SC', 'Microsoft YaHei', 'SimHei', 'SimSun', 'Arial', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-drag: none;
            -khtml-user-select: none;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* 画布样式 */
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: block;
        }

        /* 加载界面 */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            font-size: 24px;
            transition: opacity 1s ease-out;
        }

        .loading-title {
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 300;
            text-align: center;
            opacity: 0.8;
        }

        .loading-bar-container {
            width: 300px;
            height: 3px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .loading-percentage {
            font-size: 16px;
            margin-bottom: 30px;
            opacity: 0.7;
        }

        .loading-hint {
            font-size: 14px;
            opacity: 0.5;
            text-align: center;
            max-width: 300px;
            line-height: 1.5;
        }

        /* 信息显示 */
        /* .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 10;
            background: none !important;
            border: none !important;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 300px;
            backdrop-filter: blur(5px);
        } */

        .info-title {
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: bold;
            color: #4facfe;
        }

        /* 控制面板 */
        .control-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #4facfe;
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.2);
            z-index: 1000;
            transform: translateY(0);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 300px;
            overflow: hidden;
        }

        .control-panel:hover {
            box-shadow: 0 0 30px rgba(79, 172, 254, 0.4);
            transform: translateY(-5px);
        }

        .control-title {
            /* background: linear-gradient(90deg, #4facfe 10%, #00f2fe 90%); */
            -webkit-text-fill-color: transparent;
            font-size: 20px;
            letter-spacing: 2px;
            text-shadow: 0 0 18px #00f2fe, 0 0 8px #4facfe;
            animation: titleGlow 2.5s infinite alternate;
        }

        .control-item {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(79, 172, 254, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 1px solid rgba(79, 172, 254, 0.1);
            animation: controlItemPulse 2s infinite alternate;
        }

        .control-item:hover {
            background: rgba(79, 172, 254, 0.2);
            transform: translateX(-5px);
            border-color: rgba(79, 172, 254, 0.3);
        }

        .control-icon {
            width: 30px;
            height: 30px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: rgba(79, 172, 254, 0.15);
            border-radius: 6px;
            color: #4facfe;
            transition: all 0.3s ease;
        }

        .control-item:hover .control-icon {
            background: rgba(79, 172, 254, 0.3);
            transform: scale(1.1);
        }

        .control-text {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
            color: #fff;
            text-shadow: 0 0 5px rgba(79, 172, 254, 0.3);
        }

        @keyframes controlItemPulse {
            0% {
                box-shadow: 0 0 5px rgba(79, 172, 254, 0.2);
            }

            100% {
                box-shadow: 0 0 15px rgba(79, 172, 254, 0.4);
            }
        }

        /* 响应式调整 */
        @media (max-width: 480px) {
            .control-panel {
                max-width: calc(100% - 40px);
                bottom: 10px;
                right: 10px;
                padding: 15px;
            }

            .control-title {
                font-size: 14px;
            }

            .control-item {
                padding: 8px;
            }

            .control-icon {
                width: 24px;
                height: 24px;
                font-size: 14px;
            }

            .control-text {
                font-size: 12px;
            }
        }

        /* 动画效果 */
        @keyframes pulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        .pulse {
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes float {
            0% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }

            100% {
                transform: translateY(0px);
            }
        }

        .float {
            animation: float 4s infinite ease-in-out;
        }

        /* 粒子效果预览 */
        .particle-preview {
            position: absolute;
            width: 100px;
            height: 100px;
            pointer-events: none;
            opacity: 0.3;
        }

        /* 工具提示 */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* 音乐控制 */
        .music-control {
            position: fixed;
            bottom: 130px;
            right: 20px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .music-control:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* 设置面板 */
        .settings-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 12px;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 172, 254, 0.3);
            transform: translateX(-120%);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.2);
        }

        .settings-panel::-webkit-scrollbar {
            width: 6px;
        }

        .settings-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .settings-panel::-webkit-scrollbar-thumb {
            background: rgba(79, 172, 254, 0.5);
            border-radius: 3px;
        }

        .settings-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(79, 172, 254, 0.8);
        }

        .settings-panel.active {
            transform: translateX(0);
            box-shadow: 0 0 30px rgba(79, 172, 254, 0.3);
        }

        /* 自定义设置面板样式 */
        .custom-settings {
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            /* 新增科技感宇宙感背景和发光 */
            background: linear-gradient(135deg, rgba(0, 20, 50, 0.92) 0%, rgba(0, 5, 25, 0.98) 100%),
                radial-gradient(ellipse at 60% 40%, rgba(0, 255, 255, 0.15) 0%, rgba(0, 10, 60, 0.15) 60%, transparent 100%),
                repeating-linear-gradient(120deg, rgba(79, 172, 254, 0.12) 0 2px, transparent 2px 40px);
            box-shadow: 0 0 60px 15px rgba(0, 255, 255, 0.15),
                0 0 100px 20px rgba(0, 10, 60, 0.1),
                0 0 0 2px rgba(79, 172, 254, 0.25) inset;
            border-radius: 20px;
            border: 2px solid rgba(79, 172, 254, 0.35);
            position: relative;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .custom-settings[style*="display: block"] {
            opacity: 1;
            max-height: none;
            margin-top: 20px;
            border-top: 1px solid rgba(79, 172, 254, 0.3);
            padding-top: 20px;
            box-shadow: 0 0 80px 15px #00f2fe44 inset,
                0 0 40px 10px #4facfe33,
                0 0 120px 30px rgba(0, 150, 255, 0.15);
            animation: customGlow 3s infinite alternate cubic-bezier(0.4, 0, 0.6, 1);
        }

        @keyframes customGlow {
            0% {
                box-shadow: 0 0 80px 15px #00f2fe33 inset,
                    0 0 40px 10px #4facfe33,
                    0 0 120px 30px rgba(0, 150, 255, 0.15);
                border-color: rgba(79, 172, 254, 0.35);
            }

            50% {
                box-shadow: 0 0 100px 20px #00f2fe44 inset,
                    0 0 50px 15px #4facfe44,
                    0 0 150px 40px rgba(0, 180, 255, 0.2);
                border-color: rgba(0, 242, 254, 0.4);
            }

            100% {
                box-shadow: 0 0 70px 12px #00f2fe33 inset,
                    0 0 30px 8px #4facfe33,
                    0 0 100px 25px rgba(0, 150, 255, 0.15);
                border-color: rgba(79, 172, 254, 0.35);
            }
        }

        .custom-settings .star-dust {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .custom-settings .settings-title {
            background: linear-gradient(90deg, #4facfe 10%, #00f2fe 90%);
            -webkit-text-fill-color: transparent;
            font-size: 22px;
            letter-spacing: 2px;
            text-shadow: 0 0 18px #00f2fe, 0 0 8px #4facfe;
            position: relative;
            animation: titleGlow 2.5s infinite alternate;
            z-index: 1;
        }

        .custom-settings .settings-group {
            margin-bottom: 22px;
            padding: 20px 18px 18px 18px;
            background: rgba(15, 25, 55, 0.85);
            border-radius: 14px;
            border: 2px solid rgba(79, 172, 254, 0.28);
            box-shadow: 0 0 30px 6px #00f2fe33 inset,
                0 0 12px 4px #4facfe33,
                0 5px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: visible;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            transform: translateZ(0);
        }

        .custom-settings .settings-group:hover {
            border-color: rgba(0, 242, 254, 0.4);
            box-shadow: 0 0 40px 10px #00f2fe33 inset,
                0 0 20px 6px #4facfe33,
                0 8px 24px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px) translateZ(0);
        }

        .custom-settings .settings-group::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            pointer-events: none;
            border: 2px solid transparent;
            background: linear-gradient(120deg, rgba(79, 172, 254, 0.10), rgba(0, 242, 254, 0.08));
            opacity: 0.4;
            z-index: 0;
        }

        .custom-settings .settings-label {
            color: #4facfe;
            text-shadow: 0 0 8px #00f2fe99;
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 8px;
            z-index: 1;
        }

        .custom-settings .settings-slider {
            width: 100%;
            height: 10px;
            margin-bottom: 18px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 50%, #4facfe 100%);
            background-size: 200% 100%;
            border-radius: 5px;
            outline: none;
            box-shadow: 0 0 16px #00f2fe55 inset,
                0 0 30px rgba(0, 242, 254, 0.2);
            transition: all 0.3s;
            animation: sliderGradient 2s infinite alternate ease-in-out;
            position: relative;
        }

        @keyframes sliderGradient {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        .custom-settings .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(120deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 24px #00f2fe, 0 0 8px #4facfe;
            border: 3px solid #fff;
            transition: all 0.2s;
        }

        .custom-settings .settings-slider:active::-webkit-slider-thumb,
        .custom-settings .settings-slider:hover::-webkit-slider-thumb {
            transform: scale(1.18);
            box-shadow: 0 0 40px #00f2fe, 0 0 16px #4facfe;
        }

        .custom-settings .settings-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(120deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 24px #00f2fe, 0 0 8px #4facfe;
            border: 3px solid #fff;
            transition: all 0.2s;
        }

        .custom-settings .settings-slider:active::-moz-range-thumb,
        .custom-settings .settings-slider:hover::-moz-range-thumb {
            transform: scale(1.18);
            box-shadow: 0 0 40px #00f2fe, 0 0 16px #4facfe;
        }

        .custom-settings .settings-slider::-ms-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(120deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 24px #00f2fe, 0 0 8px #4facfe;
            border: 3px solid #fff;
            transition: all 0.2s;
        }

        .custom-settings .settings-slider:active::-ms-thumb,
        .custom-settings .settings-slider:hover::-ms-thumb {
            transform: scale(1.18);
            box-shadow: 0 0 40px #00f2fe, 0 0 16px #4facfe;
        }

        .custom-settings .settings-slider:focus {
            box-shadow: 0 0 24px #00f2fe99;
        }

        .custom-settings .settings-value {
            font-size: 13px;
            color: #4facfe;
            opacity: 0.85;
            text-align: right;
            margin-bottom: 6px;
        }

        .custom-settings .settings-button {
            background: linear-gradient(90deg, rgba(79, 172, 254, 0.18), rgba(0, 242, 254, 0.12));
            border: 2px solid #4facfe;
            color: #fff;
            font-weight: bold;
            letter-spacing: 1.2px;
            box-shadow: 0 0 12px 2px #00f2fe33;
            position: relative;
            overflow: hidden;
            transition: all 0.25s cubic-bezier(.4, 0, .2, 1);
        }

        .custom-settings .settings-button::after {
            content: '';
            position: absolute;
            left: -60%;
            top: 0;
            width: 60%;
            height: 100%;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.18) 0%, rgba(0, 242, 254, 0.12) 100%);
            transform: skewX(-20deg);
            transition: left 0.4s;
        }

        .custom-settings .settings-button:hover::after {
            left: 120%;
        }

        .custom-settings .settings-button:hover {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: #fff;
            box-shadow: 0 0 32px 8px #00f2fe99, 0 0 12px 4px #4facfe99;
            border-color: #00f2fe;
        }

        .custom-settings .color-picker {
            border: 2.5px solid;
            border-image: linear-gradient(120deg, #4facfe 0%, #00f2fe 100%) 1;
            box-shadow: 0 0 24px 4px #00f2fe55 inset, 0 0 32px 8px #4facfe33;
            background: linear-gradient(120deg, rgba(10, 20, 40, 0.95) 60%, rgba(0, 242, 254, 0.08) 100%);
            border-radius: 12px;
            margin-bottom: 18px;
            transition: box-shadow 0.4s, border-color 0.4s, border-image 0.4s;
            position: relative;
            overflow: visible;
            animation: colorPickerGlow 2.5s infinite alternate;
        }

        .custom-settings .color-picker::after {
            content: '';
            position: absolute;
            inset: -4px;
            border-radius: 16px;
            pointer-events: none;
            background: linear-gradient(120deg, #4facfe44 0%, #00f2fe33 100%);
            filter: blur(8px);
            opacity: 0.7;
            z-index: 0;
        }

        .custom-settings .color-picker:hover {
            box-shadow: 0 0 48px 12px #00f2fecc inset, 0 0 48px 16px #4facfe99;
            border-image: linear-gradient(120deg, #00f2fe 0%, #4facfe 100%) 1;
        }

        @keyframes colorPickerGlow {
            0% {
                box-shadow: 0 0 24px 4px #00f2fe55 inset, 0 0 32px 8px #4facfe33;
            }

            100% {
                box-shadow: 0 0 48px 12px #00f2fecc inset, 0 0 48px 16px #4facfe99;
            }
        }

        .custom-settings .color-picker-label {
            color: #4facfe;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 1px;
            text-shadow: 0 0 8px #00f2fe88;
            z-index: 1;
        }

        .custom-settings .color-picker-input {
            box-shadow: 0 0 16px #00f2fe88 inset, 0 0 8px #4facfe44;
            border: 2.5px solid #4facfe;
            border-radius: 8px;
            height: 38px;
            width: 60px;
            margin-left: 12px;
            background: rgba(0, 0, 0, 0.25);
            transition: box-shadow 0.4s, border-color 0.4s;
            outline: none;
            z-index: 1;
            animation: colorInputBreath 2.5s infinite alternate;
        }

        .custom-settings .color-picker-input:hover,
        .custom-settings .color-picker-input:focus {
            box-shadow: 0 0 32px #00f2fe, 0 0 12px #4facfe;
            border-color: #00f2fe;
        }

        @keyframes colorInputBreath {
            0% {
                box-shadow: 0 0 16px #00f2fe88 inset, 0 0 8px #4facfe44;
            }

            100% {
                box-shadow: 0 0 32px #00f2fecc inset, 0 0 16px #4facfe99;
            }
        }

        .custom-settings .ring-controls {
            border-top: 2px solid #00f2fe;
            box-shadow: 0 0 32px 8px #00f2fe44 inset;
            margin-top: 24px;
            padding-top: 24px;
            animation: glow 2s infinite alternate;
        }

        @media (max-width: 600px) {
            .custom-settings {
                padding: 4px 2px 8px 2px;
                border-radius: 10px;
            }

            .custom-settings .settings-group {
                padding: 10px 4px 10px 4px;
                border-radius: 8px;
            }
        }

        .settings-title {
            font-size: 18px;
            margin-bottom: 15px;
            font-weight: bold;
            color: #4facfe;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
        }

        .settings-close {
            cursor: pointer;
            font-size: 24px;
            opacity: 0.7;
            transition: all 0.3s;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(79, 172, 254, 0.1);
        }

        .settings-close:hover {
            opacity: 1;
            background: rgba(79, 172, 254, 0.2);
            transform: rotate(90deg);
        }

        .settings-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(79, 172, 254, 0.1);
        }

        .settings-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #4facfe;
            text-shadow: 0 0 5px rgba(79, 172, 254, 0.3);
        }

        .settings-slider {
            width: 100%;
            height: 6px;
            margin-bottom: 12px;
            background: rgba(79, 172, 254, 0.1);
            border-radius: 3px;
            outline: none;
        }

        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
            transition: all 0.2s;
        }

        .settings-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.8);
        }

        .settings-value {
            font-size: 12px;
            opacity: 0.8;
            text-align: right;
            color: #4facfe;
        }

        .settings-button {
            background: rgba(79, 172, 254, 0.1);
            border: 1px solid rgba(79, 172, 254, 0.2);
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .settings-button:hover {
            background: rgba(79, 172, 254, 0.2);
            border-color: rgba(79, 172, 254, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.2);
        }

        .settings-button.active {
            background: #4facfe;
            border-color: #4facfe;
            color: white;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.4);
        }

        /* 颜色选择器 */
        .color-picker {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 6px;
        }

        .color-picker-label {
            width: 80px;
            font-size: 13px;
            color: #4facfe;
        }

        .color-picker-input {
            flex-grow: 1;
            height: 30px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .color-picker-input:hover {
            transform: scale(1.05);
        }

        /* 行星环控制 */
        .ring-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(79, 172, 254, 0.2);
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px rgba(79, 172, 254, 0.2);
            }

            to {
                box-shadow: 0 0 15px rgba(79, 172, 254, 0.4);
            }
        }

        /* 响应式调整 */
        @media (max-width: 480px) {
            .settings-panel {
                max-width: calc(100% - 40px);
                max-height: 80vh;
            }

            .settings-button {
                padding: 6px 12px;
                font-size: 12px;
            }

            .settings-title {
                font-size: 16px;
            }
        }

        #stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .star {
            position: absolute;
            border-radius: 50%;
            opacity: var(--opacity, 1);
            animation: star-flicker var(--duration, 10s) infinite alternate;
        }

        @keyframes star-flicker {
            0% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        .starfield-bg {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(2px 2px at 20px 30px, rgba(255, 255, 255, 0.9), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 40px 70px, rgba(255, 255, 255, 0.8), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 50px 160px, rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0)),
                radial-gradient(3px 3px at 120px 10px, rgba(255, 255, 255, 0.8), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 140px 200px, rgba(255, 255, 255, 0.9), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 200px 180px, rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 250px 50px, rgba(255, 255, 255, 0.8), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 300px 100px, rgba(255, 255, 255, 0.9), rgba(0, 0, 0, 0));
            background-repeat: repeat;
            background-size: 400px 400px;
            animation: starfield-rotate 240s linear infinite;
            opacity: 0.6;
            z-index: 0;
        }

        @keyframes starfield-rotate {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 400px 400px;
            }
        }

        .cosmic-glow {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 120vw;
            height: 120vh;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse at center,
                    rgba(0, 247, 255, 0.15) 0%,
                    rgba(0, 100, 255, 0.1) 40%,
                    rgba(0, 0, 100, 0.05) 60%,
                    transparent 80%);
            z-index: 1;
            animation: cosmic-pulse 8s ease-in-out infinite alternate;
            pointer-events: none;
        }

        @keyframes cosmic-pulse {
            0% {
                opacity: 0.5;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        .space-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            z-index: 2;
            pointer-events: none;
        }

        .space-particle {
            position: absolute;
            border-radius: 50%;
            background: rgba(0, 247, 255, 0.2);
            pointer-events: none;
            opacity: 0.4;
            box-shadow: 0 0 12px 4px rgba(0, 247, 255, 0.15);
            animation: space-particle-float 8s infinite ease-in-out;
        }

        @keyframes space-particle-float {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0.4;
            }

            50% {
                transform: translateY(-20px) scale(1.2);
                opacity: 0.7;
            }

            100% {
                transform: translateY(0) scale(1);
                opacity: 0.4;
            }
        }

        .settings-button#settingsButton {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(79, 172, 254, 0.3);
            border-radius: 12px;
            color: #4facfe;
            cursor: pointer;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: settingsGlow 2s infinite alternate;
        }

        .settings-button#settingsButton:hover {
            background: rgba(79, 172, 254, 0.2);
            border-color: rgba(79, 172, 254, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(79, 172, 254, 0.4);
        }

        .settings-button#settingsButton svg {
            width: 24px;
            height: 24px;
            transition: all 0.3s ease;
        }

        .settings-button#settingsButton:hover svg {
            transform: rotate(90deg);
            color: #fff;
        }

        @keyframes settingsGlow {
            0% {
                box-shadow: 0 0 10px rgba(79, 172, 254, 0.2);
            }

            100% {
                box-shadow: 0 0 20px rgba(79, 172, 254, 0.4);
            }
        }

        /* 新增：宇宙科技感动态背景和流光动画 */
        .cosmic-bg {
            position: absolute;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background: radial-gradient(ellipse at 60% 40%, rgba(0, 255, 255, 0.08) 0%, rgba(0, 0, 40, 0.12) 60%, transparent 100%),
                repeating-linear-gradient(120deg, rgba(79, 172, 254, 0.08) 0 2px, transparent 2px 40px);
            animation: cosmicMove 30s linear infinite;
        }

        @keyframes cosmicMove {
            0% {
                background-position: 0 0, 0 0;
            }

            100% {
                background-position: 200px 200px, 200px 400px;
            }
        }

        .star-dust {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }

        .star-dust span {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(90deg, #fff, #4facfe, #00f2fe, #fff);
            opacity: 0.7;
            filter: blur(1px);
            animation: starTwinkle 3s infinite alternate;
        }

        @keyframes starTwinkle {
            0% {
                opacity: 0.5;
                transform: scale(1);
            }

            100% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* 设置面板美化 */
        .settings-panel {
            background: rgba(10, 20, 40, 0.85);
            box-shadow: 0 0 40px 10px rgba(0, 255, 255, 0.08), 0 0 0 1.5px rgba(79, 172, 254, 0.18) inset;
            border: 1.5px solid rgba(79, 172, 254, 0.25);
            overflow: visible;
        }

        .settings-panel::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            pointer-events: none;
            background: linear-gradient(120deg, rgba(79, 172, 254, 0.08) 0%, rgba(0, 242, 254, 0.06) 100%);
            z-index: 0;
        }

        .settings-title {
            background: linear-gradient(90deg, #4facfe 10%, #00f2fe 90%);
            -webkit-text-fill-color: transparent;
            font-size: 22px;
            letter-spacing: 2px;
            text-shadow: 0 0 18px #00f2fe, 0 0 8px #4facfe;
            position: relative;
            animation: titleGlow 2.5s infinite alternate;
        }

        @keyframes titleGlow {
            0% {
                text-shadow: 0 0 8px #4facfe, 0 0 18px #00f2fe;
            }

            100% {
                text-shadow: 0 0 18px #4facfe, 0 0 32px #00f2fe;
            }
        }

        .settings-group {
            background: rgba(20, 30, 60, 0.7);
            border: 1.5px solid rgba(79, 172, 254, 0.18);
            box-shadow: 0 0 16px 2px rgba(0, 255, 255, 0.06) inset;
            position: relative;
            overflow: visible;
        }

        .settings-group::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 8px;
            pointer-events: none;
            border: 1.5px solid transparent;
            background: linear-gradient(120deg, rgba(79, 172, 254, 0.18), rgba(0, 242, 254, 0.12));
            opacity: 0.5;
            z-index: 0;
        }

        .custom-settings[style*="display: block"] {
            box-shadow: 0 0 32px 4px rgba(0, 255, 255, 0.12) inset;
            border-top: 2px solid #00f2fe;
            animation: customGlow 2s infinite alternate;
        }

        @keyframes customGlow {
            0% {
                box-shadow: 0 0 16px 2px #4facfe inset;
            }

            100% {
                box-shadow: 0 0 32px 8px #00f2fe inset;
            }
        }

        .settings-button {
            background: linear-gradient(90deg, rgba(79, 172, 254, 0.18), rgba(0, 242, 254, 0.12));
            border: 1.5px solid #4facfe;
            color: #fff;
            font-weight: bold;
            letter-spacing: 1.2px;
            box-shadow: 0 0 8px 2px #00f2fe33;
            position: relative;
            overflow: hidden;
            transition: all 0.25s cubic-bezier(.4, 0, .2, 1);
        }

        .settings-button::after {
            content: '';
            position: absolute;
            left: -60%;
            top: 0;
            width: 60%;
            height: 100%;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.18) 0%, rgba(0, 242, 254, 0.12) 100%);
            transform: skewX(-20deg);
            transition: left 0.4s;
        }

        .settings-button:hover::after {
            left: 120%;
        }

        .settings-button:hover {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: #fff;
            box-shadow: 0 0 24px 4px #00f2fe99, 0 0 8px 2px #4facfe99;
            border-color: #00f2fe;
        }

        .settings-slider {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 8px #00f2fe44 inset;
            border-radius: 4px;
            height: 8px;
        }

        .settings-slider::-webkit-slider-thumb {
            background: linear-gradient(120deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 0 16px #00f2fe, 0 0 4px #4facfe;
            border: 2px solid #fff;
        }

        .settings-slider:active::-webkit-slider-thumb {
            box-shadow: 0 0 32px #00f2fe, 0 0 8px #4facfe;
        }

        .color-picker {
            border: 1.5px solid #00f2fe;
            box-shadow: 0 0 8px #00f2fe44 inset;
            background: rgba(10, 20, 40, 0.6);
        }

        .color-picker-input {
            box-shadow: 0 0 8px #00f2fe44 inset;
            border: 1.5px solid #4facfe;
        }

        .color-picker-input:hover {
            box-shadow: 0 0 16px #00f2fe, 0 0 4px #4facfe;
        }

        .ring-controls {
            border-top: 2px solid #00f2fe;
            box-shadow: 0 0 24px 2px #00f2fe44 inset;
        }

        /* 右下角操作说明美化 */
        .control-panel {
            background: rgba(5, 15, 35, 0.85);
            box-shadow: 0 0 60px 15px rgba(0, 255, 255, 0.15),
                0 0 100px 20px rgba(0, 180, 255, 0.12),
                0 0 0 2px rgba(79, 172, 254, 0.25) inset;
            border: 2px solid rgba(79, 172, 254, 0.35);
            border-radius: 18px;
            animation: floatPanel 8s ease-in-out infinite alternate;
            overflow: visible;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 22px 20px;
            position: relative;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .control-panel::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 18px;
            background: linear-gradient(135deg,
                    transparent 30%,
                    rgba(79, 172, 254, 0.08) 40%,
                    rgba(0, 242, 254, 0.06) 60%,
                    transparent 70%);
            opacity: 0;
            z-index: 0;
            animation: panelGlare 4s infinite alternate ease-in-out;
        }

        @keyframes panelGlare {

            0%,
            20% {
                opacity: 0;
                transform: translateY(8px);
            }

            80%,
            100% {
                opacity: 1;
                transform: translateY(-8px);
            }
        }

        @keyframes floatPanel {
            0% {
                transform: translateY(0);
            }

            100% {
                transform: translateY(-10px);
            }
        }

        .control-title {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 50%, #80d0ff 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            font-size: 22px;
            font-weight: 600;
            letter-spacing: 3px;
            text-shadow: 0 0 22px #00f2fe, 0 0 12px #4facfe, 0 0 36px rgba(0, 242, 254, 0.5);
            animation: titleGlow 2.5s infinite alternate, titleShimmer 3s infinite linear;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px;
            padding: 5px 0;
            position: relative;
        }

        @keyframes titleShimmer {
            0% {
                background-position: 0% center;
            }

            50% {
                background-position: 100% center;
            }

            100% {
                background-position: 0% center;
            }
        }

        .control-minimize {
            cursor: pointer;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(10, 25, 50, 0.6);
            color: #4facfe;
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            margin-left: 10px;
            box-shadow: 0 0 15px rgba(0, 242, 254, 0.3),
                inset 0 0 8px rgba(79, 172, 254, 0.2);
            border: 1.5px solid rgba(79, 172, 254, 0.25);
            position: relative;
            overflow: hidden;
            animation: minimizePulse 2s infinite alternate ease-in-out;
        }

        @keyframes minimizePulse {
            0% {
                box-shadow: 0 0 12px rgba(0, 242, 254, 0.3),
                    inset 0 0 8px rgba(79, 172, 254, 0.2);
            }

            100% {
                box-shadow: 0 0 20px rgba(0, 242, 254, 0.5),
                    inset 0 0 12px rgba(79, 172, 254, 0.4);
            }
        }

        .control-minimize:before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(79, 172, 254, 0.1) 0%, transparent 60%);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .control-minimize:hover:before {
            opacity: 1;
        }

        .control-minimize:hover {
            background: rgba(15, 40, 80, 0.8);
            transform: scale(1.15) rotate(-10deg);
            box-shadow: 0 0 25px rgba(0, 242, 254, 0.6),
                0 0 50px rgba(79, 172, 254, 0.2),
                inset 0 0 15px rgba(79, 172, 254, 0.4);
            border-color: rgba(0, 242, 254, 0.5);
        }

        .control-minimize:active {
            transform: scale(0.95);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.3),
                inset 0 0 5px rgba(79, 172, 254, 0.2);
        }

        .control-minimize svg {
            filter: drop-shadow(0 0 3px rgba(0, 242, 254, 0.8));
            transition: all 0.4s ease;
        }

        .control-minimize:hover svg {
            filter: drop-shadow(0 0 6px rgba(0, 242, 254, 1));
            transform: scale(1.1);
        }

        .control-mini-icon {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(10, 20, 40, 0.85);
            border-radius: 50%;
            width: 52px;
            height: 52px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.35),
                0 0 50px rgba(79, 172, 254, 0.2),
                inset 0 0 12px rgba(0, 242, 254, 0.2);
            border: 2px solid rgba(79, 172, 254, 0.35);
            animation: miniIconPulse 3s infinite alternate;
        }

        @keyframes miniIconPulse {
            0% {
                box-shadow: 0 0 20px rgba(0, 242, 254, 0.35),
                    0 0 50px rgba(79, 172, 254, 0.2),
                    inset 0 0 12px rgba(0, 242, 254, 0.2);
            }

            100% {
                box-shadow: 0 0 26px rgba(0, 242, 254, 0.45),
                    0 0 60px rgba(79, 172, 254, 0.3),
                    inset 0 0 18px rgba(0, 242, 254, 0.3);
            }
        }

        .control-mini-icon:hover {
            transform: scale(1.15);
            box-shadow: 0 0 30px rgba(0, 242, 254, 0.6),
                0 0 70px rgba(79, 172, 254, 0.4),
                inset 0 0 20px rgba(0, 242, 254, 0.4);
            border-color: rgba(0, 242, 254, 0.6);
        }

        .control-mini-icon .control-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4facfe;
            filter: drop-shadow(0 0 6px rgba(0, 242, 254, 0.8));
            transition: all 0.3s ease;
        }

        .control-mini-icon:hover .control-icon {
            transform: rotate(10deg);
            filter: drop-shadow(0 0 10px rgba(0, 242, 254, 1));
            color: #ffffff;
        }

        .control-item {
            background: rgba(10, 30, 60, 0.75);
            border: 1.5px solid rgba(0, 242, 254, 0.3);
            box-shadow: 0 0 16px 4px rgba(0, 242, 254, 0.15) inset,
                0 4px 12px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(.4, 0, .2, 1);
            border-radius: 10px;
            padding: 12px 14px;
            margin-bottom: 12px;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            transform: translateZ(0);
        }

        .control-item:last-child {
            margin-bottom: 0;
        }

        .control-item::after {
            content: '';
            position: absolute;
            left: -60%;
            top: 0;
            width: 60%;
            height: 100%;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.12) 0%, rgba(0, 242, 254, 0.08) 100%);
            transform: skewX(-20deg);
            transition: left 0.4s;
        }

        .control-item:hover::after {
            left: 120%;
        }

        .control-item:hover {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.9) 0%, rgba(0, 242, 254, 0.9) 100%);
            color: #fff;
            box-shadow: 0 0 30px 6px rgba(0, 242, 254, 0.6),
                0 0 50px 10px rgba(79, 172, 254, 0.3),
                0 6px 16px rgba(0, 0, 0, 0.3);
            border-color: rgba(0, 242, 254, 0.7);
            transform: translateY(-3px) scale(1.02) translateZ(0);
        }

        .control-icon {
            background: linear-gradient(120deg, #4facfe 0%, #00f2fe 100%);
            color: #fff;
            box-shadow: 0 0 12px rgba(0, 242, 254, 0.4) inset,
                0 0 20px rgba(79, 172, 254, 0.2);
            border: 2px solid rgba(79, 172, 254, 0.7);
            animation: iconPulse 3s infinite alternate ease-in-out;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 14px;
            font-size: 18px;
            position: relative;
            z-index: 1;
        }

        .control-icon::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(0, 242, 254, 0.4) 0%, transparent 70%);
            z-index: -1;
            opacity: 0.6;
            animation: iconGlowPulse 2s infinite alternate ease-in-out;
        }

        @keyframes iconPulse {
            0% {
                box-shadow: 0 0 12px rgba(0, 242, 254, 0.4) inset,
                    0 0 20px rgba(79, 172, 254, 0.2);
            }

            100% {
                box-shadow: 0 0 22px rgba(0, 242, 254, 0.7) inset,
                    0 0 30px rgba(79, 172, 254, 0.4);
            }
        }

        @keyframes iconGlowPulse {
            0% {
                opacity: 0.4;
                transform: scale(1);
            }

            100% {
                opacity: 0.8;
                transform: scale(1.15);
            }
        }

        .control-item:hover .control-icon {
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(0, 242, 254, 0.8) inset,
                0 0 40px rgba(79, 172, 254, 0.5);
        }

        /* 左下角信息面板美化 */
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            border-radius: 12px;
            padding: 18px 28px 18px 24px;
            min-width: 260px;
            max-width: 350px;
            overflow: visible;
            display: flex;
            align-items: center;
            gap: 18px;
            transition: box-shadow 0.4s, background 0.4s;
        }

        .info-panel:hover {
            /* box-shadow: 0 0 60px 20px #00f2fe99, 0 0 0 2px #4facfe99; */
            background: rgba(10, 20, 60, 0.95);
        }

        .info-panel .star-dust {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .info-title {
            /* background: linear-gradient(90deg, #fff 10%, #4facfe 40%, #00f2fe 60%, #fff 90%); */
            /* -webkit-text-fill-color: transparent; */
            color: #fff;
            font-size: 26px;
            font-weight: bold;
            letter-spacing: 2.5px;
            text-shadow: 0 0 12px #00f2fe, 0 0 2px #4facfe;
            animation: infoTitlePulse 2.5s infinite alternate, infoTitleFlow 6s linear infinite;
            position: relative;
            overflow: visible;
        }

        .glow-text {
            background: linear-gradient(90deg,
                    #ff0000 0%,
                    #ff9900 16%,
                    #ffee00 33%,
                    #33ff00 50%,
                    #00eaff 66%,
                    #0055ff 83%,
                    #cc00ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            font-weight: bold;
            letter-spacing: 2px;
            font-size: 26px;
            text-shadow: none !important;
            filter: none !important;
        }

        /* 删除.info-title .info-flow动画长方形 */
        /* .info-title .info-flow {
            position: absolute;
            left: 0; top: 0; height: 100%; width: 100%;
            pointer-events: none;
            background: linear-gradient(120deg, rgba(79,172,254,0.2) 0%, rgba(0,242,254,0.18) 100%);
            filter: blur(8px);
            opacity: 0.7;
            z-index: 1;
            animation: infoFlowMove 3s linear infinite;
        } */
        @keyframes infoFlowMove {
            0% {
                left: -100%;
            }

            100% {
                left: 100%;
            }
        }

        .info-panel .star-dust {
            z-index: 0;
        }

        .info-title {
            /* background: linear-gradient(90deg, #fff 10%, #4facfe 40%, #00f2fe 60%, #fff 90%); */
            /* -webkit-text-fill-color: transparent; */
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 24px #00f2fe, 0 0 12px #4facfe, 0 0 2px #fff;
            animation: infoTitlePulse 2.5s infinite alternate, infoTitleFlow 6s linear infinite;
            position: relative;
        }

        @keyframes infoTitlePulse {
            0% {
                text-shadow: 0 0 12px #4facfe, 0 0 24px #00f2fe, 0 0 2px #fff;
            }

            100% {
                text-shadow: 0 0 24px #4facfe, 0 0 48px #00f2fe, 0 0 8px #fff;
            }
        }

        @keyframes infoTitleFlow {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        .settings-panel {
            max-height: 90vh;
            overflow-y: auto;
            padding-bottom: 24px;
        }

        @media (max-width: 800px) {
            .settings-panel {
                max-width: calc(100% - 20px);
                max-height: 80vh;
                padding: 10px 6px 18px 6px;
            }
        }

        @media (max-width: 480px) {
            .settings-panel {
                max-width: calc(100% - 8px);
                max-height: 70vh;
                padding: 6px 2px 12px 2px;
            }
        }

        .custom-settings {
            max-height: none !important;
            overflow: visible !important;
            margin-bottom: 0;
        }

        .settings-group {
            margin-bottom: 16px;
        }

        .starflow-effect-text {
            position: relative;
            display: inline-block;
            background: linear-gradient(120deg,
                    #ff0000 0%,
                    /* 红 */
                    #ff9900 16%,
                    /* 橙 */
                    #ffee00 33%,
                    /* 黄 */
                    #33ff00 50%,
                    /* 绿 */
                    #00eaff 66%,
                    /* 青 */
                    #0055ff 83%,
                    /* 蓝 */
                    #cc00ff 100%
                    /* 紫 */
                );
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            animation: starflow-gradient 2.5s linear infinite;
            filter: drop-shadow(0 0 12px #00f2fe) drop-shadow(0 0 24px #4facfe);
            transition: filter 0.4s, transform 0.4s;
            z-index: 1;
        }

        @keyframes starflow-gradient {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 200% 50%;
            }
        }

        .info-title:hover .starflow-effect-text {
            filter: drop-shadow(0 0 32px #fff) drop-shadow(0 0 64px #00f2fe) brightness(1.3);
            transform: scale(1.08) rotate(-1deg);
        }

        .starflow-canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .info-title:hover .starflow-canvas {
            opacity: 1;
        }

        .info-title-center {
            position: fixed;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            background: none;
            box-shadow: none;
            min-width: unset;
            max-width: 90vw;
            padding: 0 24px;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
            transition: transform 0.4s;
        }

        .info-title-center:hover {
            transform: translateX(-50%) scale(1.06);
        }

        @media (max-width: 600px) {
            .info-title-center {
                top: 10px;
                padding: 0 6px;
                font-size: 16px;
            }
        }

        /* 确保星梦游Xmy|粒子宇宙链接没有下划线 */
        .starflow-effect-text a {
            text-decoration: none !important;
        }
    </style>
</head>

<body>
        <!-- 自定义鼠标指针 -->
        <div class="custom-cursor" id="custom-cursor">
            <div class="cursor-core"></div>
            <div class="cursor-ring"></div>
        </div>
    
        <!-- 鼠标尾迹效果 -->
        <div id="cursor-trails"></div>
    <div class="starfield-bg"></div>
    <div class="cosmic-glow"></div>
    <div class="space-particles"></div>
    <div id="stars-container"></div>
    <!-- 如有canvas星空背景，也插入 -->
    <canvas id="interstellar-canvas"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:0;pointer-events:none;display:none"></canvas>
    <!-- 加载屏幕 -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title pulse">@ 星梦游Xmy | 粒子宇宙</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-percentage" id="loadingPercentage">0%</div>

        <div class="loading-hint">百万粒子披星戴月向你奔赴而来...</div>
        <div class="loading-screen" id="loadingScreen" style="background: #000;">
            <video id="introVideo" src="moon-sea.mp4" autoplay loop muted playsinline
                style="width:100vw;height:100vh;object-fit:cover;position:fixed;top:0;left:0;z-index:9999;outline:none;"
                preload="auto" tabindex="-1"></video>

        </div>
    </div>

    <!-- 画布 -->
    <canvas id="canvas"></canvas>

    <!-- 信息面板 -->
    <div class="info-panel" style="position: fixed; bottom: 20px; left: 20px; z-index: 10;">
        <div class="star-dust"></div>
    </div>
    <!-- 页面顶部正中间的标题 -->
    <div class="info-title cosmic-glow-text info-title-center">
        <span class="glow-text">
            <span class="starflow-effect-text"><a href="mind-universe.html">@星梦游Xmy|粒子宇宙</a></span>

            <canvas class="starflow-canvas"></canvas>
        </span>
        <span class="info-flow"></span>
    </div>

    <!-- 控制面板 -->
    <div class="control-panel" id="controlPanel">
        <div class="cosmic-bg"></div>
        <div class="star-dust"></div>
        <div class="control-title">
            鼠标控制
            <span class="control-minimize" id="controlMinimize" title="最小化">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="minimizeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#4facfe" />
                            <stop offset="100%" stop-color="#00f2fe" />
                        </linearGradient>
                        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="1.5" result="blur" />
                            <feFlood flood-color="#00f2fe" flood-opacity="0.7" result="glow" />
                            <feComposite in="glow" in2="blur" operator="in" result="coloredBlur" />
                            <feMerge>
                                <feMergeNode in="coloredBlur" />
                                <feMergeNode in="SourceGraphic" />
                            </feMerge>
                        </filter>
                    </defs>
                    <rect x="6" y="11" width="12" height="2" rx="1" fill="url(#minimizeGrad)" filter="url(#glow)" />
                    <circle cx="12" cy="12" r="10" stroke="url(#minimizeGrad)" stroke-width="1.5" fill="none"
                        opacity="0.6" />
                </svg>
            </span>
        </div>
        <div class="control-item">
            <div class="control-icon">🖱️</div>
            <div>滑动滚轮 - 缩放距离</div>
        </div>
        <div class="control-item">
            <div class="control-icon">🖱️</div>
            <div>拖动右键 - 控制星环</div>
        </div>
        <div class="control-item">
            <div class="control-icon">🖱️</div>
            <div>长按左键 - 加速星环</div>
        </div>
        <div class="control-item">
            <div class="control-icon">🖱️</div>
            <div>长按滚轮 - 重归流浪</div>
        </div>
    </div>

    <!-- 最小化后的控制图标 -->
    <div class="control-mini-icon" id="controlMiniIcon" style="display: none;">
        <div class="control-icon">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4M9,7.5C9,6.67 9.67,6 10.5,6C11.33,6 12,6.67 12,7.5C12,8.33 11.33,9 10.5,9C9.67,9 9,8.33 9,7.5M16,11C16,12.5 14.33,14.15 12,16.07C9.67,14.15 8,12.5 8,11C8,9.03 9.66,7.5 12,7.5C14.34,7.5 16,9.03 16,11Z"
                    fill="currentColor" />
                <path
                    d="M6,18C6.55,18 7,18.45 7,19C7,19.55 6.55,20 6,20C5.45,20 5,19.55 5,19C5,18.45 5.45,18 6,18M6,16C4.34,16 3,17.34 3,19C3,20.66 4.34,22 6,22C7.66,22 9,20.66 9,19C9,17.34 7.66,16 6,16L6,16Z"
                    fill="url(#grad1)" />
                <defs>
                    <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="#4facfe" />
                        <stop offset="100%" stop-color="#00f2fe" />
                    </linearGradient>
                </defs>
            </svg>
        </div>
    </div>


    <!-- 设置面板 -->
    <div class="settings-panel" id="settingsPanel">
        <div class="cosmic-bg"></div>
        <div class="star-dust"></div>
        <div class="settings-title">
            <br>
            <span>预设选项</span>
            <span class="settings-close" id="settingsClose">×</span>
        </div>

        <!-- 预设按钮组 -->
        <div class="settings-group presets-group">
            <button class="settings-button" id="IndefinablePreset">神秘体(开场天体)</button>
            <button class="settings-button" id="wormholePreset">神秘体内星际穿越-虫洞</button>
            <button class="settings-button" id="blackHolePreset">黑洞</button>
            <button class="settings-button" id="whiteHolePreset">白洞</button>
            <button class="settings-button" id="galaxyPreset">七彩银河系</button><br>
            <button class="settings-button" id="nebulaPreset">螺旋星云</button>
            <button class="settings-button" id="sunPreset">太阳</button>
            <button class="settings-button" id="clourfulPlantPreset">缤纷彩星</button>
            <button class="settings-button" id="seaBluePreset">海洋蓝星-可自定义星球</button>
            <button class="settings-button" id="resetPreset">重置</button>
        </div>

        <!-- 自定义参数组 - 默认隐藏 -->
        <div class="custom-settings" id="customSettings" style="display: none;">
            <canvas id="customStarsBg"
                style="position:absolute;left:0;top:0;width:100%;height:100%;z-index:0;pointer-events:none;"></canvas>
            <div
                style="width:100%;display:flex;justify-content:center;align-items:center;z-index:1;position:relative;margin-bottom:10px;">
                <svg width="180" height="32" viewBox="0 0 180 32" fill="none" xmlns="http://www.w3.org/2000/svg"
                    style="filter:blur(1.5px);opacity:0.7;">
                    <ellipse cx="90" cy="16" rx="80" ry="10" fill="url(#starRingGradient)" />
                    <defs>
                        <radialGradient id="starRingGradient" cx="0.5" cy="0.5" r="0.5" fx="0.5" fy="0.5">
                            <stop offset="0%" stop-color="#b6eaff" stop-opacity="0.7" />
                            <stop offset="60%" stop-color="#4facfe" stop-opacity="0.5" />
                            <stop offset="100%" stop-color="#00f2fe" stop-opacity="0.1" />
                        </radialGradient>
                    </defs>
                </svg>
            </div>
            <div class="star-dust"></div>
            <div class="settings-title">
                <span>自定义星球参数</span>
            </div>

            <div class="settings-group">
                <div class="settings-label">粒子数量: <span id="particleCountValue">50,000</span></div>
                <input type="range" class="settings-slider" id="particleCountSlider" min="1000" max="500000" step="1000"
                    value="100000">

                <div class="settings-label">粒子大小: <span id="particleSizeValue">0.1</span></div>
                <input type="range" class="settings-slider" id="particleSizeSlider" min="0.0001" max="0.5" step="0.01"
                    value="0.1">

                <div class="settings-label">星球半径: <span id="planetRadiusValue">15</span></div>
                <input type="range" class="settings-slider" id="planetRadiusSlider" min="5" max="30" step="1"
                    value="15">
            </div>

            <div class="settings-group">
                <div class="settings-label">旋转速度: <span id="rotationSpeedValue">0.5</span></div>
                <input type="range" class="settings-slider" id="rotationSpeedSlider" min="0" max="1000" step="5"
                    value="5">

                <div class="settings-label">缩放距离: <span id="zoomValue">50</span></div>
                <input type="range" class="settings-slider" id="zoomSlider" min="10" max="200" step="1" value="50">
            </div>

            <div class="settings-group">
                <div class="settings-label">粒子颜色:</div>
                <div class="color-picker">
                    <div class="color-picker-label">主颜色:</div>
                    <input type="color" class="color-picker-input" id="primaryColorPicker" value="#4facfe">
                </div>
                <div class="color-picker">
                    <div class="color-picker-label">次颜色:</div>
                    <input type="color" class="color-picker-input" id="secondaryColorPicker" value="#00f2fe">
                </div>
            </div>

            <div class="settings-group">
                <div class="settings-label">背景颜色:</div>
                <div class="color-picker">
                    <div class="color-picker-label">颜色:</div>
                    <input type="color" class="color-picker-input" id="bgColorPicker" value="#000000">
                </div>
            </div>

            <!-- 行星环设置 -->
            <div class="settings-group ring-controls">
                <div class="settings-label">行星环设置:</div>

                <div class="settings-label">环粒子数量: <span id="ringParticleCountValue">10,000</span></div>
                <input type="range" class="settings-slider" id="ringParticleCountSlider" min="1000" max="300000"
                    step="1000" value="10000">

                <div class="settings-label">环宽度: <span id="ringWidthValue">5</span></div>
                <input type="range" class="settings-slider" id="ringWidthSlider" min="1" max="10" step="0.5" value="5">

                <div class="settings-label">环半径: <span id="ringRadiusValue">25</span></div>
                <input type="range" class="settings-slider" id="ringRadiusSlider" min="15" max="40" step="1" value="25">

                <div class="settings-label">环旋转速度: <span id="ringRotationSpeedValue">0.3</span></div>
                <input type="range" class="settings-slider" id="ringRotationSpeedSlider" min="0" max="1000" step="5"
                    value="5">

                <div class="settings-label">环透明度: <span id="ringOpacityValue">0.7</span></div>
                <input type="range" class="settings-slider" id="ringOpacitySlider" min="0.1" max="1" step="0.05"
                    value="0.7">
            </div>
        </div>
    </div>
    <canvas id="followParticles" style="display:none;position:fixed;top:0;left:0;z-index:101;pointer-events:none;"></canvas>
    <!-- 设置按钮 -->
    <button class="settings-button" id="settingsButton"
        style="position: fixed; top: 20px; left: 20px; z-index: 10; padding: 10px 15px;">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path
                d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33 1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
            </path>
        </svg>
    </button>


    <!-- Three.js 库 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>





    <script>

        // ====== 烟花粒子特效 ======
        function fireworkAtBottom() {
            // 创建或复用canvas
            let fwCanvas = document.getElementById('firework-canvas');
            if (!fwCanvas) {
                fwCanvas = document.createElement('canvas');
                fwCanvas.id = 'firework-canvas';
                fwCanvas.style.position = 'fixed';
                fwCanvas.style.left = '0';
                fwCanvas.style.top = '0';
                fwCanvas.style.width = '100vw';
                fwCanvas.style.height = '100vh';
                fwCanvas.style.pointerEvents = 'none';
                fwCanvas.style.zIndex = '9999';
                document.body.appendChild(fwCanvas);
            }

            // 高精度渲染设置
            const dpr = window.devicePixelRatio || 1;
            fwCanvas.width = window.innerWidth * dpr;
            fwCanvas.height = window.innerHeight * dpr;
            const ctx = fwCanvas.getContext('2d', { alpha: true });
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = true;

            // 烟花参数
            const startX = Math.random() * (window.innerWidth * 0.8) + window.innerWidth * 0.1;
            const startY = window.innerHeight - 10;
            let peakY = window.innerHeight * (0.35 + Math.random() * 0.45);
            peakY = Math.max(0, Math.min(peakY, window.innerHeight));
            const peakX = startX + (Math.random() - 0.5) * 150;

            // 高级色彩配置
            const colorPalettes = [
                ['#ff5e62', '#ff9966', '#ffcc33', '#ff3366', '#ff99cc'], // 暖色调
                ['#4facfe', '#00f2fe', '#38f9d7', '#43e97b', '#a6c1ee'], // 冷色调
                ['#a18cd1', '#fbc2eb', '#fad0c4', '#ff9a9e', '#f6d365'], // 粉彩色
                ['#667eea', '#764ba2', '#89f7fe', '#66a6ff', '#b06ab3'], // 紫蓝色
                ['#ff8a00', '#e100ff', '#3a7bd5', '#00d2ff', '#f46b45']  // 多彩
            ];

            // 随机选择一组配色方案
            const selectedPalette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];

            // 烟花轨迹类型 (0=直线, 1=正弦波, 2=螺旋, 3=随机抖动)
            const trajectoryType = Math.floor(Math.random() * 4);

            // 烟花主体
            const firework = {
                x: startX,
                y: startY,
                vx: (peakX - startX) / 40,
                vy: -(startY - peakY) / 40,
                age: 0,
                maxAge: 45 + Math.random() * 15,
                exploded: false,
                particles: [],
                trail: [],
                color: selectedPalette[Math.floor(Math.random() * selectedPalette.length)],
                size: 3 + Math.random() * 2,
                trajectoryType,
                spiralRadius: 5 + Math.random() * 15,
                spiralSpeed: 0.1 + Math.random() * 0.3,
                trailCount: 0
            };

            // 创建粒子 - 终极强化版
            function createParticles(cx, cy, baseColor) {
                const particles = [];
                const count = 300 + Math.floor(Math.random() * 200); // 更多粒子
                const hueVariation = 30 + Math.random() * 50;

                // 创建核心爆炸粒子 (更小更密集)
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1.5 + Math.random() * 5;
                    const color = getGradientColor(baseColor || selectedPalette[Math.floor(Math.random() * selectedPalette.length)], hueVariation);

                    particles.push({
                        x: cx,
                        y: cy,
                        vx: Math.cos(angle) * speed * (0.7 + Math.random() * 0.6),
                        vy: Math.sin(angle) * speed * (0.7 + Math.random() * 0.6),
                        alpha: 1,
                        color,
                        size: 0.5 + Math.random() * 1.5, // 更小的粒子
                        life: 0,
                        maxLife: 50 + Math.random() * 50,
                        type: 'spark',
                        decay: 0.92 + Math.random() * 0.05,
                        gravity: 0.02 + Math.random() * 0.03
                    });
                }

                // 创建闪光粒子 (更亮更多)
                const flashCount = 10 + Math.floor(Math.random() * 15);
                for (let i = 0; i < flashCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.8 + Math.random() * 2;

                    particles.push({
                        x: cx,
                        y: cy,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        alpha: 1,
                        color: '#ffffff',
                        size: 3 + Math.random() * 8,
                        life: 0,
                        maxLife: 20 + Math.random() * 15,
                        type: 'flash',
                        decay: 0.85 + Math.random() * 0.1
                    });
                }

                // 创建缓慢下落的星形粒子 (更多变化)
                const starCount = 20 + Math.floor(Math.random() * 30);
                for (let i = 0; i < starCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.3 + Math.random() * 1.2;
                    const color = getGradientColor(baseColor || selectedPalette[Math.floor(Math.random() * selectedPalette.length)], hueVariation);

                    particles.push({
                        x: cx,
                        y: cy,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        alpha: 1,
                        color,
                        size: 2 + Math.random() * 3,
                        life: 0,
                        maxLife: 100 + Math.random() * 60,
                        type: 'star',
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.15,
                        points: 5 + Math.floor(Math.random() * 4),
                        gravity: 0.01 + Math.random() * 0.02
                    });
                }

                return particles;
            }

            // 高级渐变颜色生成器
            function getGradientColor(baseColor, variation) {
                // 转换为HSL以便更好地控制颜色变化
                const hsl = hexToHSL(baseColor);

                // 随机调整色相、饱和度和亮度
                const newH = (hsl.h + (Math.random() - 0.5) * variation) % 360;
                const newS = Math.min(100, Math.max(80, hsl.s + (Math.random() - 0.5) * 20));
                const newL = Math.min(95, Math.max(50, hsl.l + (Math.random() - 0.5) * 15));

                return HSLToHex(newH, newS, newL);
            }

            // HEX转HSL
            function hexToHSL(hex) {
                let r = parseInt(hex.substring(1, 3), 16);
                let g = parseInt(hex.substring(3, 5), 16);
                let b = parseInt(hex.substring(5, 7), 16);
                r /= 255;
                g /= 255;
                b /= 255;

                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return {
                    h: Math.round(h * 360),
                    s: Math.round(s * 100),
                    l: Math.round(l * 100)
                };
            }

            // HSL转HEX
            function HSLToHex(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;

                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;

                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }

                const toHex = x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };

                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            // 动画循环
            let fireworks = fwCanvas._fireworks || [];
            fireworks.push(firework);
            fwCanvas._fireworks = fireworks;

            if (!fwCanvas._animating) {
                fwCanvas._animating = true;
                requestAnimationFrame(animate);
            }

            function animate() {
                // 使用半透明清除以创建拖尾效果
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.fillRect(0, 0, fwCanvas.width, fwCanvas.height);

                let stillAnimating = false;

                for (let fw of fwCanvas._fireworks) {
                    if (!fw.exploded) {
                        // === 升空阶段强化 ===
                        fw.age++;
                        fw.trailCount++;

                        // 根据轨迹类型计算位置
                        switch (fw.trajectoryType) {
                            case 0: // 直线
                                fw.x += fw.vx;
                                fw.y += fw.vy;
                                break;
                            case 1: // 正弦波
                                fw.x += fw.vx + Math.sin(fw.age / 5) * 4;
                                fw.y += fw.vy + Math.sin(fw.age / 8) * 3;
                                break;
                            case 2: // 螺旋
                                const spiralAngle = fw.age * fw.spiralSpeed;
                                fw.x += fw.vx + Math.cos(spiralAngle) * fw.spiralRadius * (fw.age / fw.maxAge);
                                fw.y += fw.vy + Math.sin(spiralAngle) * fw.spiralRadius * (fw.age / fw.maxAge);
                                fw.spiralRadius *= 0.97;
                                break;
                            case 3: // 随机抖动
                                fw.x += fw.vx + (Math.random() - 0.5) * 3;
                                fw.y += fw.vy + (Math.random() - 0.5) * 2;
                                break;
                        }
                        // 边界限制，防止烟花主体超出屏幕
                        fw.x = Math.max(0, Math.min(fw.x, fwCanvas.width));
                        fw.y = Math.max(0, Math.min(fw.y, fwCanvas.height));

                        // 记录轨迹点
                        if (fw.trailCount % 2 === 0) {
                            fw.trail.push({ x: fw.x, y: fw.y, alpha: 1, size: fw.size });
                            if (fw.trail.length > 20) fw.trail.shift();
                        }

                        // 更新轨迹点透明度
                        for (let i = 0; i < fw.trail.length; i++) {
                            fw.trail[i].alpha = i / fw.trail.length;
                            fw.trail[i].size = fw.size * (i / fw.trail.length) * 0.8;
                        }

                        // 重力影响 (逐渐增强)
                        fw.vy += 0.02 + (fw.age / fw.maxAge) * 0.05;

                        // 绘制轨迹 (更平滑的渐变)
                        if (fw.trail.length > 1) {
                            ctx.save();
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';

                            for (let i = 0; i < fw.trail.length - 1; i++) {
                                const alpha = fw.trail[i].alpha * 0.7;
                                const size = fw.trail[i].size;

                                // 创建渐变轨迹
                                const grad = ctx.createLinearGradient(
                                    fw.trail[i].x, fw.trail[i].y,
                                    fw.trail[i + 1].x, fw.trail[i + 1].y
                                );

                                // 根据烟花颜色生成轨迹渐变
                                const color1 = `rgba(255, 255, 255, ${alpha * 0.8})`;
                                const color2 = `${fw.color.replace(')', `, ${alpha * 0.6})`)}`;
                                const color3 = `rgba(0, 242, 254, ${alpha * 0.3})`;

                                grad.addColorStop(0, color1);
                                grad.addColorStop(0.5, color2);
                                grad.addColorStop(1, color3);

                                ctx.lineWidth = size;
                                ctx.strokeStyle = grad;
                                ctx.beginPath();
                                ctx.moveTo(fw.trail[i].x, fw.trail[i].y);
                                ctx.lineTo(fw.trail[i + 1].x, fw.trail[i + 1].y);
                                ctx.stroke();
                            }
                            ctx.restore();
                        }

                        // 绘制烟花头部 (更炫光效果)
                        ctx.save();
                        const headSize = fw.size * (1 + Math.sin(fw.age * 0.4) * 0.4);

                        // 核心光点 (多层渐变)
                        const gradCore = ctx.createRadialGradient(
                            fw.x, fw.y, 0,
                            fw.x, fw.y, headSize * 2
                        );
                        gradCore.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                        gradCore.addColorStop(0.3, `${fw.color.replace(')', `, 0.8)`)}`);
                        gradCore.addColorStop(0.7, `${fw.color.replace(')', `, 0.4)`)}`);
                        gradCore.addColorStop(1, 'rgba(255, 255, 255, 0)');

                        ctx.fillStyle = gradCore;
                        ctx.beginPath();
                        ctx.arc(fw.x, fw.y, headSize * 2, 0, 2 * Math.PI);
                        ctx.fill();

                        // 发光效果 (更强烈的光晕)
                        ctx.globalCompositeOperation = 'lighter';
                        const glowSize = headSize * (4 + Math.sin(fw.age * 0.2) * 2);
                        const gradGlow = ctx.createRadialGradient(
                            fw.x, fw.y, 0,
                            fw.x, fw.y, glowSize
                        );
                        gradGlow.addColorStop(0, `rgba(255, 255, 255, 0.95)`);
                        gradGlow.addColorStop(0.5, `${fw.color.replace(')', `, 0.3)`)}`);
                        gradGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');

                        ctx.fillStyle = gradGlow;
                        ctx.beginPath();
                        ctx.arc(fw.x, fw.y, glowSize, 0, 2 * Math.PI);
                        ctx.fill();

                        ctx.restore();

                        // 随机产生尾迹粒子 (更自然的拖尾)
                        if (Math.random() < 0.4) {
                            fw.particles.push({
                                x: fw.x - fw.vx * 3,
                                y: fw.y - fw.vy * 3,
                                vx: fw.vx * 0.1 + (Math.random() - 0.5) * 0.8,
                                vy: fw.vy * 0.1 + (Math.random() - 0.5) * 0.8,
                                alpha: 0.7 + Math.random() * 0.3,
                                color: fw.color,
                                size: 0.5 + Math.random() * 1.5,
                                life: 0,
                                maxLife: 15 + Math.random() * 15,
                                type: 'trail',
                                decay: 0.9 + Math.random() * 0.05
                            });
                        }

                        // 检查是否应该爆炸
                        if (fw.age > fw.maxAge || fw.vy > 0) {
                            fw.exploded = true;
                            fw.particles = createParticles(fw.x, fw.y, fw.color);

                            // 爆炸瞬间的闪光效果 (更强烈的闪光)
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';

                            // 主闪光
                            const flashSize = 80 + Math.random() * 70;
                            const gradFlash = ctx.createRadialGradient(
                                fw.x, fw.y, 0,
                                fw.x, fw.y, flashSize
                            );
                            gradFlash.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                            gradFlash.addColorStop(0.7, 'rgba(255, 255, 255, 0.2)');
                            gradFlash.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.fillStyle = gradFlash;
                            ctx.beginPath();
                            ctx.arc(fw.x, fw.y, flashSize, 0, 2 * Math.PI);
                            ctx.fill();

                            // 二次闪光 (更小的范围)
                            const flashSize2 = flashSize * 0.6;
                            const gradFlash2 = ctx.createRadialGradient(
                                fw.x, fw.y, 0,
                                fw.x, fw.y, flashSize2
                            );
                            gradFlash2.addColorStop(0, `${fw.color.replace(')', `, 0.8)`)}`);
                            gradFlash2.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.fillStyle = gradFlash2;
                            ctx.beginPath();
                            ctx.arc(fw.x, fw.y, flashSize2, 0, 2 * Math.PI);
                            ctx.fill();

                            ctx.restore();
                        }

                        stillAnimating = true;
                    } else {
                        // === 绽放阶段强化 ===
                        let alive = false;

                        for (let i = 0; i < fw.particles.length; i++) {
                            const p = fw.particles[i];

                            // 更新粒子状态 (更真实的物理)
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += (p.gravity || 0.03);
                            p.vx *= (p.decay || 0.96);
                            p.vy *= (p.decay || 0.96);
                            p.life++;
                            // 边界限制，防止粒子超出屏幕
                            p.x = Math.max(0, Math.min(p.x, fwCanvas.width));
                            p.y = Math.max(0, Math.min(p.y, fwCanvas.height));

                            // 不同类型粒子的不同行为
                            switch (p.type) {
                                case 'spark':
                                    p.alpha = 1 - Math.pow(p.life / p.maxLife, 1.8);
                                    p.size *= 0.98;
                                    break;
                                case 'flash':
                                    p.alpha = 1 - Math.pow(p.life / p.maxLife, 3);
                                    p.size *= 0.92;
                                    break;
                                case 'star':
                                    p.alpha = 1 - Math.pow(p.life / p.maxLife, 1.2);
                                    p.rotation += p.rotationSpeed;
                                    p.size *= 0.99;
                                    break;
                                case 'trail':
                                    p.alpha *= (p.decay || 0.92);
                                    break;
                            }

                            // 绘制粒子 (更精细的渲染)
                            if (p.alpha > 0.01) {
                                ctx.save();
                                ctx.globalAlpha = p.alpha;
                                ctx.globalCompositeOperation = 'lighter';

                                if (p.type === 'star') {
                                    // 绘制星形粒子 (更多变化)
                                    ctx.translate(p.x, p.y);
                                    ctx.rotate(p.rotation);

                                    // 星形渐变
                                    const starGrad = ctx.createRadialGradient(
                                        0, 0, 0,
                                        0, 0, p.size
                                    );
                                    starGrad.addColorStop(0, '#fff');
                                    starGrad.addColorStop(0.5, p.color);
                                    starGrad.addColorStop(1, 'rgba(255,255,255,0)');
                                    ctx.fillStyle = starGrad;

                                    const spikes = p.points || 5;
                                    const outerRadius = p.size;
                                    const innerRadius = p.size * (0.3 + Math.random() * 0.2);

                                    ctx.beginPath();
                                    for (let i = 0; i < spikes; i++) {
                                        const outerAngle = (i * 2 * Math.PI / spikes) - Math.PI / 2;
                                        const innerAngle = ((i + 0.5) * 2 * Math.PI / spikes) - Math.PI / 2;

                                        ctx.lineTo(Math.cos(outerAngle) * outerRadius, Math.sin(outerAngle) * outerRadius);
                                        ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
                                    }
                                    ctx.closePath();
                                    ctx.fill();
                                } else {
                                    // 绘制圆形粒子 (更精细的渐变)
                                    const grad = ctx.createRadialGradient(
                                        p.x, p.y, 0,
                                        p.x, p.y, p.size
                                    );

                                    if (p.type === 'flash') {
                                        grad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                                        grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
                                        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                                    } else {
                                        grad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                                        grad.addColorStop(0.3, `${p.color.replace(')', `, 0.7)`)}`);
                                        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                                    }

                                    ctx.fillStyle = grad;
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                                    ctx.fill();
                                }

                                ctx.restore();

                                // 检查粒子是否还存活
                                if (p.life < p.maxLife && p.alpha > 0.02) {
                                    alive = true;
                                }
                            }
                        }

                        if (alive) stillAnimating = true;
                    }
                }

                // 移除已结束的烟花
                fwCanvas._fireworks = fwCanvas._fireworks.filter(fw =>
                    !fw.exploded || fw.particles.some(p => p.life < p.maxLife && p.alpha > 0.02)
                );

                if (stillAnimating) {
                    requestAnimationFrame(animate);
                } else {
                    fwCanvas._animating = false;
                    // 完全清除画布
                    ctx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
                }
            }

            // 响应窗口缩放
            window.addEventListener('resize', () => {
                fwCanvas.width = window.innerWidth * dpr;
                fwCanvas.height = window.innerHeight * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            });
        }











        // 绑定control-item点击事件
        // 只保留一次绑定，且每次点击触发19次烟花

        document.querySelectorAll('.control-panel .control-item').forEach(item => {
            item.addEventListener('click', function (e) {
                if (e.button === 0) {
                    for (let i = 0; i < 19; i++) {
                        fireworkAtBottom();
                    }
                }
            });
        });
        // 等待DOM加载完成
        document.addEventListener('DOMContentLoaded', function () {
            // 生成科技感星尘点
            document.querySelectorAll('.star-dust').forEach(function (container) {
                container.innerHTML = '';
                for (let i = 0; i < 24; i++) {
                    const s = document.createElement('span');
                    const size = Math.random() * 2 + 1;
                    s.style.width = s.style.height = size + 'px';
                    s.style.left = Math.random() * 100 + '%';
                    s.style.top = Math.random() * 100 + '%';
                    s.style.opacity = (0.5 + Math.random() * 0.5).toFixed(2);
                    s.style.animationDuration = (2 + Math.random() * 2) + 's';
                    s.style.filter = 'blur(' + (Math.random() * 1.5).toFixed(1) + 'px)';
                    container.appendChild(s);
                }
            });
            // 修复：视频播放时UI隐藏，点击才进入主页面
            var introVideo = document.getElementById('introVideo');
            var controlPanel = document.getElementById('controlPanel');
            var infoTitle = document.querySelector('.info-title-center');
            var loadingScreen = document.getElementById('loadingScreen');
            // 强制隐藏控制面板和标题
            if (controlPanel) controlPanel.style.display = 'none';
            if (infoTitle) infoTitle.style.display = 'none';
            // 隐藏视频进度条
            if (introVideo) {
                introVideo.controls = false;
                introVideo.setAttribute('controls', false);
                introVideo.removeAttribute('controls');
                introVideo.style.pointerEvents = 'auto';
                introVideo.removeAttribute('loop'); // 移除loop属性，彻底用JS控制
                introVideo.setAttribute('muted', 'muted');
                introVideo.muted = true;
                introVideo.setAttribute('autoplay', 'autoplay');
                introVideo.autoplay = true;
                introVideo.setAttribute('playsinline', '');
                introVideo.playsInline = true;
                // 禁止右键菜单和拖拽
                introVideo.addEventListener('contextmenu', function (e) { e.preventDefault(); });
                introVideo.addEventListener('dragstart', function (e) { e.preventDefault(); });
                introVideo.addEventListener('selectstart', function (e) { e.preventDefault(); });
                // 统一循环保险
                function forceLoopNormal() {
                    if (this.duration - this.currentTime < 0.05 || this.ended) {
                        this.currentTime = 0.01;
                        this.play();
                    }
                }
                introVideo.addEventListener('timeupdate', forceLoopNormal);
                introVideo.addEventListener('ended', forceLoopNormal);
                // 仅允许左键点击
                introVideo.style.cursor = 'pointer';
                window._videoEntered = false;
                // 移除原有 mousedown 事件绑定，防止第一次点击时关闭视频
                introVideo.onmousedown = null;
            }
            // 禁止进度条自动进入主页面
            // 注释掉原有自动进度触发
            /*
            let progress = 0;
            const loadingBar = document.getElementById('loadingBar');
            const loadingPercentage = document.getElementById('loadingPercentage');
            const progressInterval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                    setTimeout(() => {
                        loadingScreen.style.opacity = '0';
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                            initMainApp();
                        }, 1000);
                    }, 500);
                }
                loadingBar.style.width = `${progress}%`;
                loadingPercentage.textContent = `${Math.floor(progress)}%`;
            }, 100);
            */
        });


        function applyBackgroundForPrese(preset) {
            // 需要显示背景的预设
            const showPresets = [
                'IndefinablePreset', 'wormholePreset', 'blackHolePreset', 'galaxyPreset', 'clourfulPlantPreset', 'resetPreset'
            ];
            const show = showPresets.includes(preset);
            document.getElementById('meteors-container').style.display = show ? 'block' : 'none';
            document.getElementById('stars-container').style.display = show ? 'block' : 'none';
            const canvas = document.getElementById('interstellar-canvas');
            if (canvas) canvas.style.display = show ? 'block' : 'none';
        }


        function clearAndApplyBackground(presetName) {
            // 隐藏/移除所有背景相关DOM和canvas（如starfield-bg、cosmic-glow、space-particles、#stars-container等）
            const bgClasses = ['starfield-bg', 'cosmic-glow', 'space-particles'];
            bgClasses.forEach(cls => {
                document.querySelectorAll('.' + cls).forEach(el => el.style.display = 'none');
            });
            const starsContainer = document.getElementById('stars-container');
            if (starsContainer) starsContainer.style.display = 'none';

            // 隐藏Three.js主canvas以外的所有canvas（如有）
            document.querySelectorAll('canvas').forEach(c => {
                if (c.id !== 'canvas' && c.id !== 'interstellar-canvas' && c.id !== 'firework-canvas') c.style.display = 'none';
            });

            // 只显示/隐藏 interstellar-canvas 动态星空背景
            applyBackgroundForPrese(presetName);
        }



        // 主应用初始化
        function initMainApp() {
            // 创建场景
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // 创建相机
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            // 创建渲染器
            const renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: false
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // 添加光源
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 2048;
            pointLight.shadow.mapSize.height = 2048;
            scene.add(pointLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 0);
            scene.add(directionalLight);

            // 粒子系统参数
            let config = {
                particleCount: 50000,
                particleSize: 0.1,
                planetRadius: 15,
                rotationSpeed: 0.5,
                zoom: 50,
                primaryColor: '#4facfe',
                secondaryColor: '#00f2fe',
                bgColor: '#000000',
                autoRotate: true,
                showParticles: true,
                showConnections: false,
                connectionDistance: 20,
                connectionOpacity: 0.2,
                connectionWidth: 0.5,
                starDensity: 0.5,
                noiseScale: 0.1,
                noiseIntensity: 5,
                particleAnimation: true,
                particleSpeed: 0.002,

                // 行星环参数
                ringParticleCount: 10000,
                ringWidth: 5,
                ringRadius: 25,
                ringRotationSpeed: 0.3,
                ringOpacity: 0.7,
                ringThickness: 0.5,
                ringColorSync: true,
                ringTilt: 0.2,
                ringParticleSize: 0.15,

                // 喷射特效参数
                jetEnabled: false,
                jetIntensity: 1.5,
                jetSpread: 0.8,
                jetSpeed: 0.02,
                jetColor: '#5cd0ff',
                jetSecondaryColor: '#3a8cff',
                jetParticleCount: 30000,
                jetLength: 100,
                jetTurbulence: 0.3,
                jetSize: 0.2,
                jetOpacity: 0.8,
                jetGlow: 1.2
            };

            // 粒子数组
            let particles = [];
            let stars = [];
            let animatedParticles = [];
            let ringParticles = null;
            let ringRotation = 0;
            let ringTiltX = 0;
            let ringTiltZ = 0;

            // 颜色转换函数
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16) / 255,
                    g: parseInt(result[2], 16) / 255,
                    b: parseInt(result[3], 16) / 255
                } : { r: 0, g: 0, b: 0 };
            }

            // 创建粒子系统
            function createParticles() {
                // 清除现有粒子
                if (particles.length > 0) {
                    particles.forEach(particle => scene.remove(particle));
                    particles = [];
                }

                // 创建粒子几何体
                const particlesGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.particleCount * 3);
                const colors = new Float32Array(config.particleCount * 3);
                const sizes = new Float32Array(config.particleCount);

                const primaryColor = hexToRgb(config.primaryColor);
                const secondaryColor = hexToRgb(config.secondaryColor);

                // 生成粒子位置和颜色
                for (let i = 0; i < config.particleCount; i++) {
                    // 球体上的随机点
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    // 添加一些随机性使表面不规则
                    const radius = config.planetRadius * (0.9 + Math.random() * 0.1);

                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);

                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;

                    // 颜色渐变
                    const t = Math.random();
                    colors[i * 3] = primaryColor.r * t + secondaryColor.r * (1 - t);
                    colors[i * 3 + 1] = primaryColor.g * t + secondaryColor.g * (1 - t);
                    colors[i * 3 + 2] = primaryColor.b * t + secondaryColor.b * (1 - t);

                    // 随机大小
                    sizes[i] = config.particleSize * (0.5 + Math.random() * 0.5);
                }

                // 设置几何体属性
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                // 创建粒子材质
                const particlesMaterial = new THREE.PointsMaterial({
                    size: config.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                // 创建粒子系统
                const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particleSystem);
                particles.push(particleSystem);

                // 更新UI显示
                document.getElementById('particleCountValue').textContent = config.particleCount.toLocaleString();

                // 更新行星环颜色
                if (ringParticles && config.ringColorSync) {
                    updateRingColors();
                }
            }

            // 创建星空背景
            function createStars() {
                const container = document.getElementById('stars-container');
                if (!container) return;
                container.innerHTML = ''; // 清空旧星星
                const starCount = 300;
                for (let i = 0; i < starCount; i++) {
                    const star = document.createElement('div');
                    star.classList.add('star');
                    const size = Math.random() * 4;
                    star.style.width = `${size}px`;
                    star.style.height = `${size}px`;
                    star.style.left = `${Math.random() * 100}%`;
                    star.style.top = `${Math.random() * 100}%`;
                    const hue = Math.random() * 60 + 180;
                    star.style.backgroundColor = `hsla(${hue}, 100%, 80%, 1)`;
                    star.style.boxShadow = `0 0 15px 2px hsla(${hue}, 100%, 50%, 0.8)`;
                    star.style.setProperty('--duration', `${5 + Math.random() * 15}s`);
                    star.style.setProperty('--opacity', `${0.3 + Math.random() * 0.7}`);
                    star.style.animationDelay = `${Math.random() * 15}s`;
                    container.appendChild(star);
                }
            }

            // 创建动画粒子
            function createAnimatedParticles() {
                // 清除现有动画粒子
                if (animatedParticles.length > 0) {
                    animatedParticles.forEach(particle => scene.remove(particle.system));
                    animatedParticles = [];
                }

                const animatedGeometry = new THREE.BufferGeometry();
                const animatedPositions = new Float32Array(1000 * 3);
                const animatedSpeeds = [];
                const animatedColors = new Float32Array(1000 * 3);

                const primaryColor = hexToRgb(config.primaryColor);
                const secondaryColor = hexToRgb(config.secondaryColor);

                for (let i = 0; i < 1000; i++) {
                    const radius = config.planetRadius * (1.2 + Math.random() * 0.5);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    animatedPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    animatedPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    animatedPositions[i * 3 + 2] = radius * Math.cos(phi);

                    // 设置颜色
                    const t = Math.random();
                    animatedColors[i * 3] = primaryColor.r * t + secondaryColor.r * (1 - t);
                    animatedColors[i * 3 + 1] = primaryColor.g * t + secondaryColor.g * (1 - t);
                    animatedColors[i * 3 + 2] = primaryColor.b * t + secondaryColor.b * (1 - t);

                    animatedSpeeds.push({
                        speed: config.particleSpeed * (0.5 + Math.random()),
                        direction: new THREE.Vector3(
                            Math.random() - 0.5,
                            Math.random() - 0.5,
                            Math.random() - 0.5
                        ).normalize(),
                        baseX: animatedPositions[i * 3],
                        baseY: animatedPositions[i * 3 + 1],
                        baseZ: animatedPositions[i * 3 + 2]
                    });
                }

                animatedGeometry.setAttribute('position', new THREE.BufferAttribute(animatedPositions, 3));
                animatedGeometry.setAttribute('color', new THREE.BufferAttribute(animatedColors, 3));

                const animatedMaterial = new THREE.PointsMaterial({
                    size: 0.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });

                const animatedSystem = new THREE.Points(animatedGeometry, animatedMaterial);
                scene.add(animatedSystem);
                animatedParticles.push({
                    system: animatedSystem,
                    speeds: animatedSpeeds,
                    geometry: animatedGeometry
                });
            }

            // 创建行星环
            function createRing() {
                // 清除现有行星环
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                const ringGeometry = new THREE.BufferGeometry();
                const ringPositions = new Float32Array(config.ringParticleCount * 3);
                const ringColors = new Float32Array(config.ringParticleCount * 3);
                const ringSizes = new Float32Array(config.ringParticleCount);

                const primaryColor = hexToRgb(config.primaryColor);
                const secondaryColor = hexToRgb(config.secondaryColor);

                // 生成环粒子
                for (let i = 0; i < config.ringParticleCount; i++) {
                    // 在环形区域内随机分布
                    const angle = Math.random() * Math.PI * 2;
                    const distance = config.ringRadius + (Math.random() - 0.5) * config.ringWidth;
                    const height = (Math.random() - 0.5) * config.ringThickness;

                    ringPositions[i * 3] = distance * Math.cos(angle);
                    ringPositions[i * 3 + 1] = height;
                    ringPositions[i * 3 + 2] = distance * Math.sin(angle);

                    // 颜色渐变
                    const t = Math.random();
                    ringColors[i * 3] = primaryColor.r * t + secondaryColor.r * (1 - t);
                    ringColors[i * 3 + 1] = primaryColor.g * t + secondaryColor.g * (1 - t);
                    ringColors[i * 3 + 2] = primaryColor.b * t + secondaryColor.b * (1 - t);

                    // 随机大小
                    ringSizes[i] = config.ringParticleSize * (0.5 + Math.random() * 0.5);
                }

                ringGeometry.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));
                ringGeometry.setAttribute('color', new THREE.BufferAttribute(ringColors, 3));
                ringGeometry.setAttribute('size', new THREE.BufferAttribute(ringSizes, 1));

                const ringMaterial = new THREE.PointsMaterial({
                    size: config.ringParticleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: config.ringOpacity,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                ringParticles = new THREE.Points(ringGeometry, ringMaterial);

                // 设置环的初始倾斜
                ringTiltX = config.ringTilt;
                ringTiltZ = config.ringTilt * 0.3;
                ringParticles.rotation.x = ringTiltX;
                ringParticles.rotation.z = ringTiltZ;

                ringParticles.material.size = 0.25;
                ringParticles.material.opacity = 0.95;
                ringParticles.material.blending = THREE.AdditiveBlending;
                ringParticles.material.sizeAttenuation = false;

                scene.add(ringParticles);
            }

            // 更新行星环颜色
            function updateRingColors() {
                if (!ringParticles) return;

                const primaryColor = hexToRgb(config.primaryColor);
                const secondaryColor = hexToRgb(config.secondaryColor);
                const colors = ringParticles.geometry.attributes.color.array;

                for (let i = 0; i < config.ringParticleCount; i++) {
                    const t = Math.random();
                    colors[i * 3] = primaryColor.r * t + secondaryColor.r * (1 - t);
                    colors[i * 3 + 1] = primaryColor.g * t + secondaryColor.g * (1 - t);
                    colors[i * 3 + 2] = primaryColor.b * t + secondaryColor.b * (1 - t);
                }

                ringParticles.geometry.attributes.color.needsUpdate = true;
            }

            // 初始化所有粒子系统
            createParticles();
            createStars();
            createAnimatedParticles();
            createRing();

            // 默认使用IndefinablePreset预设
            setTimeout(() => {
                document.getElementById('IndefinablePreset').click();
            }, 100);

            // 鼠标控制变量
            let isDragging = false;
            let isRightDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotation = { x: 0, y: 0 };
            let targetRotation = { x: 0, y: 0 };
            let zoom = 50;
            let targetZoom = 100;

            // 旋转速度跟踪
            let currentRotationSpeed = 0;
            let baseRingRotationSpeed = 0.3; // 行星环基础旋转速度

            // 鼠标事件监听
            const canvas = document.getElementById('canvas');

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // 左键
                    isDragging = true;
                    previousMousePosition = {
                        x: e.clientX,
                        y: e.clientY
                    };
                } else if (e.button === 2) { // 右键
                    isRightDragging = true;
                    previousMousePosition = {
                        x: e.clientX,
                        y: e.clientY
                    };
                }
            });

            window.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isDragging = false;
                } else if (e.button === 2) {
                    isRightDragging = false;
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    targetRotation.y += deltaX * 0.015; // 增加水平旋转灵敏度
                    targetRotation.x += deltaY * 0.015; // 增加垂直旋转灵敏度

                    // 计算主星球旋转速度
                    currentRotationSpeed = Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 0.001;

                    // 根据拖动方向确定旋转方向
                    const rotationDirection = deltaX > 0 ? 1 : -1;

                    // 保存旋转方向用于动画循环中同步行星环
                    lastRotationDirection = rotationDirection;

                    previousMousePosition = {
                        x: e.clientX,
                        y: e.clientY
                    };
                } else if (isRightDragging && ringParticles) {
                    e.preventDefault(); // 阻止默认拖拽行为
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    ringTiltX += deltaY * 0.005;
                    ringTiltZ += deltaX * 0.005;

                    // 限制倾斜角度
                    ringTiltX = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, ringTiltX));
                    ringTiltZ = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, ringTiltZ));

                    ringParticles.rotation.x = ringTiltX;
                    ringParticles.rotation.z = ringTiltZ;

                    previousMousePosition = {
                        x: e.clientX,
                        y: e.clientY
                    };
                }
            });

            // 阻止默认的右键和中键上下文菜单
            document.addEventListener('contextmenu', function (event) {
                if (event.button === 1) {
                    event.preventDefault();
                }
            });
            // 针对某些特殊情况（如文本选中后等）额外处理
            document.addEventListener('mousedown', function (event) {
                if (event.button === 1) {
                    event.preventDefault();
                }
            });
            document.addEventListener('mouseup', function (event) {
                if (event.button === 1) {
                    event.preventDefault();
                }
            });

            window.addEventListener('wheel', (e) => {
                targetZoom += e.deltaY * 0.1;
                targetZoom = Math.max(1, Math.min(400, targetZoom));
                document.getElementById('zoomValue').textContent = Math.round(targetZoom);
            });



            // 触摸事件支持
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
                e.preventDefault();
            });

            window.addEventListener('touchend', () => {
                isDragging = false;
            });

            window.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;

                    targetRotation.y += deltaX * 0.01;
                    targetRotation.x += deltaY * 0.01;

                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                    e.preventDefault();
                }
            });

            // 窗口大小调整
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 设置面板控制
            const settingsButton = document.getElementById('settingsButton');
            const settingsPanel = document.getElementById('settingsPanel');
            const settingsClose = document.getElementById('settingsClose');

            settingsButton.addEventListener('click', () => {
                settingsPanel.classList.toggle('active');
            });

            settingsClose.addEventListener('click', () => {
                settingsPanel.classList.remove('active');
            });

            // 滑块控制
            document.getElementById('particleCountSlider').addEventListener('input', (e) => {
                config.particleCount = parseInt(e.target.value);
                document.getElementById('particleCountValue').textContent = config.particleCount.toLocaleString();
                createParticles();
            });

            document.getElementById('particleSizeSlider').addEventListener('input', (e) => {
                config.particleSize = parseFloat(e.target.value);
                document.getElementById('particleSizeValue').textContent = config.particleSize.toFixed(2);
                createParticles();
            });

            document.getElementById('planetRadiusSlider').addEventListener('input', (e) => {
                config.planetRadius = parseInt(e.target.value);
                document.getElementById('planetRadiusValue').textContent = config.planetRadius;
                createParticles();
                createAnimatedParticles();
                createRing();
            });

            document.getElementById('rotationSpeedSlider').addEventListener('input', (e) => {
                config.rotationSpeed = parseFloat(e.target.value);
                document.getElementById('rotationSpeedValue').textContent = config.rotationSpeed.toFixed(2);
            });

            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                targetZoom = parseInt(e.target.value);
                document.getElementById('zoomValue').textContent = targetZoom;
            });

            // 更新动画粒子颜色
            function updateAnimatedParticlesColors() {
                if (animatedParticles.length === 0) return;

                const primaryColor = hexToRgb(config.primaryColor);
                const secondaryColor = hexToRgb(config.secondaryColor);
                const colors = animatedParticles[0].geometry.attributes.color.array;

                for (let i = 0; i < colors.length / 3; i++) {
                    const t = Math.random();
                    colors[i * 3] = primaryColor.r * t + secondaryColor.r * (1 - t);
                    colors[i * 3 + 1] = primaryColor.g * t + secondaryColor.g * (1 - t);
                    colors[i * 3 + 2] = primaryColor.b * t + secondaryColor.b * (1 - t);
                }

                animatedParticles[0].geometry.attributes.color.needsUpdate = true;
            }

            // 颜色选择器
            document.getElementById('primaryColorPicker').addEventListener('input', (e) => {
                config.primaryColor = e.target.value;
                createParticles();
                createStars();
                if (ringParticles && config.ringColorSync) {
                    updateRingColors();
                }
                updateAnimatedParticlesColors();
            });

            document.getElementById('secondaryColorPicker').addEventListener('input', (e) => {
                config.secondaryColor = e.target.value;
                createParticles();
                createStars();
                if (ringParticles && config.ringColorSync) {
                    updateRingColors();
                }
                updateAnimatedParticlesColors();
            });

            document.getElementById('bgColorPicker').addEventListener('input', (e) => {
                config.bgColor = e.target.value;
                scene.background = new THREE.Color(config.bgColor);
            });

            // 行星环控制
            document.getElementById('ringParticleCountSlider').addEventListener('input', (e) => {
                config.ringParticleCount = parseInt(e.target.value);
                document.getElementById('ringParticleCountValue').textContent = config.ringParticleCount.toLocaleString();
                createRing();
            });

            document.getElementById('ringWidthSlider').addEventListener('input', (e) => {
                config.ringWidth = parseFloat(e.target.value);
                document.getElementById('ringWidthValue').textContent = config.ringWidth.toFixed(1);
                createRing();
            });

            document.getElementById('ringRadiusSlider').addEventListener('input', (e) => {
                config.ringRadius = parseInt(e.target.value);
                document.getElementById('ringRadiusValue').textContent = config.ringRadius;
                createRing();
            });

            document.getElementById('ringRotationSpeedSlider').addEventListener('input', (e) => {
                config.ringRotationSpeed = parseFloat(e.target.value);
                document.getElementById('ringRotationSpeedValue').textContent = config.ringRotationSpeed.toFixed(2);
            });

            document.getElementById('ringOpacitySlider').addEventListener('input', (e) => {
                config.ringOpacity = parseFloat(e.target.value);
                document.getElementById('ringOpacityValue').textContent = config.ringOpacity.toFixed(2);
                if (ringParticles) {
                    ringParticles.material.opacity = config.ringOpacity;
                }
            });

            // 预设按钮            
            document.getElementById('sunPreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                // 太阳预设 - 创建真实的太阳层次结构
                config.primaryColor = '#fff7e6';    // 核心区域 - 偏白色
                config.secondaryColor = '#ffb366';  // 辐射区域 - 橙色
                config.particleSize = 0.08;         // 更细腻的粒子效果
                config.planetRadius = 25;           // 增大太阳半径
                config.rotationSpeed = 0.2;         // 更慢的自转速度
                config.particleCount = 1000000;     // 增加粒子数量以获得更细腻效果
                // 移除行星环系统
                config.ringParticleCount = 0;
                config.ringWidth = 0;
                config.ringRadius = 0;
                config.ringRotationSpeed = 0;
                config.ringOpacity = 0;
                config.ringTilt = 0;
                targetZoom = 60;                    // 调整视角以展示更多细节

                // 深邃的太空背景
                scene.background = new THREE.Color(0x000011);
                document.getElementById('bgColorPicker').value = '#000011';

                // 更新UI并重建粒子系统
                updateUIFromConfig();

                // 清除现有的粒子系统和环系统
                particles.forEach(particle => scene.remove(particle));
                particles = [];
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                // 创建太阳核心区域
                const coreGeometry = new THREE.BufferGeometry();
                const corePositions = new Float32Array(config.particleCount * 3);
                const coreColors = new Float32Array(config.particleCount * 3);

                // 创建太阳的不同层次
                for (let i = 0; i < config.particleCount; i++) {
                    const i3 = i * 3;
                    const radius = Math.random() * config.planetRadius;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);

                    // 计算球坐标
                    corePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    corePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    corePositions[i3 + 2] = radius * Math.cos(phi);

                    // 根据距离中心的远近设置不同的颜色
                    const distance = Math.sqrt(
                        corePositions[i3] * corePositions[i3] +
                        corePositions[i3 + 1] * corePositions[i3 + 1] +
                        corePositions[i3 + 2] * corePositions[i3 + 2]
                    );

                    let color;
                    if (distance < config.planetRadius * 0.3) {
                        // 核心区 - 白色到黄色
                        color = new THREE.Color('#ffffff').lerp(new THREE.Color('#ffff00'), distance / (config.planetRadius * 0.3));
                    } else if (distance < config.planetRadius * 0.6) {
                        // 辐射区 - 黄色到橙色
                        color = new THREE.Color('#ffff00').lerp(new THREE.Color('#ff8c00'), (distance - config.planetRadius * 0.3) / (config.planetRadius * 0.3));
                    } else {
                        // 对流区 - 橙色到红色
                        color = new THREE.Color('#ff8c00').lerp(new THREE.Color('#ff4500'), (distance - config.planetRadius * 0.6) / (config.planetRadius * 0.4));
                    }

                    coreColors[i3] = color.r;
                    coreColors[i3 + 1] = color.g;
                    coreColors[i3 + 2] = color.b;
                }

                coreGeometry.setAttribute('position', new THREE.BufferAttribute(corePositions, 3));
                coreGeometry.setAttribute('color', new THREE.BufferAttribute(coreColors, 3));

                const coreMaterial = new THREE.PointsMaterial({
                    size: config.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                const core = new THREE.Points(coreGeometry, coreMaterial);
                scene.add(core);
                particles.push(core);

                // 添加光球层
                const photosphereLight = new THREE.PointLight(0xfff4e6, 2.0, 100);
                photosphereLight.position.set(0, 0, 0);
                scene.add(photosphereLight);

                // 添加色球层
                const chromosphereLight = new THREE.PointLight(0xff6b6b, 1.5, 150);
                chromosphereLight.position.set(0, 0, 0);
                scene.add(chromosphereLight);

                // 添加日冕层
                const coronaLights = [
                    new THREE.PointLight(0xff4500, 1.0, 200), // 内日冕
                    new THREE.PointLight(0xff8c00, 0.8, 250), // 中日冕
                    new THREE.PointLight(0xffb366, 0.6, 300)  // 外日冕
                ];

                coronaLights.forEach((light, index) => {
                    light.position.set(
                        Math.cos(index * Math.PI * 2 / 3) * 20,
                        Math.sin(index * Math.PI * 2 / 3) * 20,
                        0
                    );
                    scene.add(light);
                });

                // 添加太阳耀斑效果
                const flareGeometry = new THREE.BufferGeometry();
                const flarePositions = new Float32Array(10000 * 3);
                const flareColors = new Float32Array(10000 * 3);

                for (let i = 0; i < 10000; i++) {
                    const i3 = i * 3;
                    const radius = config.planetRadius * (1 + Math.random() * 0.2);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);

                    flarePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    flarePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    flarePositions[i3 + 2] = radius * Math.cos(phi);

                    const flareColor = new THREE.Color('#ff6b6b').lerp(new THREE.Color('#ffb366'), Math.random());
                    flareColors[i3] = flareColor.r;
                    flareColors[i3 + 1] = flareColor.g;
                    flareColors[i3 + 2] = flareColor.b;
                }

                flareGeometry.setAttribute('position', new THREE.BufferAttribute(flarePositions, 3));
                flareGeometry.setAttribute('color', new THREE.BufferAttribute(flareColors, 3));

                const flareMaterial = new THREE.PointsMaterial({
                    size: config.particleSize * 1.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                const flares = new THREE.Points(flareGeometry, flareMaterial);
                scene.add(flares);
                particles.push(flares);

                // 增强环境光以突出色彩
                scene.children.forEach(child => {
                    if (child instanceof THREE.AmbientLight) {
                        child.intensity = 0.8;
                    }
                });

                clearAndApplyBackground('sunPreset');
            });




            document.getElementById('galaxyPreset').addEventListener('click', () => {
    clearScene();
    document.getElementById('customSettings').style.display = 'none';
    
    // Cosmic Galaxy Configuration
    config.primaryColor = '#8a3aff';      // Deep cosmic purple
    config.secondaryColor = '#00c4e8';    // Nebula teal
    config.particleSize = 0.015;          // Ultra-fine particles
    config.planetRadius = 0;              // No central planet
    config.rotationSpeed = 0.4;           // Majestic cosmic rotation
    config.particleCount = 2500000;       // Ultra-dense star field
    config.ringParticleCount = 0;         // No rings
    targetZoom = 90;                      // Grand cosmic perspective
    
    // Deep void-space background with cosmic energy
    scene.background = new THREE.Color(0x01010a);
    document.getElementById('bgColorPicker').value = '#01010a';
    updateUIFromConfig();

    // Clear existing particles
    particles.forEach(particle => scene.remove(particle));
    particles = [];
    if (ringParticles) {
        scene.remove(ringParticles);
        ringParticles = null;
    }

    // Create cosmic galaxy system with enhanced parameters
    const galaxyGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(config.particleCount * 3);
    const colors = new Float32Array(config.particleCount * 3);
    const sizes = new Float32Array(config.particleCount);

    // Enhanced galactic parameters
    const arms = 4;                       // Classic spiral structure
    const armWidth = 0.6;                 // Flowing arms
    const spiralFactor = 12;              // Elegant spiral
    const galaxyRadius = 180;             // Expansive galaxy
    const coreRadius = 35;                // Luminous core
    const densityFalloff = 2.8;           // Natural distribution
    const verticalDispersion = 0.7;       // 3D structure

    // Cosmic color spectrum with flowing gradients
    const armPalette = [
        { r: 0.7, g: 0.2, b: 0.9 },      // Deep cosmic purple
        { r: 0.1, g: 0.7, b: 0.9 },      // Stellar blue
        { r: 0.1, g: 0.9, b: 0.7 },     // Nebula teal
        { r: 0.9, g: 0.5, b: 0.2 }       // Warm stellar glow
    ];

    // Generate celestial particles with flowing distribution
    for (let i = 0; i < config.particleCount; i++) {
        const i3 = i * 3;
        const isCore = Math.random() < 0.25;
        let radius, angle, armIndex;

        if (isCore) {
            // Radiant core with golden halo
            radius = Math.pow(Math.random(), 2.2) * coreRadius * 1.5;
            angle = Math.random() * Math.PI * 2;
            armIndex = Math.floor(Math.random() * arms);
        } else {
            // Flowing spiral arms
            armIndex = Math.floor(Math.random() * arms);
            const armAngle = (armIndex / arms) * Math.PI * 2;
            const armOffset = (Math.random() - 0.5) * armWidth * 2;
            radius = coreRadius + Math.pow(Math.random(), densityFalloff) * (galaxyRadius - coreRadius);
            angle = armAngle + Math.log(radius/coreRadius) * spiralFactor + armOffset;
        }

        // 3D positioning with vertical dispersion
        positions[i3] = Math.cos(angle) * radius;
        positions[i3 + 1] = (Math.random() - 0.5) * verticalDispersion * Math.pow(radius/galaxyRadius, 0.5);
        positions[i3 + 2] = Math.sin(angle) * radius;

        // Dynamic coloring with cosmic variation
        const distanceFromCenter = Math.sqrt(positions[i3]**2 + positions[i3 + 1]**2 + positions[i3 + 2]**2);
        const normalizedDistance = distanceFromCenter / galaxyRadius;

        if (isCore) {
            // Core illumination with golden-white gradient
            const coreIntensity = 0.8 + 0.2 * Math.sin(distanceFromCenter * 0.1);
            const coreWarmth = 0.6 + 0.4 * (1 - normalizedDistance);
            
            colors[i3] = (0.8 + 0.1 * Math.random()) * coreIntensity;
            colors[i3 + 1] = (0.6 + 0.2 * coreWarmth) * coreIntensity;
            colors[i3 + 2] = (0.9 - normalizedDistance * 0.2) * coreIntensity;
        } else {
            // Arm colors with cosmic dust effect
            const armColor = armPalette[armIndex];
            const stellarFade = 0.5 + 0.5 * (1 - Math.pow(normalizedDistance, 0.5));
            const dustEffect = 0.7 + 0.3 * Math.random();
            const armVariation = 0.8 + 0.2 * Math.sin(angle * 3);
            
            colors[i3] = armColor.r * stellarFade * dustEffect * armVariation;
            colors[i3 + 1] = armColor.g * stellarFade * dustEffect * armVariation;
            colors[i3 + 2] = armColor.b * stellarFade * dustEffect * armVariation;
        }

        // Organic size variation
        sizes[i] = isCore 
            ? 0.12 * (1.2 - normalizedDistance * 0.6) 
            : 0.04 * (0.6 + 0.4 * Math.random());
    }

    galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    galaxyGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    // Ethereal particle material with subtle glow
    const galaxyMaterial = new THREE.PointsMaterial({
        size: 0.03,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
        alphaTest: 0.001,
        depthWrite: false
    });

    const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
    scene.add(galaxy);
    particles.push(galaxy);

    // Cosmic ambient lighting with nebula hues
    const ambientLight = new THREE.AmbientLight(0x0a0a2a, 0.25);
    scene.add(ambientLight);

    // Create a massive cosmic nebula background
    const nebulaGeometry = new THREE.SphereGeometry(3000, 64, 64);
    const nebulaTexture = createNebulaTexture(2048);
    const nebulaMaterial = new THREE.MeshBasicMaterial({
        map: nebulaTexture,
        side: THREE.BackSide,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    const nebulaSphere = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
    scene.add(nebulaSphere);
    particles.push(nebulaSphere);

    // Function to create procedural nebula texture
    function createNebulaTexture(size) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        // Create cosmic gradient
        const gradient1 = ctx.createRadialGradient(
            size * 0.3, size * 0.3, 0,
            size * 0.3, size * 0.3, size * 0.5
        );
        gradient1.addColorStop(0, 'rgba(138, 58, 255, 0.8)');
        gradient1.addColorStop(0.7, 'rgba(0, 196, 232, 0.5)');
        gradient1.addColorStop(1, 'rgba(0, 10, 20, 0)');
        
        const gradient2 = ctx.createRadialGradient(
            size * 0.7, size * 0.7, 0,
            size * 0.7, size * 0.7, size * 0.5
        );
        gradient2.addColorStop(0, 'rgba(255, 90, 0, 0.6)');
        gradient2.addColorStop(0.7, 'rgba(200, 0, 255, 0.4)');
        gradient2.addColorStop(1, 'rgba(0, 10, 20, 0)');
        
        // Draw cosmic clouds
        ctx.fillStyle = '#01010a';
        ctx.fillRect(0, 0, size, size);
        
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = gradient1;
        ctx.fillRect(0, 0, size, size);
        
        ctx.fillStyle = gradient2;
        ctx.fillRect(0, 0, size, size);
        
        // Add star clusters
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        for (let i = 0; i < 2000; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const r = Math.random() * 2;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Add cosmic dust veins
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.05)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 50; i++) {
            ctx.beginPath();
            const x1 = Math.random() * size;
            const y1 = Math.random() * size;
            ctx.moveTo(x1, y1);
            for (let j = 0; j < 5; j++) {
                ctx.lineTo(
                    x1 + (Math.random() - 0.5) * size * 0.2,
                    y1 + (Math.random() - 0.5) * size * 0.2
                );
            }
            ctx.stroke();
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        return texture;
    }

    // Create distant galaxy clusters
    const galaxyClusters = new THREE.Group();
    for (let i = 0; i < 15; i++) {
        const galaxy = new THREE.Mesh(
            new THREE.SphereGeometry(40 + Math.random() * 80, 32, 32),
            new THREE.MeshBasicMaterial({
                color: new THREE.Color(
                    0.2 + Math.random() * 0.3,
                    0.1 + Math.random() * 0.2,
                    0.3 + Math.random() * 0.4
                ),
                transparent: true,
                opacity: 0.03,
                blending: THREE.AdditiveBlending
            })
        );
        
        // Position in spherical coordinates
        const distance = 2000 + Math.random() * 3000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        galaxy.position.set(
            distance * Math.sin(phi) * Math.cos(theta),
            distance * Math.sin(phi) * Math.sin(theta),
            distance * Math.cos(phi)
        );
        
        galaxyClusters.add(galaxy);
        
        // Add glow
        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(galaxy.geometry.parameters.radius * 1.8, 32, 32),
            new THREE.MeshBasicMaterial({
                color: galaxy.material.color,
                transparent: true,
                opacity: 0.015,
                blending: THREE.AdditiveBlending
            })
        );
        galaxy.add(glow);
    }
    scene.add(galaxyClusters);
    particles.push(galaxyClusters);

    // Create cosmic web filaments
    const cosmicWeb = new THREE.Group();
    for (let i = 0; i < 30; i++) {
        const filament = new THREE.Line(
            new THREE.BufferGeometry(),
            new THREE.LineBasicMaterial({
                color: 0x4466aa,
                transparent: true,
                opacity: 0.02,
                blending: THREE.AdditiveBlending
            })
        );
        
        const distance = 1500 + Math.random() * 2000;
        const points = [];
        const segments = 10 + Math.floor(Math.random() * 10);
        
        for (let j = 0; j <= segments; j++) {
            points.push(new THREE.Vector3(
                (Math.random() - 0.5) * distance * 0.3,
                (Math.random() - 0.5) * distance * 0.3,
                (Math.random() - 0.5) * distance * 0.3
            ));
        }
        
        filament.geometry.setFromPoints(points);
        cosmicWeb.add(filament);
    }
    scene.add(cosmicWeb);
    particles.push(cosmicWeb);

    // Create quasar-like energy sources
    const quasars = new THREE.Group();
    for (let i = 0; i < 4; i++) {
        const quasar = new THREE.PointLight(
            0x4466ff,
            0.5,
            5000,
            2.0
        );
        
        const distance = 2500 + Math.random() * 2000;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        quasar.position.set(
            distance * Math.sin(phi) * Math.cos(theta),
            distance * Math.sin(phi) * Math.sin(theta),
            distance * Math.cos(phi)
        );
        
        quasars.add(quasar);
        
        // Add energy beam
        const beamLength = 1000 + Math.random() * 1500;
        const beamGeometry = new THREE.CylinderGeometry(
            5,
            100,
            beamLength,
            32,
            1,
            true
        );
        beamGeometry.rotateX(Math.PI / 2);
        
        const beamMaterial = new THREE.MeshBasicMaterial({
            color: 0x4466ff,
            transparent: true,
            opacity: 0.03,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        beam.position.copy(quasar.position);
        beam.lookAt(0, 0, 0);
        quasars.add(beam);
    }
    scene.add(quasars);
    particles.push(quasars);

    clearAndApplyBackground('galaxyPreset');
});







document.getElementById('seaBluePreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'block';
                // 更逼真的冰蓝色调
                config.primaryColor = '#5cd0ff';
                config.secondaryColor = '#3a8cff';
                config.particleSize = 0.15;
                config.planetRadius = 18;
                config.rotationSpeed = 0.7;
                config.particleCount = 80000;
                config.ringParticleCount = 25000;
                config.ringWidth = 10;
                config.ringRadius = 35;
                config.ringRotationSpeed = -1.2; // 必须是负数
                config.ringOpacity = 0.95;
                config.ringTilt = 0.35;
                config.ringThickness = 2.5;
                targetZoom = 70;
                config.particleSpeed = 0.02;
                scene.background = new THREE.Color(0x000a2a);
                document.getElementById('bgColorPicker').value = '#000a2a';
                updateUIFromConfig();
                createParticles();
                createRing();
                // 设置流浪地球环的特效
                if (ringParticles) {
                    ringTiltX = config.ringTilt;
                    ringTiltZ = 0;
                    ringParticles.rotation.x = ringTiltX;
                    ringParticles.rotation.z = ringTiltZ;
                    ringParticles.material.size = 0.25;
                    ringParticles.material.opacity = 0.95;
                    ringParticles.material.blending = THREE.AdditiveBlending;
                    ringParticles.material.sizeAttenuation = false;
                    const engineLight = new THREE.PointLight(0x5cd0ff, 2, 50);
                    engineLight.position.set(0, 0, -50);
                    scene.add(engineLight);
                }
                scene.children.forEach(child => {
                    if (child instanceof THREE.AmbientLight) {
                        child.intensity = 0.7;
                    }
                });
                clearAndApplyBackground('seaBluePreset');
            });

            document.getElementById('resetPreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                config.primaryColor = '#4facfe';
                config.secondaryColor = '#00f2fe';
                config.particleSize = 0.1;
                config.planetRadius = 15;
                config.rotationSpeed = 0.5;
                config.particleCount = 50000;
                config.ringParticleCount = 10000;
                config.ringWidth = 5;
                config.ringRadius = 25;
                config.ringRotationSpeed = 0.3;
                config.ringOpacity = 0.7;
                config.ringTilt = 0.2;
                targetZoom = 50;
                updateUIFromConfig();
                createParticles();
                createRing();
                scene.background = new THREE.Color(0x000000);
                document.getElementById('bgColorPicker').value = '#000000';

                // 重置环倾斜
                if (ringParticles) {
                    ringTiltX = config.ringTilt;
                    ringTiltZ = config.ringTilt * 0.5;
                    ringParticles.rotation.x = ringTiltX;
                    ringParticles.rotation.z = ringTiltZ;
                }
                clearAndApplyBackground('resetPreset');
            });

            // 更新UI从配置
            function updateUIFromConfig() {
                document.getElementById('particleCountSlider').value = config.particleCount;
                document.getElementById('particleCountValue').textContent = config.particleCount.toLocaleString();

                document.getElementById('particleSizeSlider').value = config.particleSize;
                document.getElementById('particleSizeValue').textContent = config.particleSize.toFixed(2);

                document.getElementById('planetRadiusSlider').value = config.planetRadius;
                document.getElementById('planetRadiusValue').textContent = config.planetRadius;

                document.getElementById('rotationSpeedSlider').value = config.rotationSpeed;
                document.getElementById('rotationSpeedValue').textContent = config.rotationSpeed.toFixed(2);

                document.getElementById('zoomSlider').value = targetZoom;
                document.getElementById('zoomValue').textContent = targetZoom;

                document.getElementById('primaryColorPicker').value = config.primaryColor;
                document.getElementById('secondaryColorPicker').value = config.secondaryColor;

                document.getElementById('ringParticleCountSlider').value = config.ringParticleCount;
                document.getElementById('ringParticleCountValue').textContent = config.ringParticleCount.toLocaleString();

                document.getElementById('ringWidthSlider').value = config.ringWidth;
                document.getElementById('ringWidthValue').textContent = config.ringWidth.toFixed(1);

                document.getElementById('ringRadiusSlider').value = config.ringRadius;
                document.getElementById('ringRadiusValue').textContent = config.ringRadius;

                document.getElementById('ringRotationSpeedSlider').value = config.ringRotationSpeed;
                document.getElementById('ringRotationSpeedValue').textContent = config.ringRotationSpeed.toFixed(2);

                document.getElementById('ringOpacitySlider').value = config.ringOpacity;
                document.getElementById('ringOpacityValue').textContent = config.ringOpacity.toFixed(2);
            }


            // 动画循环
            const animate = () => {
                requestAnimationFrame(animate);

                // 平滑旋转
                rotation.x += (targetRotation.x - rotation.x) * 0.1;
                rotation.y += (targetRotation.y - rotation.y) * 0.1;

                particles.forEach(particle => {
                    particle.rotation.x = rotation.x;
                    particle.rotation.y = rotation.y;
                });

                // 平滑缩放
                zoom += (targetZoom - zoom) * 0.1;
                camera.position.z = zoom;

                // 自动旋转
                if (config.autoRotate) {
                    targetRotation.y += 0.001 * config.rotationSpeed;
                    targetRotation.x += 0.0005 * config.rotationSpeed;
                }

                // 计算主星球实际旋转速度（上一帧与当前帧的rotation.y差值）
                if (!window._lastRotationY) window._lastRotationY = rotation.y;
                let actualRotationSpeed = Math.abs(rotation.y - window._lastRotationY);
                window._lastRotationY = rotation.y;

                // 行星环自动跟随主星球旋转速度
                if (ringParticles) {
                    // 系数可调，基础速度可调
                    let baseSpeed = 50;
                    let followCoef = 150; // 越大同步越灵敏
                    let newRingSpeed = baseSpeed + actualRotationSpeed * followCoef;
                    // 保持方向（与主星球一致）
                    config.ringRotationSpeed = newRingSpeed;
                }

                // 更新动画粒子
                if (config.particleAnimation && animatedParticles.length > 0) {
                    const animatedSystem = animatedParticles[0];
                    const positions = animatedSystem.geometry.attributes.position.array;
                    const speeds = animatedSystem.speeds;

                    for (let i = 0; i < speeds.length; i++) {
                        const speedData = speeds[i];
                        const baseX = speedData.baseX;
                        const baseY = speedData.baseY;
                        const baseZ = speedData.baseZ;

                        // 计算原始球面坐标
                        const radius = Math.sqrt(baseX * baseX + baseY * baseY + baseZ * baseZ);
                        const theta = Math.atan2(baseY, baseX);
                        const phi = Math.acos(baseZ / radius);

                        // 添加一些扰动
                        const time = Date.now() * 0.001;
                        const newTheta = theta + speedData.speed * speedData.direction.x * time;
                        const newPhi = phi + speedData.speed * speedData.direction.y * time;
                        const newRadius = radius + Math.sin(time * 2 + i) * 0.5;

                        positions[i * 3] = newRadius * Math.sin(newPhi) * Math.cos(newTheta);
                        positions[i * 3 + 1] = newRadius * Math.sin(newPhi) * Math.sin(newTheta);
                        positions[i * 3 + 2] = newRadius * Math.cos(newPhi);
                    }

                    animatedSystem.geometry.attributes.position.needsUpdate = true;
                }

                // 更新行星环旋转和喷射效果
                if (ringParticles) {
                    const isseaBlue = config.ringRotationSpeed < 0; // 判断是否是流浪地球模式

                    // 流浪地球模式下不自动调整旋转速度，保持预设值
                    if (!isseaBlue && !isDragging) {
                        currentRotationSpeed *= 0.95; // 速度衰减
                        // 使用相同方向的速度计算
                        config.ringRotationSpeed = baseRingRotationSpeed - currentRotationSpeed * 2;
                        // 保持速度在0.1到1之间，同时保留方向
                        config.ringRotationSpeed = Math.min(1, Math.max(0.1, Math.abs(config.ringRotationSpeed))) *
                            (config.ringRotationSpeed >= 0 ? 1 : -1);
                    }

                    // 流浪地球模式下增强喷射效果
                    if (isseaBlue) {
                        // 更快的旋转速度
                        ringRotation += 0.003 * config.ringRotationSpeed;

                        // 更新环粒子位置以模拟喷射
                        const positions = ringParticles.geometry.attributes.position.array;
                        const colors = ringParticles.geometry.attributes.color.array;
                        const time = Date.now() * 0.001;

                        for (let i = 0; i < config.ringParticleCount; i++) {
                            const i3 = i * 3;
                            const i4 = i * 4;

                            // 计算喷射强度和方向
                            const angle = Math.atan2(positions[i3 + 2], positions[i3]);
                            const progress = (time * 0.8 + i * 0.0005) % 1;
                            const jetIntensity = Math.pow(Math.sin(progress * Math.PI), 2) * 1.5;

                            // 向后喷射效果（沿Y轴负方向）
                            positions[i3 + 1] -= jetIntensity * 15;

                            // 添加径向喷射效果（向外扩散）
                            const radialIntensity = jetIntensity * 0.5;
                            positions[i3] += Math.cos(angle) * radialIntensity;
                            positions[i3 + 2] += Math.sin(angle) * radialIntensity;

                            // 随机扰动效果
                            const noise = 0.3 + Math.sin(time * 2 + i) * 0.2;
                            positions[i3] += (Math.random() - 0.5) * noise;
                            positions[i3 + 1] += (Math.random() - 0.5) * noise * 0.5;
                            positions[i3 + 2] += (Math.random() - 0.5) * noise;

                            // 根据喷射强度调整粒子颜色亮度
                            const brightness = 0.7 + jetIntensity * 0.6;
                            colors[i4] = Math.min(1, hexToRgb(config.secondaryColor).r * brightness);
                            colors[i4 + 1] = Math.min(1, hexToRgb(config.secondaryColor).g * brightness);
                            colors[i4 + 2] = Math.min(1, hexToRgb(config.secondaryColor).b * brightness);
                        }

                        ringParticles.geometry.attributes.position.needsUpdate = true;
                        ringParticles.geometry.attributes.color.needsUpdate = true;
                    } else {
                        // 普通模式下的旋转
                        ringRotation += 0.001 * config.ringRotationSpeed;
                    }

                    ringParticles.rotation.y = ringRotation;
                }

                // 渲染场景
                renderer.render(scene, camera);
            };

            // 开始动画
            animate();

            document.getElementById('IndefinablePreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                // Indefinable预设 - 创建超真实4DIndefinable穿越效果
                config.primaryColor = '#ffd700';    // 中心金色
                config.secondaryColor = '#000033';  // 深蓝背景
                config.particleSize = 0.015;        // 更细腻的粒子效果
                config.planetRadius = 0;            // 无中心星球
                config.rotationSpeed = 2.5;         // 更快的旋转速度
                config.particleCount = 2000000;     // 增加粒子数量到200万以获得更细腻效果
                config.ringParticleCount = 0;       // 不使用环系统
                config.ringWidth = 0;
                config.ringRadius = 0;
                config.ringRotationSpeed = 0;
                config.ringOpacity = 0;
                config.ringTilt = 0;
                config.ringThickness = 0;
                targetZoom = 200;                   // 更远的初始视角

                // 宇宙深空背景
                scene.background = new THREE.Color(0x000011);
                document.getElementById('bgColorPicker').value = '#000011';

                // 更新UI并重建粒子系统
                updateUIFromConfig();

                // 清除现有粒子系统
                particles.forEach(particle => scene.remove(particle));
                particles = [];
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                // 清除场景中的其他对象
                scene.children.forEach(child => {
                    if (child instanceof THREE.Mesh ||
                        child instanceof THREE.PointLight ||
                        child instanceof THREE.DirectionalLight) {
                        if (child !== ambientLight &&
                            child !== pointLight &&
                            child !== directionalLight) {
                            scene.remove(child);
                        }
                    }
                });

                // 创建Indefinable粒子系统
                const IndefinableGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.particleCount * 3);
                const colors = new Float32Array(config.particleCount * 3);
                const sizes = new Float32Array(config.particleCount);
                const velocities = new Float32Array(config.particleCount * 3); // 添加速度属性用于动画

                // Indefinable参数
                const innerRadius = 5;              // 内径
                const outerRadius = 60;             // 外径增大
                const length = 300;                 // Indefinable长度增加
                const spiralArms = 12;              // 螺旋臂数量增加
                const spiralTightness = 0.4;        // 螺旋紧密度增加

                // 增强版多段颜色渐变系统
                const colorStops = [
                    { pos: 0.0, color: { r: 1.0, g: 0.9, b: 0.2 } },    // 亮金色
                    { pos: 0.1, color: { r: 1.0, g: 0.8, b: 0.1 } },    // 暖金色
                    { pos: 0.2, color: { r: 1.0, g: 0.7, b: 0.0 } },     // 橙金色
                    { pos: 0.4, color: { r: 1.0, g: 0.5, b: 0.0 } },    // 深橙色
                    { pos: 0.5, color: { r: 0.8, g: 0.4, b: 0.3 } },    // 红橙色
                    { pos: 0.6, color: { r: 0.5, g: 0.4, b: 0.7 } },    // 紫蓝色
                    { pos: 0.7, color: { r: 0.3, g: 0.5, b: 0.9 } },    // 天蓝色
                    { pos: 0.8, color: { r: 0.1, g: 0.3, b: 0.8 } },    // 深蓝色
                    { pos: 0.9, color: { r: 0.05, g: 0.1, b: 0.5 } },   // 午夜蓝
                    { pos: 1.0, color: { r: 0.02, g: 0.02, b: 0.1 } }   // 深空蓝
                ];

                // 获取颜色渐变中的颜色
                function getGradientColor(ratio) {
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (ratio >= colorStops[i].pos && ratio <= colorStops[i + 1].pos) {
                            const localRatio = (ratio - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                            return {
                                r: colorStops[i].color.r * (1 - localRatio) + colorStops[i + 1].color.r * localRatio,
                                g: colorStops[i].color.g * (1 - localRatio) + colorStops[i + 1].color.g * localRatio,
                                b: colorStops[i].color.b * (1 - localRatio) + colorStops[i + 1].color.b * localRatio
                            };
                        }
                    }
                    return colorStops[colorStops.length - 1].color;
                }

                // 生成Indefinable粒子
                for (let i = 0; i < config.particleCount; i++) {
                    const i3 = i * 3;

                    // 决定粒子位置类型
                    const particleType = Math.random();
                    let radius, angle, zPos, colorRatio;

                    if (particleType < 0.65) {
                        // 主要螺旋结构
                        const arm = Math.floor(Math.random() * spiralArms);
                        radius = innerRadius + Math.pow(Math.random(), 1.5) * (outerRadius - innerRadius);

                        // 改进螺旋结构，使其更加自然
                        const spiralOffset = Math.random() * 0.2;
                        angle = (arm / spiralArms) * Math.PI * 2 +
                            (radius / outerRadius) * spiralTightness * Math.PI * 4 + spiralOffset;

                        // 使z轴分布更加集中在中心，形成漏斗状
                        const zDistribution = Math.pow(Math.random(), 1.2) * 2 - 1; // 偏向中心分布
                        zPos = zDistribution * length * (radius / outerRadius);

                        colorRatio = radius / outerRadius;
                    } else if (particleType < 0.85) {
                        // 背景星星
                        radius = outerRadius + Math.random() * 150;
                        angle = Math.random() * Math.PI * 2;
                        zPos = (Math.random() - 0.5) * length * 2;
                        colorRatio = 1;
                    } else if (particleType < 0.95) {
                        // 中心高亮粒子
                        radius = innerRadius * (0.1 + Math.random() * 0.9);
                        angle = Math.random() * Math.PI * 2;
                        zPos = (Math.random() - 0.5) * innerRadius * 2;
                        colorRatio = 0;
                    } else {
                        // 特殊效果粒子 - 从开端加速滑动到末尾的大粒子
                        radius = innerRadius * 0.5;
                        angle = Math.random() * Math.PI * 2;
                        zPos = length * 0.9; // 从开端开始
                        colorRatio = 0;
                        // 标记为大粒子
                        sizes[i] = 0.3 + Math.random() * 0.2;
                    }

                    // 计算位置
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = Math.sin(angle) * radius;
                    positions[i3 + 2] = zPos;

                    // 设置粒子速度 - 用于动画
                    const speedFactor = particleType < 0.95 ? 0.2 + Math.random() * 0.3 : 0.8 + Math.random() * 0.4;
                    velocities[i3] = (Math.random() - 0.5) * 0.01 * speedFactor;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.01 * speedFactor;
                    velocities[i3 + 2] = (particleType < 0.95 ? -1 : -2) * speedFactor; // 主要向负z方向移动

                    // 根据位置设置颜色 (使用更复杂的颜色渐变)
                    const color = getGradientColor(colorRatio);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;

                    // 根据位置设置粒子大小
                    if (particleType < 0.65) {
                        // 主要螺旋结构粒子
                        sizes[i] = 0.08 * (1 - colorRatio * 0.6);
                    } else if (particleType < 0.85) {
                        // 背景星星
                        sizes[i] = 0.03 + Math.random() * 0.04;
                    } else if (particleType < 0.95) {
                        // 中心高亮粒子
                        sizes[i] = 0.12 + Math.random() * 0.08;
                    } else {
                        // 特殊效果粒子
                        sizes[i] = 0.15 + Math.random() * 0.15;
                    }

                    // 中心区域增加亮度
                    if (radius < innerRadius * 2) {
                        const brightness = 1 + (1 - radius / (innerRadius * 2)) * 3;
                        colors[i3] = Math.min(1, colors[i3] * brightness);
                        colors[i3 + 1] = Math.min(1, colors[i3 + 1] * brightness);
                        colors[i3 + 2] = Math.min(1, colors[i3 + 2] * brightness);
                    }

                    // 增强闪烁星星效果
                    if (Math.random() < 0.02) { // 提高闪烁概率
                        const flashIntensity = 1.8 + Math.random() * 0.5; // 更强烈的闪烁
                        colors[i3] = Math.min(1, colors[i3] * flashIntensity);
                        colors[i3 + 1] = Math.min(1, colors[i3 + 1] * flashIntensity);
                        colors[i3 + 2] = Math.min(1, colors[i3 + 2] * flashIntensity);
                        sizes[i] *= 1.8; // 更大的尺寸变化

                        // 添加闪烁衰减效果
                        setTimeout(() => {
                            colors[i3] /= flashIntensity * 0.8;
                            colors[i3 + 1] /= flashIntensity * 0.8;
                            colors[i3 + 2] /= flashIntensity * 0.8;
                            sizes[i] /= 1.5;
                            Indefinable.geometry.attributes.color.needsUpdate = true;
                            Indefinable.geometry.attributes.size.needsUpdate = true;
                        }, 200 + Math.random() * 300); // 随机衰减时间
                    }
                }

                IndefinableGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                IndefinableGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                IndefinableGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                // 自定义着色器材质，用于实现更高级的视觉效果
                const IndefinableMaterial = new THREE.PointsMaterial({
                    size: 0.08,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false // 禁用深度写入以改善混合效果
                });

                const Indefinable = new THREE.Points(IndefinableGeometry, IndefinableMaterial);
                scene.add(Indefinable);
                particles.push(Indefinable);

                // 添加螺旋结构增强 - 更多的光源
                const lightColors = [
                    0xffd700, // 金色
                    0xff8c00, // 深橙色
                    0x4169e1, // 皇家蓝
                    0x1e90ff, // 道奇蓝
                    0x00bfff, // 深天蓝
                    0x87cefa  // 淡蓝色
                ];

                for (let arm = 0; arm < spiralArms; arm++) {
                    const armAngle = (arm / spiralArms) * Math.PI * 2;
                    const lightColor = lightColors[arm % lightColors.length];
                    const armLight = new THREE.PointLight(lightColor, 0.8, 120);
                    armLight.position.set(
                        Math.cos(armAngle) * 35,
                        Math.sin(armAngle) * 35,
                        (arm % 2 === 0) ? 30 : -30 // 交替放置在z轴正负方向
                    );
                    scene.add(armLight);
                }

                // 增强中心光晕系统
                const glowGeometry = new THREE.SphereGeometry(12, 64, 64); // 更高分辨率
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.5, // 提高不透明度
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                scene.add(glow);

                // 动态脉动光晕效果
                function pulseGlow() {
                    const scale = 1 + Math.sin(Date.now() * 0.002) * 0.1;
                    glow.scale.set(scale, scale, scale);
                    requestAnimationFrame(pulseGlow);
                }
                pulseGlow();

                // 增强外层光晕
                const outerGlowGeometry = new THREE.SphereGeometry(18, 64, 64);
                const outerGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
                scene.add(outerGlow);

                // 增强Indefinable出口光晕
                const exitGlowGeometry = new THREE.SphereGeometry(15, 64, 64);
                const exitGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x6495ed, // 更亮的蓝色
                    transparent: true,
                    opacity: 0.4, // 提高不透明度
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const exitGlow = new THREE.Mesh(exitGlowGeometry, exitGlowMaterial);
                exitGlow.position.z = -length * 0.8;

                // 出口光晕脉动效果
                function pulseExitGlow() {
                    const scale = 1 + Math.sin(Date.now() * 0.0015) * 0.15;
                    exitGlow.scale.set(scale, scale, scale);
                    requestAnimationFrame(pulseExitGlow);
                }
                scene.add(exitGlow);
                pulseExitGlow();

                // 添加镜头动画 - 完整的Indefinable穿越体验
                let animationStartTime = Date.now();
                let animationPhase = 0; // 0: 接近, 1: 穿越, 2: 出口, 3: 结束
                let lastUpdateTime = Date.now();

                // 粒子动画函数 - 使粒子随时间流动
                function animateParticles() {
                    const now = Date.now();
                    const deltaTime = (now - lastUpdateTime) / 1000;
                    lastUpdateTime = now;

                    const positions = Indefinable.geometry.attributes.position.array;
                    const colors = Indefinable.geometry.attributes.color.array;
                    const sizes = Indefinable.geometry.attributes.size.array;

                    // 更新粒子位置
                    for (let i = 0; i < config.particleCount; i++) {
                        const i3 = i * 3;

                        // 移动粒子
                        if (sizes[i] > 0.3) { // 大粒子特殊处理
                            // 加速滑动到末尾
                            const progress = (positions[i3 + 2] + length) / (length * 2);
                            const speed = 0.5 + progress * 2; // 逐渐加速
                            positions[i3 + 2] -= speed * deltaTime * 60;

                            // 相机跟随大粒子
                            if (i === 0) { // 只跟随第一个大粒子
                                targetZoom = 15 + progress * 10;
                                targetRotation.y = angle;
                                targetRotation.x = 0;
                            }

                            // 如果到达末尾，重置到开端
                            if (positions[i3 + 2] < -length * 0.9) {
                                positions[i3 + 2] = length * 0.9;
                            }
                        } else {
                            // 普通粒子正常移动
                            positions[i3] += velocities[i3] * deltaTime * 60;
                            positions[i3 + 1] += velocities[i3 + 1] * deltaTime * 60;
                            positions[i3 + 2] += velocities[i3 + 2] * deltaTime * 60;

                            // 如果粒子移出Indefinable，重新放置到入口
                            if (positions[i3 + 2] < -length) {
                                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                                const angle = Math.random() * Math.PI * 2;
                                positions[i3] = Math.cos(angle) * radius;
                                positions[i3 + 1] = Math.sin(angle) * radius;
                                positions[i3 + 2] = length * 0.5;
                            }

                            // 随机闪烁效果
                            if (Math.random() < 0.05) {
                                const colorRatio = radius / outerRadius;
                                const color = getGradientColor(colorRatio);
                                colors[i3] = color.r * 2;
                                colors[i3 + 1] = color.g * 2;
                                colors[i3 + 2] = color.b * 2;
                                sizes[i] *= 1.2;
                            }
                        }

                        // 随机闪烁效果
                        if (Math.random() < 0.001) {
                            colors[i3] = Math.min(1, colors[i3] * (1.5 + Math.random()));
                            colors[i3 + 1] = Math.min(1, colors[i3 + 1] * (1.5 + Math.random()));
                            colors[i3 + 2] = Math.min(1, colors[i3 + 2] * (1.5 + Math.random()));
                        } else if (Math.random() < 0.001) {
                            // 逐渐恢复正常亮度
                            const x = positions[i3];
                            const y = positions[i3 + 1];
                            const z = positions[i3 + 2];
                            const radius = Math.sqrt(x * x + y * y);
                            const colorRatio = radius / outerRadius;
                            const color = getGradientColor(colorRatio);

                            colors[i3] = color.r;
                            colors[i3 + 1] = color.g;
                            colors[i3 + 2] = color.b;

                            // 中心区域增加亮度
                            if (radius < innerRadius * 2) {
                                const brightness = 1 + (1 - radius / (innerRadius * 2)) * 3;
                                colors[i3] = Math.min(1, colors[i3] * brightness);
                                colors[i3 + 1] = Math.min(1, colors[i3 + 1] * brightness);
                                colors[i3 + 2] = Math.min(1, colors[i3 + 2] * brightness);
                            }
                        }
                    }

                    Indefinable.geometry.attributes.position.needsUpdate = true;
                    Indefinable.geometry.attributes.color.needsUpdate = true;
                    Indefinable.geometry.attributes.size.needsUpdate = true;

                    requestAnimationFrame(animateParticles);
                }

                // 启动粒子动画
                animateParticles();

                // 完整的穿越动画
                const animateCamera = () => {
                    const elapsed = (Date.now() - animationStartTime) / 1000;

                    // 动画阶段控制
                    if (elapsed < 5 && animationPhase === 0) {
                        // 阶段0: 接近Indefinable
                        const progress = elapsed / 5;
                        const easeOut = 1 - Math.pow(1 - progress, 3);
                        targetZoom = 100 - easeOut * 85; // 从100到15
                        targetRotation.y = easeOut * Math.PI * 0.5;
                    } else if (elapsed >= 5 && elapsed < 8 && animationPhase <= 1) {
                        // 阶段1: 穿越Indefinable
                        animationPhase = 1;
                        const progress = (elapsed - 5) / 3;
                        targetZoom = 15 - progress * 10; // 从15到5
                        targetRotation.y += 0.02;
                        targetRotation.x = Math.sin(elapsed * 0.5) * 0.3;
                    } else if (elapsed >= 8 && elapsed < 12 && animationPhase <= 2) {
                        // 阶段2: 从Indefinable出口出现
                        animationPhase = 2;
                        const progress = (elapsed - 8) / 4;
                        targetZoom = 5 + progress * 50; // 从5到55
                        targetRotation.y += 0.01;
                        targetRotation.x = Math.sin(elapsed * 0.3) * 0.2;
                    } else if (elapsed >= 12 && animationPhase <= 3) {
                        // 阶段3: 稳定观察
                        animationPhase = 3;
                        targetZoom = 55;
                    }

                    if (elapsed < 15) {
                        requestAnimationFrame(animateCamera);
                    }
                };
                animateCamera();
                clearAndApplyBackground('IndefinablePreset');
            });



            document.getElementById('wormholePreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                // 虫洞预设 - 创建超真实4D虫洞穿越效果
                config.primaryColor = '#ffd700';    // 中心金色
                config.secondaryColor = '#000033';  // 深蓝背景
                config.particleSize = 0.015;        // 更细腻的粒子效果
                config.planetRadius = 0;            // 无中心星球
                config.rotationSpeed = 2.5;         // 更快的旋转速度
                config.particleCount = 2000000;     // 增加粒子数量到200万以获得更细腻效果
                config.ringParticleCount = 0;       // 不使用环系统
                config.ringWidth = 0;
                config.ringRadius = 0;
                config.ringRotationSpeed = 0;
                config.ringOpacity = 0;
                config.ringTilt = 0;
                config.ringThickness = 0;
                targetZoom = 200;                   // 更远的初始视角

                // 宇宙深空背景
                scene.background = new THREE.Color(0x000011);
                document.getElementById('bgColorPicker').value = '#000011';

                // 更新UI并重建粒子系统
                updateUIFromConfig();

                // 清除现有粒子系统
                particles.forEach(particle => scene.remove(particle));
                particles = [];
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                // 清除场景中的其他对象
                scene.children.forEach(child => {
                    if (child instanceof THREE.Mesh ||
                        child instanceof THREE.PointLight ||
                        child instanceof THREE.DirectionalLight) {
                        if (child !== ambientLight &&
                            child !== pointLight &&
                            child !== directionalLight) {
                            scene.remove(child);
                        }
                    }
                });

                // 创建虫洞粒子系统
                const wormholeGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.particleCount * 3);
                const colors = new Float32Array(config.particleCount * 3);
                const sizes = new Float32Array(config.particleCount);
                const velocities = new Float32Array(config.particleCount * 3); // 添加速度属性用于动画

                // 虫洞参数
                const innerRadius = 5;              // 内径
                const outerRadius = 60;             // 外径增大
                const length = 300;                 // 虫洞长度增加
                const spiralArms = 12;              // 螺旋臂数量增加
                const spiralTightness = 0.4;        // 螺旋紧密度增加

                // 定义虫洞颜色渐变
                const colorStops = [
                    { pos: 0.0, color: { r: 1.0, g: 0.84, b: 0.0 } },    // 中心金色 #ffd700
                    { pos: 0.3, color: { r: 1.0, g: 0.6, b: 0.0 } },     // 橙色
                    { pos: 0.6, color: { r: 0.2, g: 0.4, b: 0.8 } },     // 蓝色
                    { pos: 1.0, color: { r: 0.0, g: 0.0, b: 0.2 } }      // 深蓝色 #000033
                ];

                // 获取颜色渐变中的颜色
                function getGradientColor(ratio) {
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (ratio >= colorStops[i].pos && ratio <= colorStops[i + 1].pos) {
                            const localRatio = (ratio - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                            return {
                                r: colorStops[i].color.r * (1 - localRatio) + colorStops[i + 1].color.r * localRatio,
                                g: colorStops[i].color.g * (1 - localRatio) + colorStops[i + 1].color.g * localRatio,
                                b: colorStops[i].color.b * (1 - localRatio) + colorStops[i + 1].color.b * localRatio
                            };
                        }
                    }
                    return colorStops[colorStops.length - 1].color;
                }

                // 生成虫洞粒子
                for (let i = 0; i < config.particleCount; i++) {
                    const i3 = i * 3;

                    // 决定粒子位置类型
                    const particleType = Math.random();
                    let radius, angle, zPos, colorRatio;

                    if (particleType < 0.65) {
                        // 主要螺旋结构
                        const arm = Math.floor(Math.random() * spiralArms);
                        radius = innerRadius + Math.pow(Math.random(), 1.5) * (outerRadius - innerRadius);

                        // 改进螺旋结构，使其更加自然
                        const spiralOffset = Math.random() * 0.2;
                        angle = (arm / spiralArms) * Math.PI * 2 +
                            (radius / outerRadius) * spiralTightness * Math.PI * 4 + spiralOffset;

                        // 使z轴分布更加集中在中心，形成漏斗状
                        const zDistribution = Math.pow(Math.random(), 1.2) * 2 - 1; // 偏向中心分布
                        zPos = zDistribution * length * (radius / outerRadius);

                        colorRatio = radius / outerRadius;
                    } else if (particleType < 0.85) {
                        // 背景星星
                        radius = outerRadius + Math.random() * 150;
                        angle = Math.random() * Math.PI * 2;
                        zPos = (Math.random() - 0.5) * length * 2;
                        colorRatio = 1;
                    } else if (particleType < 0.95) {
                        // 中心高亮粒子
                        radius = innerRadius * (0.1 + Math.random() * 0.9);
                        angle = Math.random() * Math.PI * 2;
                        zPos = (Math.random() - 0.5) * innerRadius * 2;
                        colorRatio = 0;
                    } else {
                        // 特殊效果粒子 - 光流
                        radius = innerRadius * 0.5 + Math.random() * outerRadius * 0.5;
                        angle = Math.random() * Math.PI * 2;
                        zPos = (Math.random() * 2 - 1) * length;
                        colorRatio = 0.2;
                    }

                    // 计算位置
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = Math.sin(angle) * radius;
                    positions[i3 + 2] = zPos;

                    // 设置粒子速度 - 用于动画
                    const speedFactor = particleType < 0.95 ? 0.2 + Math.random() * 0.3 : 0.8 + Math.random() * 0.4;
                    velocities[i3] = (Math.random() - 0.5) * 0.01 * speedFactor;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.01 * speedFactor;
                    velocities[i3 + 2] = (particleType < 0.95 ? -1 : -2) * speedFactor; // 主要向负z方向移动

                    // 根据位置设置颜色 (使用更复杂的颜色渐变)
                    const color = getGradientColor(colorRatio);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;

                    // 根据位置设置粒子大小
                    if (particleType < 0.65) {
                        // 主要螺旋结构粒子
                        sizes[i] = 0.08 * (1 - colorRatio * 0.6);
                    } else if (particleType < 0.85) {
                        // 背景星星
                        sizes[i] = 0.03 + Math.random() * 0.04;
                    } else if (particleType < 0.95) {
                        // 中心高亮粒子
                        sizes[i] = 0.12 + Math.random() * 0.08;
                    } else {
                        // 特殊效果粒子
                        sizes[i] = 0.15 + Math.random() * 0.15;
                    }

                    // 中心区域增加亮度
                    if (radius < innerRadius * 2) {
                        const brightness = 1 + (1 - radius / (innerRadius * 2)) * 3;
                        colors[i3] = Math.min(1, colors[i3] * brightness);
                        colors[i3 + 1] = Math.min(1, colors[i3 + 1] * brightness);
                        colors[i3 + 2] = Math.min(1, colors[i3 + 2] * brightness);
                    }

                    // 随机添加闪烁星星
                    if (Math.random() < 0.01) {
                        colors[i3] = Math.min(1, colors[i3] * 2);
                        colors[i3 + 1] = Math.min(1, colors[i3 + 1] * 2);
                        colors[i3 + 2] = Math.min(1, colors[i3 + 2] * 2);
                        sizes[i] *= 1.5;
                    }
                }

                wormholeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                wormholeGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                wormholeGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                // 自定义着色器材质，用于实现更高级的视觉效果
                const wormholeMaterial = new THREE.PointsMaterial({
                    size: 0.08,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false // 禁用深度写入以改善混合效果
                });

                const wormhole = new THREE.Points(wormholeGeometry, wormholeMaterial);
                scene.add(wormhole);
                particles.push(wormhole);

                // 添加螺旋结构增强 - 更多的光源
                const lightColors = [
                    0xffd700, // 金色
                    0xff8c00, // 深橙色
                    0x4169e1, // 皇家蓝
                    0x1e90ff, // 道奇蓝
                    0x00bfff, // 深天蓝
                    0x87cefa  // 淡蓝色
                ];

                for (let arm = 0; arm < spiralArms; arm++) {
                    const armAngle = (arm / spiralArms) * Math.PI * 2;
                    const lightColor = lightColors[arm % lightColors.length];
                    const armLight = new THREE.PointLight(lightColor, 0.8, 120);
                    armLight.position.set(
                        Math.cos(armAngle) * 35,
                        Math.sin(armAngle) * 35,
                        (arm % 2 === 0) ? 30 : -30 // 交替放置在z轴正负方向
                    );
                    scene.add(armLight);
                }

                // 添加中心光晕 - 更大更亮
                const glowGeometry = new THREE.SphereGeometry(10, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                scene.add(glow);

                // 添加第二个光晕层
                const outerGlowGeometry = new THREE.SphereGeometry(15, 32, 32);
                const outerGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffcc00,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                });
                const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
                scene.add(outerGlow);

                // 添加虫洞出口光晕
                const exitGlowGeometry = new THREE.SphereGeometry(12, 32, 32);
                const exitGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x4169e1, // 皇家蓝
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                const exitGlow = new THREE.Mesh(exitGlowGeometry, exitGlowMaterial);
                exitGlow.position.z = -length * 0.8; // 放置在虫洞另一端
                scene.add(exitGlow);

                // 添加镜头动画 - 完整的虫洞穿越体验
                let animationStartTime = Date.now();
                let animationPhase = 0; // 0: 接近, 1: 穿越, 2: 出口, 3: 结束
                let lastUpdateTime = Date.now();

                // 粒子动画函数 - 使粒子随时间流动
                function animateParticles() {
                    const now = Date.now();
                    const deltaTime = (now - lastUpdateTime) / 1000;
                    lastUpdateTime = now;

                    const positions = wormhole.geometry.attributes.position.array;
                    const colors = wormhole.geometry.attributes.color.array;
                    const sizes = wormhole.geometry.attributes.size.array;

                    // 更新粒子位置
                    for (let i = 0; i < config.particleCount; i++) {
                        const i3 = i * 3;

                        // 移动粒子
                        positions[i3] += velocities[i3] * deltaTime * 60;
                        positions[i3 + 1] += velocities[i3 + 1] * deltaTime * 60;
                        positions[i3 + 2] += velocities[i3 + 2] * deltaTime * 60;

                        // 如果粒子移出虫洞，重新放置到入口
                        if (positions[i3 + 2] < -length) {
                            // 重置到虫洞入口
                            const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                            const angle = Math.random() * Math.PI * 2;
                            positions[i3] = Math.cos(angle) * radius;
                            positions[i3 + 1] = Math.sin(angle) * radius;
                            positions[i3 + 2] = length * 0.5;

                            // 随机闪烁效果
                            if (Math.random() < 0.05) {
                                const colorRatio = radius / outerRadius;
                                const color = getGradientColor(colorRatio);
                                colors[i3] = color.r * 2;
                                colors[i3 + 1] = color.g * 2;
                                colors[i3 + 2] = color.b * 2;
                                sizes[i] *= 1.2;
                            }
                        }

                        // 随机闪烁效果
                        if (Math.random() < 0.001) {
                            colors[i3] = Math.min(1, colors[i3] * (1.5 + Math.random()));
                            colors[i3 + 1] = Math.min(1, colors[i3 + 1] * (1.5 + Math.random()));
                            colors[i3 + 2] = Math.min(1, colors[i3 + 2] * (1.5 + Math.random()));
                        } else if (Math.random() < 0.001) {
                            // 逐渐恢复正常亮度
                            const x = positions[i3];
                            const y = positions[i3 + 1];
                            const z = positions[i3 + 2];
                            const radius = Math.sqrt(x * x + y * y);
                            const colorRatio = radius / outerRadius;
                            const color = getGradientColor(colorRatio);

                            colors[i3] = color.r;
                            colors[i3 + 1] = color.g;
                            colors[i3 + 2] = color.b;

                            // 中心区域增加亮度
                            if (radius < innerRadius * 2) {
                                const brightness = 1 + (1 - radius / (innerRadius * 2)) * 3;
                                colors[i3] = Math.min(1, colors[i3] * brightness);
                                colors[i3 + 1] = Math.min(1, colors[i3 + 1] * brightness);
                                colors[i3 + 2] = Math.min(1, colors[i3 + 2] * brightness);
                            }
                        }
                    }

                    wormhole.geometry.attributes.position.needsUpdate = true;
                    wormhole.geometry.attributes.color.needsUpdate = true;
                    wormhole.geometry.attributes.size.needsUpdate = true;

                    requestAnimationFrame(animateParticles);
                }

                // 启动粒子动画
                animateParticles();

                // 完整的穿越动画
                const animateCamera = () => {
                    const elapsed = (Date.now() - animationStartTime) / 1000;

                    // 动画阶段控制
                    if (elapsed < 5 && animationPhase === 0) {
                        // 阶段0: 接近虫洞
                        const progress = elapsed / 5;
                        const easeOut = 1 - Math.pow(1 - progress, 3);
                        targetZoom = 100 - easeOut * 85; // 从100到15
                        targetRotation.y = easeOut * Math.PI * 0.5;
                    } else if (elapsed >= 5 && elapsed < 8 && animationPhase <= 1) {
                        // 阶段1: 穿越虫洞
                        animationPhase = 1;
                        const progress = (elapsed - 5) / 3;
                        targetZoom = 15 - progress * 10; // 从15到5
                        targetRotation.y += 0.02;
                        targetRotation.x = Math.sin(elapsed * 0.5) * 0.3;
                    } else if (elapsed >= 8 && elapsed < 12 && animationPhase <= 2) {
                        // 阶段2: 从虫洞出口出现
                        animationPhase = 2;
                        const progress = (elapsed - 8) / 4;
                        targetZoom = 5 + progress * 50; // 从5到55
                        targetRotation.y += 0.01;
                        targetRotation.x = Math.sin(elapsed * 0.3) * 0.2;
                    } else if (elapsed >= 12 && animationPhase <= 3) {
                        // 阶段3: 稳定观察
                        animationPhase = 3;
                        targetZoom = 55;
                    }

                    if (elapsed < 15) {
                        requestAnimationFrame(animateCamera);
                    }
                };
                animateCamera();
                clearAndApplyBackground('wormholePreset');
            });

            document.getElementById('blackHolePreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                // 黑洞预设 - 创建逼真的黑洞效果
                config.primaryColor = '#ff4500';    // 炽热橙色
                config.secondaryColor = '#00bfff';  // 冷冽蓝色
                config.particleSize = 0.05;         // 更小的粒子以创造更细腻的效果
                config.planetRadius = 0;            // 移除中心星球
                config.rotationSpeed = 3.0;         // 高速旋转
                config.particleCount = 600000;      // 大量粒子以创造丰富的视觉效果
                config.ringParticleCount = 0;       // 不使用环系统
                config.ringWidth = 0;
                config.ringRadius = 0;
                config.ringRotationSpeed = 0;
                config.ringOpacity = 0;
                config.ringTilt = 0;
                config.ringThickness = 0;
                targetZoom = 60;                    // 更近的视角以展示黑洞细节

                // 深邃的宇宙背景
                scene.background = new THREE.Color(0x000000);
                document.getElementById('bgColorPicker').value = '#000000';

                // 更新UI并重建粒子系统
                updateUIFromConfig();

                // 清除现有的粒子系统和环系统
                particles.forEach(particle => scene.remove(particle));
                particles = [];
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                // 创建黑洞粒子系统
                const blackHoleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.particleCount * 3);
                const colors = new Float32Array(config.particleCount * 3);
                const sizes = new Float32Array(config.particleCount);

                // 黑洞参数
                const eventHorizonRadius = 10;      // 事件视界半径
                const accretionDiskRadius = 30;     // 吸积盘半径
                const spiralFactor = 12;            // 螺旋因子
                const densityFactor = 2.5;          // 密度因子

                // 定义吸积盘颜色
                const diskColors = [
                    { r: 1.0, g: 0.3, b: 0.0 },    // 炽热橙色
                    { r: 1.0, g: 0.6, b: 0.0 },    // 金黄色
                    { r: 1.0, g: 0.8, b: 0.0 },    // 亮黄色
                    { r: 0.0, g: 0.5, b: 1.0 },    // 天蓝色
                    { r: 0.0, g: 0.8, b: 1.0 },    // 浅蓝色
                    { r: 0.5, g: 0.0, b: 1.0 },    // 紫色
                    { r: 1.0, g: 0.0, b: 0.5 },    // 玫瑰红
                    { r: 1.0, g: 0.4, b: 0.0 }     // 橙红色
                ];

                // 生成黑洞粒子
                for (let i = 0; i < config.particleCount; i++) {
                    const i3 = i * 3;

                    // 决定粒子类型
                    const particleType = Math.random();
                    let radius, angle, colorIndex;

                    if (particleType < 0.4) {
                        // 吸积盘主体
                        const diskType = Math.random();
                        if (diskType < 0.6) {
                            // 主要吸积盘
                            radius = eventHorizonRadius + Math.random() * (accretionDiskRadius - eventHorizonRadius);
                            angle = Math.random() * Math.PI * 2;
                        } else {
                            // 螺旋结构
                            const spiralOffset = Math.random() * 0.5;
                            radius = eventHorizonRadius + Math.random() * (accretionDiskRadius - eventHorizonRadius);
                            angle = (radius / accretionDiskRadius) * spiralFactor + spiralOffset;
                        }
                        colorIndex = Math.floor(Math.random() * diskColors.length);
                    } else if (particleType < 0.7) {
                        // 背景星星
                        radius = accretionDiskRadius + Math.random() * 100;
                        angle = Math.random() * Math.PI * 2;
                        colorIndex = Math.floor(Math.random() * 3); // 使用较少的颜色
                    } else if (particleType < 0.85) {
                        // 事件视界附近的粒子
                        radius = eventHorizonRadius * (0.8 + Math.random() * 0.4);
                        angle = Math.random() * Math.PI * 2;
                        colorIndex = Math.floor(Math.random() * diskColors.length);
                    } else {
                        // 被吞噬的恒星
                        radius = eventHorizonRadius * (0.5 + Math.random() * 0.3);
                        angle = Math.random() * Math.PI * 2;
                        colorIndex = 0; // 使用最亮的颜色
                    }

                    // 添加一些随机性
                    radius += (Math.random() - 0.5) * 2;

                    // 计算位置
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = (Math.random() - 0.5) * 0.5; // 减少垂直方向的偏移
                    positions[i3 + 2] = Math.sin(angle) * radius;

                    // 根据位置设置颜色
                    const distanceFromCenter = Math.sqrt(positions[i3] * positions[i3] + positions[i3 + 2] * positions[i3 + 2]);
                    const colorRatio = distanceFromCenter / accretionDiskRadius;

                    if (particleType < 0.4) {
                        // 吸积盘颜色
                        const diskColor = diskColors[colorIndex];
                        const brightness = 0.7 + (1 - colorRatio) * 0.3;
                        colors[i3] = diskColor.r * brightness;
                        colors[i3 + 1] = diskColor.g * brightness;
                        colors[i3 + 2] = diskColor.b * brightness;

                        // 添加发光效果
                        if (Math.random() < 0.1) {
                            colors[i3] = Math.min(1, colors[i3] * 1.5);
                            colors[i3 + 1] = Math.min(1, colors[i3 + 1] * 1.5);
                            colors[i3 + 2] = Math.min(1, colors[i3 + 2] * 1.5);
                        }
                    } else if (particleType < 0.7) {
                        // 背景星星颜色
                        const starBrightness = 0.5 + Math.random() * 0.5;
                        colors[i3] = starBrightness;
                        colors[i3 + 1] = starBrightness;
                        colors[i3 + 2] = starBrightness;
                    } else if (particleType < 0.85) {
                        // 事件视界附近的粒子颜色
                        const diskColor = diskColors[colorIndex];
                        const brightness = 0.8 + Math.random() * 0.2;
                        colors[i3] = diskColor.r * brightness;
                        colors[i3 + 1] = diskColor.g * brightness;
                        colors[i3 + 2] = diskColor.b * brightness;
                    } else {
                        // 被吞噬的恒星颜色
                        const brightness = 0.9 + Math.random() * 0.1;
                        colors[i3] = brightness;
                        colors[i3 + 1] = brightness * 0.8;
                        colors[i3 + 2] = brightness * 0.6;
                    }

                    // 根据位置设置粒子大小
                    if (particleType < 0.4) {
                        // 吸积盘粒子大小
                        sizes[i] = 0.08 * (1 - colorRatio * 0.5);
                    } else if (particleType < 0.7) {
                        // 背景星星大小
                        sizes[i] = 0.05 + Math.random() * 0.05;
                    } else if (particleType < 0.85) {
                        // 事件视界附近的粒子大小 - 增强视觉冲击力
                        const variance = Math.random() * 0.05; // 添加微小变化增加自然感
                        const baseSize = 0.1 + (particleType - 0.7) * 0.5; // 根据粒子类型线性增加大小
                        sizes[i] = baseSize + variance;
                    } else {
                        // 被吞噬的恒星大小
                        sizes[i] = 0.15 + Math.random() * 0.1;
                    }
                }

                blackHoleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                blackHoleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                blackHoleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const blackHoleMaterial = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                const blackHole = new THREE.Points(blackHoleGeometry, blackHoleMaterial);
                scene.add(blackHole);
                particles.push(blackHole);

                // 添加多个点光源创造吸积盘发光效果
                const lightColors = ['#ff4500', '#ff8c00', '#ffd700', '#00bfff', '#1e90ff', '#4169e1'];
                lightColors.forEach((color, index) => {
                    const light = new THREE.PointLight(color, 2.0, 200);
                    const angle = (index / lightColors.length) * Math.PI * 2;
                    light.position.set(
                        Math.cos(angle) * 50,
                        Math.sin(angle) * 50,
                        Math.sin(index) * 30
                    );
                    scene.add(light);
                });

                // 增加环境光亮度以突出色彩
                scene.children.forEach(child => {
                    if (child instanceof THREE.AmbientLight) {
                        child.intensity = 0.4;
                    }
                });
                clearAndApplyBackground('blackHolePreset');
            });

            function clearScene() {
                // 移除所有粒子系统
                particles.forEach(p => scene.remove(p));
                particles = [];
                animatedParticles.forEach(p => scene.remove(p.system));
                animatedParticles = [];
                stars.forEach(s => scene.remove(s));
                stars = [];
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                // 移除所有非基础光源和Mesh
                const keep = [ambientLight, pointLight, directionalLight];
                for (let i = scene.children.length - 1; i >= 0; i--) {
                    const obj = scene.children[i];
                    if (
                        (obj instanceof THREE.PointLight || obj instanceof THREE.Mesh || obj instanceof THREE.DirectionalLight) &&
                        !keep.includes(obj)
                    ) {
                        scene.remove(obj);
                    }
                }
                createStars();

                // 修复标题粒子效果在预设切换后无法触发的问题
                setTimeout(() => {
                    // 重新绑定标题粒子效果
                    const textSpan = document.querySelector('.starflow-effect-text');
                    if (textSpan) {
                        // 重新创建粒子效果
                        document.removeEventListener('DOMContentLoaded', createStarflowCanvas);
                        document.removeEventListener('DOMContentLoaded', createColorfulBurst);

                        createStarflowCanvas();
                        const burstFunc = createColorfulBurst();

                        if (burstFunc && textSpan.parentElement && textSpan.parentElement.parentElement) {
                            // 移除旧事件
                            const titleElement = textSpan.parentElement.parentElement;
                            const oldListeners = titleElement.getEventListeners?.() || [];
                            if (oldListeners.length > 0) {
                                titleElement.replaceWith(titleElement.cloneNode(true));
                            }

                            // 重新添加事件监听器
                            const newTitleElement = document.querySelector('.info-title');
                            if (newTitleElement) {
                                newTitleElement.addEventListener('mouseenter', () => {
                                    const starCanvas = document.querySelector('.starflow-canvas');
                                    if (starCanvas) {
                                        starCanvas.style.opacity = 1;
                                    }
                                    burstFunc();
                                });

                                // 模拟鼠标进入事件以触发一次效果
                                const mouseEnterEvent = new MouseEvent('mouseenter');
                                newTitleElement.dispatchEvent(mouseEnterEvent);
                            }
                        }
                    }
                }, 200);
            }

            document.getElementById('clourfulPlantPreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                // 超级无敌好看的精彩绝伦无与伦比的配色
                config.primaryColor = '#ff6bcb'; // 粉紫
                config.secondaryColor = '#6bffb8'; // 薄荷绿
                config.particleSize = 0.13;
                config.planetRadius = 17;
                config.rotationSpeed = 0.8;
                config.particleCount = 120000;
                config.ringParticleCount = 40000;
                config.ringWidth = 8;
                config.ringRadius = 28;
                config.ringRotationSpeed = 0.45;
                config.ringOpacity = 0.85;
                config.ringTilt = 0.38;
                config.ringThickness = 1.8;
                targetZoom = 45;
                scene.background = new THREE.Color('#1a093a');
                document.getElementById('bgColorPicker').value = '#1a093a';
                updateUIFromConfig();
                // 彩色渐变粒子
                function getColorfulGradient(t) {
                    // t: 0~1
                    const stops = [
                        { pos: 0.0, color: { r: 1.0, g: 0.42, b: 0.42 } }, // 红
                        { pos: 0.18, color: { r: 1.0, g: 0.8, b: 0.2 } }, // 金黄
                        { pos: 0.36, color: { r: 0.2, g: 1.0, b: 0.6 } }, // 绿
                        { pos: 0.54, color: { r: 0.2, g: 0.7, b: 1.0 } }, // 蓝
                        { pos: 0.72, color: { r: 0.7, g: 0.2, b: 1.0 } }, // 紫
                        { pos: 0.9, color: { r: 1.0, g: 0.2, b: 0.8 } }, // 粉
                        { pos: 1.0, color: { r: 1.0, g: 0.42, b: 0.42 } } // 红
                    ];
                    for (let i = 0; i < stops.length - 1; i++) {
                        if (t >= stops[i].pos && t <= stops[i + 1].pos) {
                            const localT = (t - stops[i].pos) / (stops[i + 1].pos - stops[i].pos);
                            return {
                                r: stops[i].color.r * (1 - localT) + stops[i + 1].color.r * localT,
                                g: stops[i].color.g * (1 - localT) + stops[i + 1].color.g * localT,
                                b: stops[i].color.b * (1 - localT) + stops[i + 1].color.b * localT
                            };
                        }
                    }
                    return stops[stops.length - 1].color;
                }
                // 重写createParticles
                if (particles.length > 0) {
                    particles.forEach(particle => scene.remove(particle));
                    particles = [];
                }
                const particlesGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.particleCount * 3);
                const colors = new Float32Array(config.particleCount * 3);
                const sizes = new Float32Array(config.particleCount);
                for (let i = 0; i < config.particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const radius = config.planetRadius * (0.9 + Math.random() * 0.1);
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    // 彩色渐变
                    const t = (phi / Math.PI + theta / (2 * Math.PI)) / 2;
                    const c = getColorfulGradient(t);
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                    sizes[i] = config.particleSize * (0.5 + Math.random() * 0.7);
                }
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                const particlesMaterial = new THREE.PointsMaterial({
                    size: config.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.88,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particleSystem);
                particles.push(particleSystem);
                document.getElementById('particleCountValue').textContent = config.particleCount.toLocaleString();
                // 彩色渐变行星环
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }
                const ringGeometry = new THREE.BufferGeometry();
                const ringPositions = new Float32Array(config.ringParticleCount * 3);
                const ringColors = new Float32Array(config.ringParticleCount * 3);
                const ringSizes = new Float32Array(config.ringParticleCount);
                for (let i = 0; i < config.ringParticleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = config.ringRadius + (Math.random() - 0.5) * config.ringWidth;
                    const height = (Math.random() - 0.5) * config.ringThickness;
                    ringPositions[i * 3] = distance * Math.cos(angle);
                    ringPositions[i * 3 + 1] = height;
                    ringPositions[i * 3 + 2] = distance * Math.sin(angle);
                    // 彩色渐变
                    const t = (angle / (2 * Math.PI));
                    const c = getColorfulGradient(t);
                    ringColors[i * 3] = c.r;
                    ringColors[i * 3 + 1] = c.g;
                    ringColors[i * 3 + 2] = c.b;
                    ringSizes[i] = config.particleSize * 1.2 * (0.5 + Math.random() * 0.7);
                }
                ringGeometry.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));
                ringGeometry.setAttribute('color', new THREE.BufferAttribute(ringColors, 3));
                ringGeometry.setAttribute('size', new THREE.BufferAttribute(ringSizes, 1));
                const ringMaterial = new THREE.PointsMaterial({
                    size: config.particleSize * 1.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: config.ringOpacity,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                ringParticles = new THREE.Points(ringGeometry, ringMaterial);
                ringTiltX = config.ringTilt;
                ringTiltZ = config.ringTilt * 0.5;
                ringParticles.rotation.x = ringTiltX;
                ringParticles.rotation.z = ringTiltZ;
                scene.add(ringParticles);
                // 环绕多色点光源
                const lightColors = [0xff6bcb, 0x6bffb8, 0xfff56b, 0x6b8bff, 0xff6b6b, 0x6bffd6, 0xffa36b, 0x6bfffa];
                lightColors.forEach((color, index) => {
                    const light = new THREE.PointLight(color, 1.5, 120);
                    const angle = (index / lightColors.length) * Math.PI * 2;
                    light.position.set(
                        Math.cos(angle) * 60,
                        Math.sin(angle) * 60,
                        Math.sin(index) * 30
                    );
                    scene.add(light);
                });
                // 环境光更亮
                scene.children.forEach(child => {
                    if (child instanceof THREE.AmbientLight) {
                        child.intensity = 1.0;
                    }
                });
                clearAndApplyBackground('clourfulPlantPreset');
            });

            document.getElementById('whiteHolePreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                // 白洞预设 - 创建震撼的白洞效果
                config.primaryColor = '#ffffff';    // 纯白色
                config.secondaryColor = '#00ffff';  // 青色
                config.particleSize = 0.05;         // 更小的粒子以创造更细腻的效果
                config.planetRadius = 0;            // 移除中心星球
                config.rotationSpeed = -2.8;        // 更快的反向旋转
                config.particleCount = 800000;      // 增加粒子数量
                config.ringParticleCount = 0;       // 不使用环系统
                config.ringWidth = 0;
                config.ringRadius = 0;
                config.ringRotationSpeed = 0;
                config.ringOpacity = 0;
                config.ringTilt = 0;
                config.ringThickness = 0;
                targetZoom = 65;                    // 调整视角以展示更多细节

                // 深邃的宇宙背景
                scene.background = new THREE.Color(0x000022); // 更深邃的蓝色背景
                document.getElementById('bgColorPicker').value = '#000022';

                // 更新UI并重建粒子系统
                updateUIFromConfig();

                // 清除现有的粒子系统和环系统
                particles.forEach(particle => scene.remove(particle));
                particles = [];
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                // 创建白洞粒子系统
                const whiteHoleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.particleCount * 3);
                const colors = new Float32Array(config.particleCount * 3);
                const sizes = new Float32Array(config.particleCount);

                // 增强的白洞参数
                const coreRadius = 10;              // 增大核心半径
                const ejectionRadius = 50;          // 增大喷射半径
                const spiralFactor = 12;            // 增加螺旋效果
                const densityFactor = 2.5;          // 提高密度
                const energyWaveCount = 5;          // 能量波数量

                // 扩展的白洞喷射物质颜色
                const ejectionColors = [
                    { r: 1.0, g: 1.0, b: 1.0 },    // 纯白色
                    { r: 0.95, g: 1.0, b: 1.0 },   // 冰蓝白色
                    { r: 1.0, g: 0.98, b: 0.95 },  // 暖白色
                    { r: 0.95, g: 0.95, b: 1.0 },  // 淡紫白色
                    { r: 1.0, g: 1.0, b: 0.95 },   // 淡金白色
                    { r: 0.9, g: 0.98, b: 1.0 },   // 天蓝白色
                    { r: 1.0, g: 0.95, b: 0.98 },  // 粉白色
                    { r: 0.98, g: 1.0, b: 0.98 },  // 翡翠白色
                    { r: 1.0, g: 0.95, b: 0.9 },   // 琥珀白色
                    { r: 0.9, g: 1.0, b: 0.95 }    // 薄荷白色
                ];

                // 能量波颜色
                const waveColors = [
                    { r: 1.0, g: 0.8, b: 0.4 },    // 金色
                    { r: 0.4, g: 0.8, b: 1.0 },    // 蓝色
                    { r: 1.0, g: 0.4, b: 0.8 },    // 紫色
                    { r: 0.8, g: 1.0, b: 0.4 },    // 青色
                    { r: 1.0, g: 0.6, b: 0.2 }     // 橙色
                ];

                // 生成白洞粒子
                for (let i = 0; i < config.particleCount; i++) {
                    const i3 = i * 3;

                    // 决定粒子类型
                    const particleType = Math.random();
                    let radius, angle, colorIndex;

                    if (particleType < 0.35) {
                        // 主要喷射物质
                        const ejectionType = Math.random();
                        if (ejectionType < 0.6) {
                            // 主要喷射区域
                            radius = coreRadius + Math.pow(Math.random(), 0.4) * (ejectionRadius - coreRadius);
                            angle = Math.random() * Math.PI * 2;
                        } else {
                            // 增强的螺旋结构
                            const spiralOffset = Math.random() * 0.8;
                            radius = coreRadius + Math.pow(Math.random(), 0.6) * (ejectionRadius - coreRadius);
                            angle = (radius / ejectionRadius) * spiralFactor + spiralOffset;
                        }
                        colorIndex = Math.floor(Math.random() * ejectionColors.length);
                    } else if (particleType < 0.6) {
                        // 能量波动效果
                        const waveIndex = Math.floor(Math.random() * energyWaveCount);
                        const wavePhase = (waveIndex / energyWaveCount) * Math.PI * 2;
                        radius = coreRadius + Math.random() * (ejectionRadius * 1.2 - coreRadius);
                        angle = Math.random() * Math.PI * 2 + Math.sin(wavePhase) * 0.5;
                        colorIndex = Math.floor(Math.random() * waveColors.length);
                    } else if (particleType < 0.8) {
                        // 外围光晕和能量场
                        radius = ejectionRadius + Math.random() * 100;
                        angle = Math.random() * Math.PI * 2;
                        const pulsePhase = Math.sin(radius / 20) * 0.5 + 0.5;
                        colorIndex = Math.floor(pulsePhase * ejectionColors.length);
                    } else if (particleType < 0.9) {
                        // 核心区域 - 强烈的能量中心
                        radius = coreRadius * (0.1 + Math.random() * 0.5);
                        angle = Math.random() * Math.PI * 2;
                        colorIndex = 0; // 使用纯白色
                    } else {
                        // 高速喷射物质流
                        radius = coreRadius + Math.pow(Math.random(), 0.25) * (ejectionRadius * 1.8 - coreRadius);
                        angle = Math.random() * Math.PI * 2;
                        colorIndex = Math.floor(Math.random() * ejectionColors.length);
                    }

                    // 添加动态随机性
                    const timeOffset = Math.random() * Math.PI * 2;
                    radius += Math.sin(timeOffset) * 2;
                    angle += Math.cos(timeOffset) * 0.1;

                    // 计算位置
                    const heightFactor = Math.pow(radius / ejectionRadius, 1.3); // 增强垂直扩散
                    const verticalOffset = Math.sin(angle * 3) * heightFactor * 2; // 添加波浪效果
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = (Math.random() - 0.5) * heightFactor * 20 + verticalOffset; // 增强垂直方向的扩散
                    positions[i3 + 2] = Math.sin(angle) * radius;

                    // 设置颜色和亮度
                    const distanceFromCenter = Math.sqrt(positions[i3] * positions[i3] + positions[i3 + 2] * positions[i3 + 2]);
                    const colorRatio = distanceFromCenter / ejectionRadius;

                    if (particleType < 0.35) {
                        // 主要喷射物质颜色
                        const ejectionColor = ejectionColors[colorIndex];
                        const brightness = 0.85 + (1 - colorRatio) * 0.25;
                        colors[i3] = ejectionColor.r * brightness;
                        colors[i3 + 1] = ejectionColor.g * brightness;
                        colors[i3 + 2] = ejectionColor.b * brightness;

                        // 增强发光效果
                        if (Math.random() < 0.2) {
                            const glowIntensity = 1.3 + Math.random() * 0.2;
                            colors[i3] = Math.min(1, colors[i3] * glowIntensity);
                            colors[i3 + 1] = Math.min(1, colors[i3 + 1] * glowIntensity);
                            colors[i3 + 2] = Math.min(1, colors[i3 + 2] * glowIntensity);
                        }
                    } else if (particleType < 0.6) {
                        // 能量波动颜色
                        const waveColor = waveColors[colorIndex];
                        const waveBrightness = 0.7 + Math.sin(distanceFromCenter / 5) * 0.3;
                        colors[i3] = waveColor.r * waveBrightness;
                        colors[i3 + 1] = waveColor.g * waveBrightness;
                        colors[i3 + 2] = waveColor.b * waveBrightness;
                    } else if (particleType < 0.8) {
                        // 外围光晕颜色
                        const haloColor = ejectionColors[colorIndex];
                        const haloBrightness = 0.4 + Math.random() * 0.3;
                        colors[i3] = haloColor.r * haloBrightness;
                        colors[i3 + 1] = haloColor.g * haloBrightness;
                        colors[i3 + 2] = haloColor.b * haloBrightness;
                    } else if (particleType < 0.9) {
                        // 核心区域颜色 - 炫目的白色
                        const coreBrightness = 0.95 + Math.random() * 0.05;
                        colors[i3] = coreBrightness;
                        colors[i3 + 1] = coreBrightness;
                        colors[i3 + 2] = coreBrightness;
                    } else {
                        // 高速喷射物质颜色
                        const streamColor = ejectionColors[colorIndex];
                        const streamBrightness = 0.75 + Math.random() * 0.35;
                        colors[i3] = streamColor.r * streamBrightness;
                        colors[i3 + 1] = streamColor.g * streamBrightness;
                        colors[i3 + 2] = streamColor.b * streamBrightness;
                    }

                    // 设置粒子大小
                    if (particleType < 0.35) {
                        // 主要喷射物质大小
                        sizes[i] = 0.09 * (1 - colorRatio * 0.25);
                    } else if (particleType < 0.6) {
                        // 能量波动粒子大小
                        sizes[i] = 0.07 + Math.random() * 0.05;
                    } else if (particleType < 0.8) {
                        // 外围光晕大小
                        sizes[i] = 0.04 + Math.random() * 0.03;
                    } else if (particleType < 0.9) {
                        // 核心区域粒子大小
                        sizes[i] = 0.15 + Math.random() * 0.1;
                    } else {
                        // 高速喷射物质大小
                        sizes[i] = 0.12 + Math.random() * 0.08;
                    }

                    // 添加距离衰减效果
                    sizes[i] *= Math.max(0.4, 1 - colorRatio * 0.3);
                }

                whiteHoleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                whiteHoleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                whiteHoleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const whiteHoleMaterial = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.92,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false // 改善透明度效果
                });

                const whiteHole = new THREE.Points(whiteHoleGeometry, whiteHoleMaterial);
                scene.add(whiteHole);
                particles.push(whiteHole);

                // 增强光照效果
                const lightColors = [
                    '#ffffff', // 纯白光
                    '#e6f3ff', // 冰蓝光
                    '#fff0f5', // 粉白光
                    '#f0ffff', // 天青光
                    '#fffafa', // 雪白光
                    '#f8f8ff', // 幽灵白光
                    '#fdf5e6', // 老白光
                    '#f0fff0'  // 蜜白光
                ];

                // 创建多层次的点光源
                lightColors.forEach((color, index) => {
                    // 内层光源
                    const innerLight = new THREE.PointLight(color, 2.0, 150);
                    const innerAngle = (index / lightColors.length) * Math.PI * 2;
                    innerLight.position.set(
                        Math.cos(innerAngle) * 30,
                        Math.sin(index) * 20,
                        Math.sin(innerAngle) * 30
                    );
                    scene.add(innerLight);

                    // 外层光源
                    const outerLight = new THREE.PointLight(color, 1.5, 200);
                    const outerAngle = ((index + 0.5) / lightColors.length) * Math.PI * 2;
                    outerLight.position.set(
                        Math.cos(outerAngle) * 50,
                        Math.sin(index + 2) * 30,
                        Math.sin(outerAngle) * 50
                    );
                    scene.add(outerLight);
                });

                // 添加环境光以增强整体亮度
                scene.children.forEach(child => {
                    if (child instanceof THREE.AmbientLight) {
                        child.intensity = 0.6;
                    }
                });

                // 应用背景
                clearAndApplyBackground('whiteHolePreset');
            });

            document.getElementById('nebulaPreset').addEventListener('click', () => {
                clearScene();
                document.getElementById('customSettings').style.display = 'none';
                // 螺旋星云预设 - 创建震撼的螺旋星云效果
                config.primaryColor = '#00ffff';    // 冰蓝色核心
                config.secondaryColor = '#ff4500'  // 橙色尾部
                config.particleSize = 0.05;         // 更细腻的粒子效果
                config.planetRadius = 0;            // 移除中心行星
                config.rotationSpeed = 1.8;         // 更快的旋转速度
                config.particleCount = 3000000;     // 显著增加粒子数量
                config.ringParticleCount = 0;       // 移除环系统
                config.ringWidth = 0;
                config.ringRadius = 0;
                config.ringRotationSpeed = 0;
                config.ringOpacity = 0;
                config.ringTilt = 0;
                config.ringThickness = 0;
                targetZoom = 200;                   // 更远的视角以展示完整螺旋星云

                // 深邃的宇宙背景
                scene.background = new THREE.Color(0x000015);
                document.getElementById('bgColorPicker').value = '#000015';

                // 更新UI并重建粒子系统
                updateUIFromConfig();

                // 清除现有粒子系统
                particles.forEach(particle => scene.remove(particle));
                particles = [];
                if (ringParticles) {
                    scene.remove(ringParticles);
                    ringParticles = null;
                }

                // 创建螺旋星云核心粒子系统
                const cometGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.particleCount * 3);
                const colors = new Float32Array(config.particleCount * 3);
                const sizes = new Float32Array(config.particleCount);

                // 创建增强的螺旋星云形状
                for (let i = 0; i < config.particleCount; i++) {
                    const i3 = i * 3;

                    // 使用改进的分布算法创造更自然的螺旋星云形状
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.pow(Math.random(), 0.15); // 使用更强的幂函数创造超密集核心，更平滑的过渡

                    // 计算基础位置
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi);

                    // 增强尾迹效果，更平滑的过渡
                    const stretch = 6.0 + Math.random() * 5; // 更长的尾迹
                    z *= stretch;

                    // 增强螺旋效果，更流畅的旋转
                    const spiral = Math.sin(z * 3 + theta) * 0.5 + Math.cos(z * 2) * 0.3;
                    x += spiral * Math.cos(theta);
                    y += spiral * Math.sin(theta);

                    // 添加波浪效果使粒子运动更加自然
                    const wave = Math.sin(z * 2 + theta * 3) * 0.2;
                    x += wave * Math.sin(theta);
                    y += wave * Math.cos(theta);

                    // 添加复杂的湍流效果，更平滑的流动
                    const turbulence = Math.sin(z * 4) * 0.2 + Math.cos(z * 2) * 0.15 + Math.sin(theta * 5) * 0.1;
                    const turbScale = Math.max(0.2, 1 - Math.abs(z) / 100); // 根据距离调整湍流强度
                    x += turbulence * Math.cos(theta * 2) * turbScale;
                    y += turbulence * Math.sin(theta * 2) * turbScale;

                    positions[i3] = x * 80;     // 更大的尺寸
                    positions[i3 + 1] = y * 80;
                    positions[i3 + 2] = z * 80;

                    // 创建超级丰富的渐变色彩系统
                    const distFromCenter = Math.sqrt(x * x + y * y + z * z);
                    const t = Math.max(0, Math.min(1, distFromCenter / 3));

                    // 增强的多层次颜色渐变系统
                    const coreColor = new THREE.Color('#00ffff');      // 冰蓝色核心
                    const coreColor2 = new THREE.Color('#87CEEB');     // 天蓝色核心层
                    const midColor1 = new THREE.Color('#40E0D0');      // 绿松石色过渡
                    const midColor2 = new THREE.Color('#00CED1');      // 深青色过渡
                    const midColor3 = new THREE.Color('#4169E1');      // 皇家蓝过渡
                    const midColor4 = new THREE.Color('#1E90FF');      // 道奇蓝过渡

                    // 尾部丰富的色彩系统
                    const tailColors = [
                        new THREE.Color('#FF6B6B'),    // 珊瑚红
                        new THREE.Color('#FF7F50'),    // 珊瑚色
                        new THREE.Color('#FFA07A'),    // 浅鲑鱼色
                        new THREE.Color('#FF8C00'),    // 深橙色
                        new THREE.Color('#FFD700'),    // 金色
                        new THREE.Color('#FFA500'),    // 橙色
                        new THREE.Color('#FF4500'),    // 橙红色
                        new THREE.Color('#FF6347')     // 番茄色
                    ];

                    let color;
                    if (t < 0.15) {
                        // 核心区域 - 冰蓝色渐变
                        color = new THREE.Color().lerpColors(coreColor, coreColor2, t * 6.67);
                    } else if (t < 0.25) {
                        // 第一过渡区 - 天蓝到绿松石
                        color = new THREE.Color().lerpColors(coreColor2, midColor1, (t - 0.15) * 10);
                    } else if (t < 0.35) {
                        // 第二过渡区 - 绿松石到深青
                        color = new THREE.Color().lerpColors(midColor1, midColor2, (t - 0.25) * 10);
                    } else if (t < 0.45) {
                        // 第三过渡区 - 深青到皇家蓝
                        color = new THREE.Color().lerpColors(midColor2, midColor3, (t - 0.35) * 10);
                    } else if (t < 0.55) {
                        // 第四过渡区 - 皇家蓝到道奇蓝
                        color = new THREE.Color().lerpColors(midColor3, midColor4, (t - 0.45) * 10);
                    } else {
                        // 尾部区域 - 多彩渐变
                        const tailSection = Math.floor((t - 0.55) * 8 / 0.45); // 将剩余0.45分成8段
                        const localT = ((t - 0.55) * 8 / 0.45) % 1;
                        const tailIndex = Math.min(tailSection, tailColors.length - 2);
                        color = new THREE.Color().lerpColors(
                            tailColors[tailIndex],
                            tailColors[tailIndex + 1],
                            localT
                        );
                    }

                    // 增强闪烁效果
                    const flicker = Math.random() * 0.4 + 0.8;
                    color.multiplyScalar(flicker);

                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;

                    // 增强的粒子大小变化
                    const sizeVariation = Math.sin(distFromCenter * 5) * 0.4;
                    const coreBrightness = Math.max(0, 1 - distFromCenter * 2);
                    sizes[i] = (1 - t) * 0.3 + 0.08 + sizeVariation + coreBrightness * 0.25;
                }

                cometGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                cometGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                cometGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                // 创建增强的螺旋星云材质
                const cometMaterial = new THREE.PointsMaterial({
                    size: config.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.95,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false
                });

                // 创建螺旋星云粒子系统
                const cometParticles = new THREE.Points(cometGeometry, cometMaterial);
                scene.add(cometParticles);
                particles.push(cometParticles);

                // 增强发光效果
                const cometLight = new THREE.PointLight(0x00ffff, 4, 200);
                cometLight.position.set(0, 0, 0);
                scene.add(cometLight);

                // 增强尾迹光效
                const tailLight = new THREE.PointLight(0x4169E1, 2.5, 250);
                tailLight.position.set(0, 0, -80);
                scene.add(tailLight);

                // 添加环境光晕
                const ambientLight = new THREE.AmbientLight(0x001133, 1.2);
                scene.add(ambientLight);

                // 添加星云效果
                const nebulaGeometry = new THREE.BufferGeometry();
                const nebulaPositions = new Float32Array(150000 * 3);
                const nebulaColors = new Float32Array(150000 * 3);

                for (let i = 0; i < 150000; i++) {
                    const i3 = i * 3;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 150 + Math.random() * 150;
                    const height = (Math.random() - 0.5) * 300;

                    nebulaPositions[i3] = Math.cos(angle) * radius;
                    nebulaPositions[i3 + 1] = Math.sin(angle) * radius;
                    nebulaPositions[i3 + 2] = height;

                    // 创建深蓝色调的星云
                    const nebulaColor = new THREE.Color(0x000040);
                    const brightness = Math.random() * 0.5 + 0.5;
                    nebulaColor.multiplyScalar(brightness);

                    nebulaColors[i3] = nebulaColor.r;
                    nebulaColors[i3 + 1] = nebulaColor.g;
                    nebulaColors[i3 + 2] = nebulaColor.b;
                }

                nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
                nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));

                const nebulaMaterial = new THREE.PointsMaterial({
                    size: 0.8,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });

                const nebulaParticles = new THREE.Points(nebulaGeometry, nebulaMaterial);
                scene.add(nebulaParticles);
                particles.push(nebulaParticles);

                // 增强多层发光效果系统
                // 核心区域的多层光源
                const coreLightPrimary = new THREE.PointLight(0x00ffff, 6, 180);  // 主核心光源
                coreLightPrimary.position.set(0, 0, 0);
                scene.add(coreLightPrimary);

                const coreLightSecondary = new THREE.PointLight(0x87CEEB, 4, 150);  // 次核心光源
                coreLightSecondary.position.set(0, 0, -20);
                scene.add(coreLightSecondary);

                // 中部过渡区域的光源
                const midLightCyan = new THREE.PointLight(0x40E0D0, 3.5, 200);  // 青色光源
                midLightCyan.position.set(0, 0, -40);
                scene.add(midLightCyan);

                const midLightBlue = new THREE.PointLight(0x4169E1, 3, 220);  // 蓝色光源
                midLightBlue.position.set(0, 0, -60);
                scene.add(midLightBlue);

                // 尾部多彩光源系统
                const tailLightWarm = new THREE.PointLight(0xff6b6b, 2.8, 280);  // 暖色调光源
                tailLightWarm.position.set(0, 0, -100);
                scene.add(tailLightWarm);

                const tailLightGold = new THREE.PointLight(0xffd700, 2.5, 300);  // 金色光源
                tailLightGold.position.set(0, 0, -140);
                scene.add(tailLightGold);

                const tailLightOrange = new THREE.PointLight(0xff4500, 2.2, 320);  // 橙色光源
                tailLightOrange.position.set(0, 0, -180);
                scene.add(tailLightOrange);

                // 环境光晕 - 更柔和的基础照明
                const cometAmbientLight = new THREE.AmbientLight(0x001133, 1.4);
                scene.add(cometAmbientLight);

                clearAndApplyBackground('nebulaPreset');
            });
        }

        // 中键长按跳转
        let middleMouseDownTimer = null;
        window.addEventListener('mousedown', function (event) {
            if (event.button === 1) { // 1 表示鼠标中键
                middleMouseDownTimer = setTimeout(function () {
                    window.location.href = './wandering-earth.html';
                }, 1000); // 1秒
            }
        });

        window.addEventListener('mouseup', function (event) {
            if (event.button === 1) { // 1 表示鼠标中键
                if (middleMouseDownTimer) {
                    clearTimeout(middleMouseDownTimer);
                    middleMouseDownTimer = null;
                }
            }
        });

        // 防止中键点击时出现上下文菜单
        window.addEventListener('contextmenu', function (event) {
            if (event.button === 1) {
                event.preventDefault();
            }
        });

        function createStarflowCanvas() {
            const textSpan = document.querySelector('.starflow-effect-text');
            const canvas = textSpan.nextElementSibling;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let width, height, particles = [];

            function resize() {
                width = textSpan.offsetWidth;
                height = textSpan.offsetHeight;
                canvas.width = width;
                canvas.height = height;
            }

            function randomStar() {
                return {
                    x: Math.random() * width,
                    y: Math.random() * height,
                    r: Math.random() * 1.2 + 0.5,
                    alpha: Math.random() * 0.5 + 0.5,
                    speed: Math.random() * 0.5 + 0.2,
                    dx: Math.random() * 0.5 - 0.25,
                    dy: Math.random() * 0.2 - 0.1
                };
            }

            function draw() {
                ctx.clearRect(0, 0, width, height);
                for (let p of particles) {
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(0.5, '#4facfe');
                    grad.addColorStop(1, 'rgba(0,242,254,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
            }

            function update() {
                for (let p of particles) {
                    p.x += p.dx * p.speed;
                    p.y += p.dy * p.speed;
                    p.alpha -= 0.003 + Math.random() * 0.002;
                    if (p.alpha <= 0.1 || p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
                        Object.assign(p, randomStar());
                        p.y = Math.random() * height * 0.5 + height * 0.25;
                    }
                }
            }

            function animate() {
                update();
                draw();
                if (canvas._active) requestAnimationFrame(animate);
            }

            function start() {
                resize();
                particles = Array.from({ length: Math.max(18, Math.floor(width / 10)) }, randomStar);
                canvas._active = true;
                animate();
            }
            function stop() {
                canvas._active = false;
                ctx.clearRect(0, 0, width, height);
            }

            window.addEventListener('resize', resize);

            // 悬停触发
            textSpan.parentElement.parentElement.addEventListener('mouseenter', () => {
                start();
                canvas.style.opacity = 1;
            });
            textSpan.parentElement.parentElement.addEventListener('mouseleave', () => {
                stop();
                canvas.style.opacity = 0;
            });
            // 初始化
            resize();
            stop();
        }
        document.addEventListener('DOMContentLoaded', createStarflowCanvas);

        // 五彩粒子爆发动画
        function createColorfulBurst() {
            const textSpan = document.querySelector('.starflow-effect-text');
            if (!textSpan) return; // 安全检查

            // 创建或复用canvas
            let burstCanvas = document.getElementById('colorful-burst-canvas');
            if (!burstCanvas) {
                burstCanvas = document.createElement('canvas');
                burstCanvas.id = 'colorful-burst-canvas';
                burstCanvas.style.position = 'absolute';
                burstCanvas.style.left = '-250%';
                burstCanvas.style.top = '-250%';
                burstCanvas.style.width = '600%';
                burstCanvas.style.height = '600%';
                burstCanvas.style.pointerEvents = 'none';
                burstCanvas.style.zIndex = 10;
                burstCanvas.style.opacity = 0;
                textSpan.appendChild(burstCanvas);
            }
            let width = textSpan.offsetWidth * 6;
            let height = textSpan.offsetHeight * 6;
            burstCanvas.width = width;
            burstCanvas.height = height;

            let particles = [];
            let animating = false;

            function randomColor() {
                // 彩虹色
                const colors = [
                    '#ff0000', '#ff9900', '#ffee00', '#33ff00', '#00eaff', '#0055ff', '#cc00ff', '#fff'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            function burst() {
                particles = [];
                const cx = width / 2;
                const cy = height / 2;
                for (let i = 0; i < 1200; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3.2 + Math.random() * 7.5;
                    particles.push({
                        x: cx,
                        y: cy,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: 0.3 + Math.random() * 0.4,
                        color: randomColor(),
                        alpha: 1,
                        life: 0,
                        maxLife: 44 + Math.random() * 24
                    });
                }
                burstCanvas.style.opacity = 1;
                if (!animating) {
                    animating = true;
                    animate();
                }
            }

            function animate() {
                const ctx = burstCanvas.getContext('2d');
                ctx.clearRect(0, 0, width, height);
                let alive = false;
                for (let p of particles) {
                    if (p.alpha > 0.05 && p.life < p.maxLife) {
                        alive = true;
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.055; // 重力
                        p.life++;
                        p.alpha *= 0.982;
                        ctx.save();
                        ctx.globalAlpha = p.alpha;
                        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
                        grad.addColorStop(0, '#fff');
                        grad.addColorStop(0.3, p.color);
                        grad.addColorStop(1, 'rgba(255,255,255,0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                if (alive) {
                    requestAnimationFrame(animate);
                } else {
                    burstCanvas.style.opacity = 0;
                    animating = false;
                }
            }

            // 悬停触发 - 确保在所有预设下都有效
            if (textSpan.parentElement && textSpan.parentElement.parentElement) {
                // 移除可能存在的旧事件监听器
                textSpan.parentElement.parentElement.removeEventListener('mouseenter', burst);
                // 添加新的事件监听器
                textSpan.parentElement.parentElement.addEventListener('mouseenter', burst);
            }

            // 窗口/字体大小变化时自适应
            window.addEventListener('resize', () => {
                if (textSpan) {
                    width = textSpan.offsetWidth * 6;
                    height = textSpan.offsetHeight * 6;
                    if (burstCanvas) {
                        burstCanvas.width = width;
                        burstCanvas.height = height;
                    }
                }
            });

            // 导出burst函数以便其他地方调用
            return burst;
        }
        document.addEventListener('DOMContentLoaded', createColorfulBurst);

        // ====== 自定义参数UI星光星尘canvas动态 ======
        const customStarsBg = document.getElementById('customStarsBg');
        let starsCtx, stars, animId;

        // 控制面板最小化功能
        function setupControlPanelMinimize() {
            const controlPanel = document.getElementById('controlPanel');
            const controlMinimize = document.getElementById('controlMinimize');
            const controlMiniIcon = document.getElementById('controlMiniIcon');

            if (!controlPanel || !controlMinimize || !controlMiniIcon) return;

            // 最小化按钮点击事件
            controlMinimize.addEventListener('click', () => {
                controlPanel.style.display = 'none';
                controlMiniIcon.style.display = 'flex';
            });

            // 迷你图标点击事件
            controlMiniIcon.addEventListener('click', () => {
                controlMiniIcon.style.display = 'none';
                controlPanel.style.display = 'block';
            });
        }

        document.addEventListener('DOMContentLoaded', setupControlPanelMinimize);

        function resizeStarsCanvas() {
            if (!customStarsBg) return;
            customStarsBg.width = customStarsBg.offsetWidth;
            customStarsBg.height = customStarsBg.offsetHeight;
        }
        function createStars() {
            stars = [];
            const w = customStarsBg.width, h = customStarsBg.height;
            for (let i = 0; i < 80; i++) {
                stars.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    r: Math.random() * 1.2 + 0.5,
                    o: Math.random() * 0.5 + 0.5,
                    s: Math.random() * 0.6 + 0.2,
                    t: Math.random() * 360
                });
            }
        }
        function drawStars() {
            if (!customStarsBg) return;
            starsCtx = customStarsBg.getContext('2d');
            starsCtx.clearRect(0, 0, customStarsBg.width, customStarsBg.height);
            for (const star of stars) {
                // 跳过左下角80x80像素区域的星星
                if (star.x < 80 && star.y > customStarsBg.height - 80) continue;
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 800 + star.t);
                starsCtx.save();
                starsCtx.globalAlpha = star.o * pulse;
                const grad = starsCtx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.r * 2.2);
                grad.addColorStop(0, '#e0f7ff');
                grad.addColorStop(0.5, '#4facfe');
                grad.addColorStop(1, 'rgba(0,242,254,0.05)');
                starsCtx.beginPath();
                starsCtx.arc(star.x, star.y, star.r * pulse, 0, 2 * Math.PI);
                starsCtx.fillStyle = grad;
                starsCtx.shadowColor = '#b6eaff';
                starsCtx.shadowBlur = 8;
                starsCtx.fill();
                starsCtx.restore();
            }
        }
        function animateStars() {
            drawStars();
            animId = requestAnimationFrame(animateStars);
        }
        function showCustomStarsBg() {
            if (!customStarsBg) return;
            resizeStarsCanvas();
            createStars();
            animateStars();
            window.addEventListener('resize', resizeStarsCanvas);
        }
        function hideCustomStarsBg() {
            if (animId) cancelAnimationFrame(animId);
            if (customStarsBg) {
                const ctx = customStarsBg.getContext('2d');
                ctx.clearRect(0, 0, customStarsBg.width, customStarsBg.height);
            }
            window.removeEventListener('resize', resizeStarsCanvas);
        }
        // 监听自定义参数UI显示/隐藏
        const customSettings = document.getElementById('customSettings');
        const observer = new MutationObserver(() => {
            if (customSettings.style.display === 'block') {
                showCustomStarsBg();
            } else {
                hideCustomStarsBg();
            }
        });
        observer.observe(customSettings, { attributes: true, attributeFilter: ['style'] });
    </script>


    <script>
        // 记录点击次数
        let _pageClickCount = 0;

        function forceVideoLoop(video) {
            if (!video) return;
            // 彻底移除loop属性后再加上
            video.removeAttribute('loop');
            video.setAttribute('loop', 'loop');
            // 多重保险：事件+定时器+属性
            function realLoop() {
                if (video.ended || video.paused || (video.duration - video.currentTime < 0.2)) {
                    video.currentTime = 0.01;
                    let p = video.play();
                    if (p && p.catch) p.catch(() => { setTimeout(() => { video.play(); }, 100); });
                }
            }
            video.addEventListener('ended', realLoop);
            video.addEventListener('timeupdate', function () {
                if (video.duration - video.currentTime < 0.05) {
                    video.currentTime = 0.01;
                    video.play();
                }
            });
            // 火狐file协议下再加一层保险
            var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            var isFileProtocol = window.location.protocol === 'file:';
            if (isFirefox && isFileProtocol) {
                if (!window._ffLoopInterval) {
                    window._ffLoopInterval = setInterval(realLoop, 200);
                }
            }
            // 其他浏览器也加保险
            if (!window._videoLoopInterval) {
                window._videoLoopInterval = setInterval(realLoop, 500);
            }
            // 属性保险
            video.setAttribute('autoplay', 'autoplay');
            video.autoplay = true;
            video.setAttribute('muted', 'muted');
            video.muted = true;
            video.setAttribute('playsinline', '');
            video.playsInline = true;
            video.controls = false;
            video.removeAttribute('controls');
            video.style.pointerEvents = 'auto';
            video.style.cursor = 'pointer';
            // 禁止右键菜单和拖拽
            video.addEventListener('contextmenu', function (e) { e.preventDefault(); });
            video.addEventListener('dragstart', function (e) { e.preventDefault(); });
            video.addEventListener('selectstart', function (e) { e.preventDefault(); });
        }







        function handlePageClick() {
            _pageClickCount++;
            if (_pageClickCount === 1) {
                // 第一次点击，只进入全屏，不关闭视频
                var elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
            } else if (_pageClickCount === 2) {
                // 第二次点击，退出视频，进入粒子页面
                var introVideo = document.getElementById('introVideo');
                var controlPanel = document.getElementById('controlPanel');
                var infoTitle = document.querySelector('.info-title-center');
                var loadingScreen = document.getElementById('loadingScreen');
                if (introVideo) {
                    // 隐藏视频和黑色背景（兼容嵌套div）
                    var videoParent = introVideo.parentElement;
                    videoParent.style.display = 'none';
                    if (videoParent.parentElement.classList.contains('loading-screen')) {
                        videoParent.parentElement.style.display = 'none';
                    }
                }
                // 显示控制面板和标题
                if (controlPanel) controlPanel.style.display = '';
                if (infoTitle) infoTitle.style.display = '';
                // 进入主页面（触发原有loadingScreen隐藏和initMainApp）
                if (typeof initMainApp === 'function') initMainApp();
                // 清除视频循环
                if (window._videoLoopInterval) {
                    clearInterval(window._videoLoopInterval);
                    window._videoLoopInterval = null;
                }
                if (window._ffLoopInterval) {
                    clearInterval(window._ffLoopInterval);
                    window._ffLoopInterval = null;
                }
                // 解绑点击事件，防止后续误触
                document.removeEventListener('click', handlePageClick);
            }
        }

        document.addEventListener('click', handlePageClick);
        window.addEventListener('DOMContentLoaded', function () {
            var introVideo = document.getElementById('introVideo');
            if (introVideo) {
                // 彻底移除所有mousedown监听
                introVideo.onmousedown = null;
                // 强制循环保险
                forceVideoLoop(introVideo);
            }
        });
    </script>


        <script>
        // === 自定义鼠标三层同步与 trail 逻辑 ===
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        function setCursorElementsCenter(x, y) {
            // custom-cursor
            const cursor = document.getElementById('custom-cursor');
            if (cursor) {
                cursor.style.left = `${x}px`;
                cursor.style.top = `${y}px`;
            }
            // 所有 trail
            document.querySelectorAll('.cursor-trail').forEach(trail => {
                trail.style.left = `${x}px`;
                trail.style.top = `${y}px`;
                trail.style.transform = 'translate(-50%, -50%)';
            });
        }
        function syncCursorCenters() {
            setCursorElementsCenter(mouseX, mouseY);
            requestAnimationFrame(syncCursorCenters);
        }
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            setCursorElementsCenter(mouseX, mouseY);
            const cursorTrails = document.getElementById('cursor-trails');
            if (cursorTrails) {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.position = 'fixed';
                trail.style.left = `${mouseX}px`;
                trail.style.top = `${mouseY}px`;
                trail.style.transform = 'translate(-50%, -50%)';
                cursorTrails.appendChild(trail);
                setTimeout(() => {
                    trail.style.opacity = '0';
                    setTimeout(() => {
                        if (trail.parentNode) trail.parentNode.removeChild(trail);
                    }, 300);
                }, 100);
            }
        });
        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouseX = e.clientX;
                mouseY = e.clientY;
                setCursorElementsCenter(mouseX, mouseY);
                const cursor = document.getElementById('custom-cursor');
                if (cursor) {
                    cursor.style.transform = 'translate(-50%, -50%) scale(0.8)';
                }
            }
        });
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                const cursor = document.getElementById('custom-cursor');
                if (cursor) {
                    cursor.style.transform = 'translate(-50%, -50%) scale(1)';
                }
            }
        });
        function initCustomCursor() {
            const cursor = document.getElementById('custom-cursor');
            document.querySelectorAll('button, a, input, select').forEach(el => {
                el.addEventListener('mouseenter', () => {
                    if (cursor) {
                        cursor.style.transform = 'translate(-50%, -50%) scale(1.5)';
                        const core = cursor.querySelector('.cursor-core');
                        if (core) core.style.backgroundColor = '#ff00aa';
                    }
                });
                el.addEventListener('mouseleave', () => {
                    if (cursor) {
                        cursor.style.transform = 'translate(-50%, -50%) scale(1)';
                        const core = cursor.querySelector('.cursor-core');
                        if (core) core.style.backgroundColor = '#00f7ff';
                    }
                });
            });
        }
        document.addEventListener('DOMContentLoaded', function () {
            requestAnimationFrame(syncCursorCenters);
            initCustomCursor();
        });







//鼠标中键彗星粒子跟随特效
        (function(){
    // 避免变量冲突，全部加_fp后缀
    const fp_canvas = document.getElementById('followParticles');
    const fp_ctx = fp_canvas.getContext('2d', { alpha: false });
    let fp_particles = [];
    let fp_particleCount = Math.min(
        Math.floor((window.innerWidth * window.innerHeight) / 5000),
        150
    );
    let fp_mouseX = window.innerWidth / 2;
    let fp_mouseY = window.innerHeight / 2;
    let fp_isEffectActive = false;
    let fp_animationId = null;
    const fp_colors = [
        '#00b4ff', '#0062ff', '#00ffea', '#7700ff',
        '#ff00aa', '#ff5100', '#a200ff', '#00a2ff'
    ];
    const fp_colorRGBA = fp_colors.map(color => {
        const r = parseInt(color.substr(1, 2), 16);
        const g = parseInt(color.substr(3, 2), 16);
        const b = parseInt(color.substr(5, 2), 16);
        return { r, g, b, str: color };
    });
    function fp_resizeCanvas() {
        const width = window.innerWidth | 0;
        const height = window.innerHeight | 0;
        if (fp_canvas.width !== width || fp_canvas.height !== height) {
            fp_canvas.width = width;
            fp_canvas.height = height;
        }
    }
    fp_resizeCanvas();
    window.addEventListener('resize', fp_resizeCanvas);
    // 粒子类
    class FP_Particle {
        constructor() {
            this.reset(true);
            this.z = Math.random() * 2 + 1;
            this.sparkleIntensity = Math.random() * 0.5 + 0.5;
        }
        reset(initial = false) {
            if (initial) {
                const edge = Math.floor(Math.random() * 4);
                const offset = Math.random() * 300 + 100;
                this.x = edge % 2 === 0 
                    ? Math.random() * fp_canvas.width 
                    : (edge === 1 ? fp_canvas.width + offset : -offset);
                this.y = edge % 2 === 1 
                    ? Math.random() * fp_canvas.height 
                    : (edge === 2 ? fp_canvas.height + offset : -offset);
            } else {
                this.x = fp_mouseX + (Math.random() * 100 - 50);
                this.y = fp_mouseY + (Math.random() * 100 - 50);
            }
            this.size = Math.random() * 3 + 1;
            this.colorData = fp_colorRGBA[Math.floor(Math.random() * fp_colorRGBA.length)];
            this.speedX = Math.random() * 4 - 2;
            this.speedY = Math.random() * 4 - 2;
            this.z = Math.random() * 2 + 1;
            this.opacity = initial ? 0 : Math.random() * 0.5;
            this.targetOpacity = Math.random() * 0.8 + 0.1;
            this.fadeSpeed = Math.random() * 0.02 + 0.01;
            this.angle = Math.random() * Math.PI * 2;
            this.angleSpeed = Math.random() * 0.02 - 0.01;
            this.orbitRadius = Math.random() * 100 + 30;
            this.life = 0;
            this.maxLife = Math.random() * 200 + 100;
            this.trail = [];
            this.maxTrailLength = Math.floor(Math.random() * 10) + 8;
            this.sparkleIntensity = Math.random() * 0.5 + 0.5;
            this.sparkleSpeed = Math.random() * 0.03 + 0.02;
            this.sparklePhase = Math.random() * Math.PI * 2;
            this.trailWidthVariation = Math.random() * 0.7 + 0.3;
            this.trailColorVariation = Math.random() * 0.2 + 0.8;
        }
        update() {
            this.life++;
            this.sparklePhase += this.sparkleSpeed;
            this.angle += this.angleSpeed;
            const cosAngle = Math.cos(this.angle);
            const sinAngle = Math.sin(this.angle);
            const targetX = fp_mouseX + cosAngle * this.orbitRadius;
            const targetY = fp_mouseY + sinAngle * this.orbitRadius;
            this.x += (targetX - this.x) * 0.012 * this.z;
            this.y += (targetY - this.y) * 0.012 * this.z;
            this.trail.push({
                x: this.x | 0, 
                y: this.y | 0,
                width: this.size * this.z * (0.5 + Math.sin(this.sparklePhase) * 0.5 * this.trailWidthVariation),
                opacity: this.opacity
            });
            if (this.trail.length > this.maxTrailLength) {
                this.trail = this.trail.slice(-this.maxTrailLength);
            }
            if (this.opacity < this.targetOpacity) {
                this.opacity += this.fadeSpeed;
            } else {
                this.opacity = this.targetOpacity;
            }
            if (this.life >= this.maxLife) {
                this.reset();
            }
        }
        draw() {
            const { r, g, b } = this.colorData;
            const sparkleFactor = 0.7 + Math.sin(this.sparklePhase) * 0.3 * this.sparkleIntensity;
            const currentOpacity = this.opacity * sparkleFactor;
            // 绘制轨迹
            fp_ctx.save();
            for (let i = 1; i < this.trail.length; i++) {
                const point1 = this.trail[i - 1];
                const point2 = this.trail[i];
                fp_ctx.strokeStyle = `rgba(${r},${g},${b},${point2.opacity * this.trailColorVariation})`;
                fp_ctx.lineWidth = point2.width;
                fp_ctx.beginPath();
                fp_ctx.moveTo(point1.x, point1.y);
                fp_ctx.lineTo(point2.x, point2.y);
                fp_ctx.stroke();
            }
            fp_ctx.restore();
            // 发光光晕
            const glowSize = this.size * this.z * 2.5 * sparkleFactor;
            const coreSize = this.size * this.z * 0.8;
            fp_ctx.save();
            fp_ctx.globalAlpha = currentOpacity * 0.7;
            const gradient = fp_ctx.createRadialGradient(
                this.x, this.y, 0,
                this.x, this.y, glowSize
            );
            gradient.addColorStop(0, this.colorData.str);
            gradient.addColorStop(1, 'transparent');
            fp_ctx.fillStyle = gradient;
            fp_ctx.beginPath();
            fp_ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
            fp_ctx.fill();
            // 粒子核心
            fp_ctx.globalAlpha = currentOpacity * 0.9;
            fp_ctx.fillStyle = this.colorData.str;
            fp_ctx.beginPath();
            fp_ctx.arc(this.x, this.y, coreSize, 0, Math.PI * 2);
            fp_ctx.fill();
            // 高光
            fp_ctx.globalAlpha = currentOpacity * 0.6;
            fp_ctx.fillStyle = 'rgba(255,255,255,0.8)';
            fp_ctx.beginPath();
            fp_ctx.arc(
                this.x - coreSize * 0.3,
                this.y - coreSize * 0.3,
                coreSize * 0.3,
                0, Math.PI * 2
            );
            fp_ctx.fill();
            fp_ctx.restore();
        }
    }
    function fp_initParticles() {
        fp_particles = new Array(fp_particleCount);
        for (let i = 0; i < fp_particleCount; i++) {
            fp_particles[i] = new FP_Particle();
            fp_particles[i].life = Math.random() * 50;
        }
    }
    function fp_animate() {
        if (!fp_isEffectActive) {
            fp_animationId = null;
            return;
        }
        fp_ctx.fillStyle = 'rgba(0,0,0,0.08)';
        fp_ctx.fillRect(0, 0, fp_canvas.width, fp_canvas.height);
        for (let i = 0; i < fp_particleCount; i++) {
            fp_particles[i].update();
            fp_particles[i].draw();
        }
        if (Math.random() < 0.2) {
            const x = Math.random() * fp_canvas.width;
            const y = Math.random() * fp_canvas.height;
            const size = Math.random() * 2 + 1;
            const colorData = fp_colorRGBA[Math.floor(Math.random() * fp_colorRGBA.length)];
            const opacity = Math.random() * 0.3 + 0.1;
            fp_ctx.save();
            fp_ctx.globalAlpha = opacity;
            const gradient = fp_ctx.createRadialGradient(
                x, y, 0,
                x, y, size * 4
            );
            gradient.addColorStop(0, colorData.str);
            gradient.addColorStop(1, 'transparent');
            fp_ctx.fillStyle = gradient;
            fp_ctx.beginPath();
            fp_ctx.arc(x, y, size * 4, 0, Math.PI * 2);
            fp_ctx.fill();
            fp_ctx.restore();
        }
        fp_animationId = requestAnimationFrame(fp_animate);
    }
    function fp_toggleEffect(x, y) {
        fp_isEffectActive = !fp_isEffectActive;
        if (fp_isEffectActive) {
            fp_canvas.style.display = 'block';
            fp_mouseX = x || window.innerWidth / 2;
            fp_mouseY = y || window.innerHeight / 2;
            fp_initParticles();
            if (!fp_animationId) {
                fp_animate();
            }
        } else {
            fp_canvas.style.display = 'none';
            fp_ctx.fillStyle = 'black';
            fp_ctx.fillRect(0, 0, fp_canvas.width, fp_canvas.height);
        }
    }
    // 只监听中键点击
    window.addEventListener('mousedown', function(e){
        if (e.button === 1) {
            e.preventDefault();
            fp_mouseX = e.clientX;
            fp_mouseY = e.clientY;
            fp_toggleEffect(fp_mouseX, fp_mouseY);
        }
    });
    // 鼠标移动时更新粒子中心
    window.addEventListener('mousemove', function(e){
        fp_mouseX = e.clientX;
        fp_mouseY = e.clientY;
    });
    // 页面不可见时暂停动画
    document.addEventListener('visibilitychange', function(){
        if (document.hidden) {
            if (fp_animationId) {
                cancelAnimationFrame(fp_animationId);
                fp_animationId = null;
            }
        } else if (fp_isEffectActive && !fp_animationId) {
            fp_animate();
        }
    });
})();   
   
   
   </script>

</body>

</html>

