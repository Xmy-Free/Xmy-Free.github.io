<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>transition-animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        body {
            background-color: #000;
            font-family: Arial, sans-serif;
            perspective: 1500px;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #universe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a0a2d 0%, #000 100%);
            overflow: hidden;
            transform-style: preserve-3d;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        #wormhole-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            z-index: 7;
            perspective: 2000px;
            perspective-origin: center center;
            transform-style: preserve-3d;
            overflow: hidden;
            pointer-events: none;
        }

        #wormhole {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(0);
            width: 20vmin;
            height: 20vmin;
            border-radius: 50%;
            background: transparent;
            transform-style: preserve-3d;
            z-index: 7;
            animation: expandWormhole 6s cubic-bezier(0.19, 1, 0.22, 1) forwards;
        }

        .wormhole-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotateX(75deg);
            border-radius: 50%;
            border: 3px solid transparent;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            animation: rotateRing 20s linear infinite;
            box-shadow: 0 0 30px 5px rgba(255, 255, 255, 0.15);
            background: transparent;
            backdrop-filter: blur(1px);
        }

        .wormhole-inner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            background: radial-gradient(circle at center,
                    rgba(255, 255, 255, 0.9) 0%,
                    rgba(255, 230, 180, 0.9) 2%,
                    rgba(255, 180, 100, 0.8) 5%,
                    rgba(240, 120, 80, 0.7) 10%,
                    rgba(200, 100, 250, 0.5) 20%,
                    rgba(100, 150, 255, 0.4) 40%,
                    rgba(50, 100, 230, 0.3) 60%,
                    rgba(30, 60, 180, 0.2) 80%,
                    rgba(20, 30, 120, 0) 100%);
            transform: translateZ(-20px);
            filter: blur(2px);
            animation: pulseWormhole 5s ease-in-out infinite alternate;
            box-shadow: inset 0 0 60px 10px rgba(255, 200, 100, 0.5);
        }

        .wormhole-core {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10%;
            height: 10%;
            border-radius: 50%;
            background: radial-gradient(circle at center,
                    rgba(255, 255, 255, 1) 0%,
                    rgba(255, 240, 200, 0.95) 20%,
                    rgba(255, 200, 100, 0.9) 40%,
                    rgba(255, 160, 60, 0.8) 60%,
                    rgba(255, 120, 50, 0.5) 80%,
                    rgba(255, 100, 50, 0) 100%);
            filter: blur(1px);
            box-shadow: 0 0 30px 15px rgba(255, 200, 100, 0.7);
            animation: pulseCore 3s ease-in-out infinite alternate;
            z-index: 20;
        }

        .wormhole-stream {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            animation: rotateStream 30s linear infinite;
        }

        .wormhole-stream-particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform-style: preserve-3d;
            filter: blur(1px);
        }

        .wormhole-vortex {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotateX(75deg) rotateY(0deg);
            width: 90%;
            height: 90%;
            transform-style: preserve-3d;
            z-index: 6;
            animation: rotateVortex 25s linear infinite;
        }

        .vortex-line {
            position: absolute;
            top: 50%;
            left: 50%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
            transform-origin: 0% 50%;
            transform: rotate(var(--rotation)) scaleX(1);
            opacity: 0.6;
            filter: blur(1px);
        }

        @keyframes expandWormhole {
            0% {
                width: 20vmin;
                height: 20vmin;
                transform: translate(-50%, -50%) translateZ(0);
            }

            30% {
                width: 35vmin;
                height: 35vmin;
                transform: translate(-50%, -50%) translateZ(0);
            }

            100% {
                width: 600vmin;
                height: 600vmin;
                transform: translate(-50%, -50%) translateZ(2000px);
            }
        }

        @keyframes rotateRing {
            0% {
                transform: translate(-50%, -50%) rotateX(75deg) rotateZ(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotateX(75deg) rotateZ(360deg);
            }
        }

        @keyframes rotateVortex {
            0% {
                transform: translate(-50%, -50%) rotateX(75deg) rotateY(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotateX(75deg) rotateY(-360deg);
            }
        }

        @keyframes rotateStream {
            0% {
                transform: rotateZ(0deg);
            }

            100% {
                transform: rotateZ(-360deg);
            }
        }

        @keyframes pulseWormhole {
            0% {
                opacity: 0.9;
                filter: blur(2px) brightness(1);
            }

            50% {
                opacity: 1;
                filter: blur(2.5px) brightness(1.2);
            }

            100% {
                opacity: 0.95;
                filter: blur(3px) brightness(1.15);
            }
        }

        @keyframes pulseCore {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.9;
                filter: blur(1px) brightness(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
                filter: blur(1.5px) brightness(1.5);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.95;
                filter: blur(1px) brightness(1.3);
            }
        }

        .cosmic-rays {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%);
            z-index: 8;
            pointer-events: none;
        }

        .cosmic-ray {
            position: absolute;
            top: 50%;
            left: 50%;
            height: 1px;
            background: linear-gradient(90deg,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.8) 50%,
                    rgba(255, 255, 255, 0) 100%);
            transform-origin: center;
            opacity: 0;
            z-index: 9;
        }

        .energy-burst {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 5vmin;
            height: 5vmin;
            border-radius: 50%;
            background: radial-gradient(circle at center,
                    rgba(255, 255, 255, 1) 0%,
                    rgba(255, 200, 100, 0.8) 20%,
                    rgba(255, 100, 100, 0.6) 40%,
                    rgba(200, 50, 200, 0.4) 60%,
                    rgba(100, 100, 255, 0.2) 80%,
                    rgba(50, 50, 200, 0) 100%);
            z-index: 8;
            filter: blur(2px);
            opacity: 0;
            animation: energyBurst 6s ease-in-out forwards;
        }

        @keyframes energyBurst {
            0% {
                opacity: 0;
                width: 2vmin;
                height: 2vmin;
                filter: blur(1px) brightness(1);
            }

            40% {
                opacity: 0.9;
                width: 15vmin;
                height: 15vmin;
                filter: blur(3px) brightness(1.5);
            }

            80% {
                opacity: 0.7;
                width: 10vmin;
                height: 10vmin;
                filter: blur(2px) brightness(1.2);
            }

            100% {
                opacity: 0;
                width: 2vmin;
                height: 2vmin;
                filter: blur(1px) brightness(1);
            }
        }

        #space-ripple {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center,
                    transparent 30%,
                    rgba(100, 150, 255, 0.1) 40%,
                    rgba(100, 150, 255, 0.05) 50%,
                    transparent 60%);
            border-radius: 50%;
            z-index: 6;
            opacity: 0;
            animation: spaceRipple 6s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes spaceRipple {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            50% {
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(1.2);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(2);
            }
        }

        #tunnel {
            display: none;
            /* Hide the old tunnel */
        }

        #stars {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            z-index: 1;
            perspective: 1000px;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: #fff;
            border-radius: 50%;
            opacity: 0.8;
            animation: twinkle 1s infinite alternate ease-in-out, starMove 6s ease-in forwards;
        }

        .spiral-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #fff;
            border-radius: 50%;
            transform-style: preserve-3d;
            opacity: 0;
            z-index: 5;
            box-shadow: 0 0 8px 2px rgba(255, 255, 255, 0.4);
        }

        .cosmic-dust {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            animation: rotateDust 20s linear infinite;
            z-index: 3;
        }

        .dust-particle {
            position: absolute;
            width: 1px;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            opacity: 0.6;
        }

        .nebula {
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background:
                radial-gradient(ellipse at 30% 40%, rgba(255, 100, 80, 0.3) 0%, rgba(255, 100, 80, 0) 70%),
                radial-gradient(ellipse at 70% 60%, rgba(70, 130, 230, 0.3) 0%, rgba(70, 130, 230, 0) 70%),
                radial-gradient(ellipse at 45% 45%, rgba(180, 130, 230, 0.2) 0%, rgba(180, 130, 230, 0) 70%);
            opacity: 0.6;
            animation: rotateNebula 60s linear infinite, nebulaTransition 6s ease-in forwards;
            z-index: 2;
            pointer-events: none;
        }

        .glow-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 5vmin;
            height: 5vmin;
            border-radius: 50%;
            border: 2px solid rgba(255, 170, 100, 0.5);
            box-shadow: 0 0 15px 5px rgba(255, 170, 100, 0.3);
            opacity: 0;
            z-index: 9;
            animation: colorTransitionRing 6s ease-in forwards;
        }

        #travel-text {
            position: absolute;
            font-family: 'Arial', sans-serif;
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            width: 100%;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            opacity: 0;
            z-index: 20;
            animation: showTravelText 6s ease forwards;
            pointer-events: none;
        }

        @keyframes twinkle {
            0% {
                opacity: 0.4;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes starMove {
            0% {
                transform: translateZ(-1000px);
            }

            100% {
                transform: translateZ(500px);
            }
        }

        @keyframes rotateDust {
            0% {
                transform: rotateZ(0deg);
            }

            100% {
                transform: rotateZ(360deg);
            }
        }

        @keyframes rotateNebula {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes nebulaTransition {
            0% {
                background:
                    radial-gradient(ellipse at 30% 40%, rgba(255, 100, 80, 0.4) 0%, rgba(255, 100, 80, 0) 70%),
                    radial-gradient(ellipse at 70% 60%, rgba(255, 170, 50, 0.3) 0%, rgba(255, 170, 50, 0) 70%),
                    radial-gradient(ellipse at 45% 45%, rgba(255, 140, 0, 0.2) 0%, rgba(255, 140, 0, 0) 70%);
            }

            50% {
                background:
                    radial-gradient(ellipse at 30% 40%, rgba(255, 100, 80, 0.2) 0%, rgba(255, 100, 80, 0) 70%),
                    radial-gradient(ellipse at 70% 60%, rgba(180, 130, 230, 0.3) 0%, rgba(180, 130, 230, 0) 70%),
                    radial-gradient(ellipse at 45% 45%, rgba(100, 150, 255, 0.2) 0%, rgba(100, 150, 255, 0) 70%);
            }

            100% {
                background:
                    radial-gradient(ellipse at 30% 40%, rgba(100, 150, 255, 0.3) 0%, rgba(100, 150, 255, 0) 70%),
                    radial-gradient(ellipse at 70% 60%, rgba(70, 130, 230, 0.3) 0%, rgba(70, 130, 230, 0) 70%),
                    radial-gradient(ellipse at 45% 45%, rgba(135, 206, 250, 0.2) 0%, rgba(135, 206, 250, 0) 70%);
            }
        }

        @keyframes colorTransitionRing {
            0% {
                border: 2px solid rgba(255, 170, 100, 0.5);
                box-shadow: 0 0 15px 5px rgba(255, 170, 100, 0.3);
            }

            50% {
                border: 2px solid rgba(180, 130, 230, 0.5);
                box-shadow: 0 0 15px 5px rgba(180, 130, 230, 0.3);
            }

            100% {
                border: 2px solid rgba(70, 130, 230, 0.5);
                box-shadow: 0 0 15px 5px rgba(70, 130, 230, 0.3);
            }
        }

        @keyframes showTravelText {

            0%,
            30% {
                opacity: 0;
                transform: translateY(-50%) scale(0.8);
                color: rgba(255, 220, 180, 0.8);
                text-shadow: 0 0 10px rgba(255, 170, 100, 0.8);
            }

            50%,
            80% {
                opacity: 1;
                transform: translateY(-50%) scale(1);
                color: rgba(255, 255, 255, 0.9);
                text-shadow: 0 0 15px rgba(150, 170, 255, 0.9);
            }

            100% {
                opacity: 0;
                transform: translateY(-50%) scale(1.2);
                color: rgba(200, 230, 255, 0.8);
                text-shadow: 0 0 20px rgba(70, 130, 230, 0.8);
            }
        }

        .ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate3d(1, 0.5, 0.2, 0deg);
            border-radius: 50%;
            border: 1px solid rgba(255, 170, 100, 0.3);
            opacity: 0;
            z-index: 8;
            animation: colorTransitionRing 6s ease-in forwards;
            transform-style: preserve-3d;
        }

        #warp-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 4;
            perspective: 800px;
            perspective-origin: 50% 50%;
            transform-style: preserve-3d;
        }

        .warp-line {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-style: preserve-3d;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
            opacity: 0;
            height: 1px;
            z-index: 5;
        }

        #space-distortion {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            animation: spaceDistort 6s ease-in-out forwards;
            background: radial-gradient(circle at center, transparent 30%, rgba(0, 0, 0, 0.1) 60%, transparent 100%);
        }

        @keyframes spaceDistort {
            0% {
                opacity: 0;
                backdrop-filter: blur(0px) brightness(1);
            }

            20% {
                opacity: 0.1;
                backdrop-filter: blur(2px) brightness(1.2);
            }

            50% {
                opacity: 0.3;
                backdrop-filter: blur(5px) brightness(1.5);
            }

            80% {
                opacity: 0.1;
                backdrop-filter: blur(2px) brightness(1.2);
            }

            100% {
                opacity: 0;
                backdrop-filter: blur(0px) brightness(1);
            }
        }

        #loading-progress {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            z-index: 20;
        }

        #progress-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(to right, rgba(255, 170, 100, 0.7), rgba(70, 130, 230, 0.7));
            border-radius: 2px;
            transition: width 0.1s ease;
        }

        #progress-text {
            position: absolute;
            left: 50%;
            bottom: 7%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            z-index: 20;
            background: linear-gradient(to right, rgba(255, 170, 100, 0.9), rgba(255, 255, 255, 0.9), rgba(70, 130, 230, 0.9));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.7;
            }
        }

        @keyframes moveThroughTunnel {
            0% {
                perspective: 1000px;
                filter: saturate(1.2) brightness(0.9);
            }

            30% {
                perspective: 800px;
                filter: saturate(1.5) brightness(1.1);
            }

            70% {
                perspective: 400px;
                filter: saturate(1.3) brightness(1.2);
            }

            100% {
                perspective: 100px;
                filter: saturate(1) brightness(1.3);
            }
        }

        #flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            z-index: 100;
            pointer-events: none;
            animation: flashEffect 6s ease-in-out forwards;
        }

        @keyframes flashEffect {

            0%,
            95% {
                opacity: 0;
            }

            98% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div id="universe">
        <canvas id="starfield"></canvas>
        <div id="stars"></div>
        <div id="wormhole-container">
            <div id="wormhole">
                <div class="wormhole-inner"></div>
            </div>
            <div id="space-ripple"></div>
        </div>
        <div class="energy-burst"></div>
        <div id="tunnel"></div>
        <div class="cosmic-dust"></div>
        <div class="nebula"></div>
        <div id="warp-effect"></div>
        <div id="space-distortion"></div>
        <div id="flash"></div>
        <div id="travel-text">Traveling through space-time continuum...</div>
        <div id="loading-progress">
            <div id="progress-bar"></div>
        </div>
        <div id="progress-text">Initializing wormhole traversal...</div>
    </div>



    <script>
        document.addEventListener('click', function () {
            var elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.mozRequestFullScreen) { /* Firefox */
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE/Edge */
                elem.msRequestFullscreen();
            }
        }, { once: true }); // 使用 { once: true } 确保只在第一次点击时触发
    </script>

    <script>
        // Initialize variables for the destination
        const destinationPage = "2.html"; // Change this to your target page
        const animationDuration = 6000; // 6 seconds

        // Canvas setup for star field
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');

        // 设置画布大小为窗口大小
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 星星数组
        let canvasStars = [];
        const STAR_COUNT = 1500;
        const MAX_SPEED = 30;
        const FOCAL_LENGTH = canvas.width * 0.8;

        // 鼠标位置
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // 速度控制
        let speed = 2;
        let targetSpeed = 2;

        // 颜色变换
        let colorPhase = 0; // 0到1之间的值，表示从暖色到冷色的渐变

        // 初始化星星
        function initStars() {
            canvasStars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                canvasStars.push({
                    x: Math.random() * canvas.width - canvas.width / 2,
                    y: Math.random() * canvas.height - canvas.height / 2,
                    z: Math.random() * canvas.width,
                    prevX: 0,
                    prevY: 0,
                    size: Math.random() * 1.5 + 0.5,
                    speed: 0,
                    tail: [],
                    // 给星星添加颜色属性 - 从暖色到冷色的渐变
                    color: {
                        r: 255,
                        g: 255,
                        b: 255
                    }
                });
            }
        }

        // 更新星星位置
        function updateStars(timestamp) {
            // 逐渐增加速度，模拟加速穿越
            const progress = Math.min(1, timestamp / animationDuration);
            targetSpeed = 2 + progress * 38; // 从2到40的速度变化 - 提高最大速度

            // 更新颜色相位
            colorPhase = progress;

            // 平滑调整速度
            speed += (targetSpeed - speed) * 0.06; // 更快地跟随目标速度

            // 视角向前倾斜效果，使镜头看起来像是向前冲入隧道
            const perspectiveOrigin = 50 + Math.sin(timestamp / 1000) * 3;
            document.getElementById('wormhole-container').style.perspectiveOrigin = `${perspectiveOrigin}% 50%`;

            // 调整隧道缩放以匹配速度感
            const zoomScale = 1 + progress * 0.3;
            document.getElementById('wormhole').style.transform = `translate(-50%, -50%) translateZ(0) scale(${zoomScale})`;

            for (let i = 0; i < canvasStars.length; i++) {
                const star = canvasStars[i];

                // 保存上一帧位置用于绘制拖尾
                star.prevX = star.x;
                star.prevY = star.y;

                // 更新Z位置（向观察者移动）
                star.z -= speed;
                star.speed = speed;

                // 如果星星移动到观察者后面，重新放置到远处
                if (star.z <= 0) {
                    star.x = Math.random() * canvas.width - canvas.width / 2;
                    star.y = Math.random() * canvas.height - canvas.height / 2;
                    star.z = canvas.width;
                    star.tail = [];

                    // 更新星星颜色 - 基于当前颜色相位
                    if (colorPhase < 0.3) {
                        // 暖色调
                        star.color = {
                            r: 255,
                            g: 170 + Math.random() * 85,
                            b: 100 + Math.random() * 80
                        };
                    } else if (colorPhase < 0.7) {
                        // 过渡色
                        star.color = {
                            r: 200 + Math.random() * 55,
                            g: 150 + Math.random() * 80,
                            b: 200 + Math.random() * 55
                        };
                    } else {
                        // 冷色调
                        star.color = {
                            r: 100 + Math.random() * 80,
                            g: 150 + Math.random() * 105,
                            b: 230 + Math.random() * 25
                        };
                    }
                }

                // 根据鼠标位置偏移星星位置，创造视角移动感
                const perspective = FOCAL_LENGTH / (star.z + FOCAL_LENGTH);

                // 进入隧道时星星应该向中心聚集 - 漩涡效果
                const centerForce = progress * 0.15; // 随时间增加向中心的力
                const distFromCenterX = star.x / (canvas.width / 2);
                const distFromCenterY = star.y / (canvas.height / 2);

                star.x -= distFromCenterX * centerForce * speed;
                star.y -= distFromCenterY * centerForce * speed;

                const mouseEffectX = (mouseX - canvas.width / 2) * perspective * 0.05;
                const mouseEffectY = (mouseY - canvas.height / 2) * perspective * 0.05;

                star.x += mouseEffectX;
                star.y += mouseEffectY;

                // 拖尾长度与速度和进度成正比 - 随着时间推移拖尾变长
                if (speed > 10) {
                    star.tail.push({ x: star.x, y: star.y, z: star.z });
                    const tailLengthBase = Math.floor(speed / 5) + 3;
                    const tailLengthProgress = tailLengthBase + Math.floor(progress * 8);
                    const tailLength = Math.min(20, tailLengthProgress); // 限制最大长度

                    if (star.tail.length > tailLength) {
                        star.tail.shift();
                    }
                } else {
                    star.tail = [];
                }
            }
        }

        // 绘制星星
        function drawStars() {
            // 更透明的背景产生更强的拖尾效果
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 根据Z坐标排序星星，确保远处的星星先绘制
            canvasStars.sort((a, b) => b.z - a.z);

            for (let i = 0; i < canvasStars.length; i++) {
                const star = canvasStars[i];

                // 计算透视投影
                const perspective = FOCAL_LENGTH / (star.z + FOCAL_LENGTH);
                const x = canvas.width / 2 + star.x * perspective;
                const y = canvas.height / 2 + star.y * perspective;

                // 随速度和时间推移增加星星大小
                const progressFactor = colorPhase * 0.5 + 0.5; // 根据进度增大星星
                const size = star.size * perspective * (1 + speed / 30) * progressFactor;

                // 绘制拖尾
                if (star.tail.length > 1 && speed > 10) {
                    ctx.beginPath();

                    // 根据速度和进度设置拖尾渐变
                    const gradient = ctx.createLinearGradient(
                        canvas.width / 2 + star.tail[0].x * (FOCAL_LENGTH / (star.tail[0].z + FOCAL_LENGTH)),
                        canvas.height / 2 + star.tail[0].y * (FOCAL_LENGTH / (star.tail[0].z + FOCAL_LENGTH)),
                        x, y
                    );

                    const { r, g, b } = star.color;
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0)`);
                    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${0.2 + colorPhase * 0.3})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${0.5 + colorPhase * 0.4})`);

                    for (let j = 0; j < star.tail.length - 1; j++) {
                        const tailPerspective1 = FOCAL_LENGTH / (star.tail[j].z + FOCAL_LENGTH);
                        const tx1 = canvas.width / 2 + star.tail[j].x * tailPerspective1;
                        const ty1 = canvas.height / 2 + star.tail[j].y * tailPerspective1;

                        const tailPerspective2 = FOCAL_LENGTH / (star.tail[j + 1].z + FOCAL_LENGTH);
                        const tx2 = canvas.width / 2 + star.tail[j + 1].x * tailPerspective2;
                        const ty2 = canvas.height / 2 + star.tail[j + 1].y * tailPerspective2;

                        if (j === 0) {
                            ctx.moveTo(tx1, ty1);
                        }
                        ctx.lineTo(tx2, ty2);
                    }

                    // 使拖尾更明显，线宽随速度增加
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = size * (0.5 + colorPhase * 0.3);
                    ctx.stroke();
                }

                // 绘制星星
                const alpha = Math.min(1, perspective * 2);
                const { r, g, b } = star.color;

                // 随着进入隧道，增加星星亮度
                const brightnessFactor = 1 + colorPhase;
                const brightR = Math.min(255, r * brightnessFactor);
                const brightG = Math.min(255, g * brightnessFactor);
                const brightB = Math.min(255, b * brightnessFactor);

                ctx.fillStyle = `rgba(${brightR}, ${brightG}, ${brightB}, ${alpha})`;

                // 大星星使用更圆滑的形状
                if (size > 2) {
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();

                    // 为更大的星星添加光晕效果
                    const glowSize = size * (2 + colorPhase * 2);
                    const grd = ctx.createRadialGradient(x, y, size * 0.5, x, y, glowSize);
                    grd.addColorStop(0, `rgba(${brightR}, ${brightG}, ${brightB}, ${0.7 * alpha})`);
                    grd.addColorStop(0.5, `rgba(${brightR}, ${brightG}, ${brightB}, ${0.3 * alpha})`);
                    grd.addColorStop(1, `rgba(${brightR}, ${brightG}, ${brightB}, 0)`);

                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // 小星星直接绘制为矩形，性能更好
                    ctx.fillRect(x - size / 2, y - size / 2, size, size);
                }
            }
        }

        // 动画循环
        let startTime = null;
        function animate(timestamp) {
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;

            updateStars(elapsed);
            drawStars();

            if (elapsed < animationDuration) {
                requestAnimationFrame(animate);
            }
        }

        // 模拟鼠标移动以增加动态效果
        function simulateMouseMovement() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.1;

            const progress = Date.now() / 2000; // 控制速度
            mouseX = centerX + Math.cos(progress) * radius;
            mouseY = centerY + Math.sin(progress * 0.7) * radius;
        }

        // 设置周期性的鼠标模拟
        setInterval(simulateMouseMovement, 16);

        // 窗口调整大小处理
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initStars();
        });

        // DOM元素创建和交互设置
        function createDOM() {
            // Progress bar animation with color transition
            const progressBar = document.getElementById("progress-bar");
            const progressText = document.getElementById("progress-text");
            let progress = 0;
            const progressMessages = [
                "Initializing wormhole traversal...",
                "Calculating quantum coordinates...",
                "Stabilizing gravity fluctuations...",
                "Compressing spacetime fabric...",
                "Aligning dimensional vectors...",
                "Engaging hyperspace engines...",
                "Establishing destination lock...",
                "Completing transition sequence..."
            ];

            const progressInterval = setInterval(() => {
                progress += 1;
                progressBar.style.width = `${progress}%`;

                // Update progress text
                if (progress % 12 === 0) {
                    const messageIndex = Math.floor(progress / 12) % progressMessages.length;
                    progressText.textContent = progressMessages[messageIndex];

                    // Add a subtle fade animation for text change
                    progressText.style.animation = "none";
                    setTimeout(() => {
                        progressText.style.animation = "fadeInOut 1s ease";
                    }, 10);
                }

                if (progress >= 100) {
                    clearInterval(progressInterval);
                    progressText.textContent = "Transition complete! Redirecting...";
                }
            }, animationDuration / 100);

            // 创建扭曲线条效果 - 增强3D空间穿越感
            const warpEffect = document.getElementById("warp-effect");
            const numWarpLines = 100; // 光速线数量

            for (let i = 0; i < numWarpLines; i++) {
                const warpLine = document.createElement("div");
                warpLine.className = "warp-line";

                // 随机角度和长度
                const angle = Math.random() * 360;
                const length = 50 + Math.random() * 100; // 线长度

                // 设置线的初始位置和样式
                warpLine.style.width = `${length}px`;
                warpLine.style.transform = `translate(-50%, -50%) rotate(${angle}deg) translateZ(${-900 + Math.random() * 300}px)`;

                // 速度线的颜色渐变
                const lineProgress = i / numWarpLines;
                let color;

                if (lineProgress < 0.35) {
                    // 暖色调
                    color = `rgba(255, ${170 + Math.random() * 85}, ${100 + Math.random() * 80}, 0.8)`;
                } else if (lineProgress < 0.7) {
                    // 过渡色调
                    color = `rgba(${200 + Math.random() * 55}, ${150 + Math.random() * 60}, ${200 + Math.random() * 55}, 0.8)`;
                } else {
                    // 冷色调
                    color = `rgba(${100 + Math.random() * 60}, ${170 + Math.random() * 85}, 255, 0.8)`;
                }

                warpLine.style.background = `linear-gradient(90deg, transparent, ${color}, transparent)`;

                // 创建速度线动画
                const delay = Math.random() * 3;
                const duration = 2 + Math.random() * 3;

                const warpKeyframes = `
                    @keyframes warpLine${i} {
                        0% {
                            opacity: 0;
                            transform: translate(-50%, -50%) rotate(${angle}deg) translateZ(${-900 + Math.random() * 300}px);
                        }
                        10% {
                            opacity: ${0.5 + Math.random() * 0.5};
                        }
                        90% {
                            opacity: ${0.5 + Math.random() * 0.5};
                        }
                        100% {
                            opacity: 0;
                            transform: translate(-50%, -50%) rotate(${angle}deg) translateZ(${800 + Math.random() * 400}px);
                        }
                    }
                `;

                const warpStyle = document.createElement("style");
                warpStyle.textContent = warpKeyframes;
                document.head.appendChild(warpStyle);

                warpLine.style.animation = `warpLine${i} ${duration}s ease-in ${delay}s infinite`;

                warpEffect.appendChild(warpLine);
            }

            // 创建光环效果
            const numGlowRings = 8;
            for (let i = 0; i < numGlowRings; i++) {
                const ring = document.createElement("div");
                ring.className = "glow-ring";

                const delay = i * (animationDuration / numGlowRings);
                const duration = animationDuration * 0.75;

                const ringKeyframes = `
                    @keyframes expandGlowRing${i} {
                        0% {
                            width: 5vmin;
                            height: 5vmin;
                            opacity: 0.8;
                            border: 2px solid rgba(255, 170, 100, 0.5);
                            box-shadow: 0 0 15px 5px rgba(255, 170, 100, 0.3);
                        }
                        40% {
                            border: 2px solid rgba(200, 120, 200, 0.5);
                            box-shadow: 0 0 25px 8px rgba(200, 120, 200, 0.3);
                        }
                        80% {
                            border: 2px solid rgba(100, 160, 255, 0.5);
                            box-shadow: 0 0 35px 10px rgba(100, 160, 255, 0.3);
                        }
                        100% {
                            width: 180vmin;
                            height: 180vmin;
                            opacity: 0;
                            border: 2px solid rgba(70, 130, 230, 0.5);
                            box-shadow: 0 0 40px 12px rgba(70, 130, 230, 0.3);
                        }
                    }
                `;

                const ringStyle = document.createElement("style");
                ringStyle.textContent = ringKeyframes;
                document.head.appendChild(ringStyle);

                ring.style.animation = `expandGlowRing${i} ${duration}ms ease-out ${delay}ms forwards`;

                document.body.appendChild(ring);
            }
        }

        // 音频效果
        function setupAudio() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioCtx = new AudioContext();

                // 创建基础音色
                const oscillator1 = audioCtx.createOscillator();
                oscillator1.type = 'sine';
                oscillator1.frequency.setValueAtTime(55, audioCtx.currentTime);

                const oscillator2 = audioCtx.createOscillator();
                oscillator2.type = 'sine';
                oscillator2.frequency.setValueAtTime(110, audioCtx.currentTime);

                const oscillator3 = audioCtx.createOscillator();
                oscillator3.type = 'triangle';
                oscillator3.frequency.setValueAtTime(220, audioCtx.currentTime);

                // 频率变化
                oscillator1.frequency.linearRampToValueAtTime(75, audioCtx.currentTime + 3);
                oscillator1.frequency.linearRampToValueAtTime(65, audioCtx.currentTime + 6);

                oscillator2.frequency.linearRampToValueAtTime(165, audioCtx.currentTime + 2);
                oscillator2.frequency.linearRampToValueAtTime(196, audioCtx.currentTime + 4);
                oscillator2.frequency.linearRampToValueAtTime(147, audioCtx.currentTime + 6);

                oscillator3.frequency.linearRampToValueAtTime(330, audioCtx.currentTime + 3);
                oscillator3.frequency.linearRampToValueAtTime(440, audioCtx.currentTime + 6);

                // 滤波器
                const filter1 = audioCtx.createBiquadFilter();
                filter1.type = 'lowpass';
                filter1.frequency.setValueAtTime(500, audioCtx.currentTime);
                filter1.frequency.linearRampToValueAtTime(2000, audioCtx.currentTime + 6);
                filter1.Q.setValueAtTime(1, audioCtx.currentTime);
                filter1.Q.linearRampToValueAtTime(8, audioCtx.currentTime + 3);
                filter1.Q.linearRampToValueAtTime(2, audioCtx.currentTime + 6);

                // 音量控制
                const gainNode1 = audioCtx.createGain();
                gainNode1.gain.setValueAtTime(0, audioCtx.currentTime);
                gainNode1.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 1);
                gainNode1.gain.linearRampToValueAtTime(0.25, audioCtx.currentTime + 3);
                gainNode1.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 5);
                gainNode1.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 6);

                const gainNode2 = audioCtx.createGain();
                gainNode2.gain.setValueAtTime(0, audioCtx.currentTime);
                gainNode2.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.5);
                gainNode2.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 2);
                gainNode2.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 4);
                gainNode2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 6);

                const gainNode3 = audioCtx.createGain();
                gainNode3.gain.setValueAtTime(0, audioCtx.currentTime);
                gainNode3.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 2);
                gainNode3.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 5);
                gainNode3.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 6);

                // 空间音效
                const panner = audioCtx.createPanner();
                panner.panningModel = 'HRTF';
                panner.positionX.setValueAtTime(0, audioCtx.currentTime);
                panner.positionY.setValueAtTime(0, audioCtx.currentTime);
                panner.positionZ.setValueAtTime(-10, audioCtx.currentTime);
                panner.positionZ.linearRampToValueAtTime(5, audioCtx.currentTime + 6);

                // 连接音频节点
                oscillator1.connect(filter1);
                filter1.connect(gainNode1);
                gainNode1.connect(panner);

                oscillator2.connect(gainNode2);
                gainNode2.connect(panner);

                oscillator3.connect(gainNode3);
                gainNode3.connect(panner);

                panner.connect(audioCtx.destination);

                // 启动振荡器
                oscillator1.start();
                oscillator2.start();
                oscillator3.start();
                oscillator1.stop(audioCtx.currentTime + 6);
                oscillator2.stop(audioCtx.currentTime + 6);
                oscillator3.stop(audioCtx.currentTime + 6);

                // 添加呼啸音效
                let lastSweepTime = audioCtx.currentTime;

                const createRandomSweep = () => {
                    if (audioCtx.currentTime - lastSweepTime < 0.2) return;
                    lastSweepTime = audioCtx.currentTime;

                    const startFreq = 2000 + Math.random() * 2000;
                    const endFreq = 300 + Math.random() * 700;

                    const sweepOsc = audioCtx.createOscillator();
                    sweepOsc.type = Math.random() > 0.5 ? 'sine' : 'sawtooth';
                    sweepOsc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
                    sweepOsc.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + 0.3);

                    const sweepGain = audioCtx.createGain();
                    sweepGain.gain.setValueAtTime(0, audioCtx.currentTime);
                    sweepGain.gain.linearRampToValueAtTime(0.07, audioCtx.currentTime + 0.05);
                    sweepGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);

                    const sweepPan = audioCtx.createStereoPanner();
                    sweepPan.pan.setValueAtTime(Math.random() * 2 - 1, audioCtx.currentTime);

                    sweepOsc.connect(sweepGain);
                    sweepGain.connect(sweepPan);
                    sweepPan.connect(audioCtx.destination);

                    sweepOsc.start();
                    sweepOsc.stop(audioCtx.currentTime + 0.3);
                };

                // 定期添加随机音效
                const beepScheduler = setInterval(() => {
                    if (Math.random() > 0.6) {
                        createRandomSweep();
                    }
                }, 300);

                setTimeout(() => {
                    clearInterval(beepScheduler);
                }, animationDuration - 100);

            } catch (e) {
                console.log("Audio context not available");
            }
        }

        // 创建漩涡隧道内的环和粒子流
        function createWormholeEffects() {
            const wormhole = document.getElementById('wormhole');

            // 创建多层环以增加深度效果
            const numRings = 10;
            for (let i = 0; i < numRings; i++) {
                const ring = document.createElement('div');
                ring.className = 'wormhole-ring';

                // 每个环有不同的大小、颜色和旋转速度
                const size = 100 - i * 5;
                ring.style.width = `${size}%`;
                ring.style.height = `${size}%`;

                // 环的颜色随深度变化 - 从暖色到冷色
                const progress = i / numRings;
                let borderColor;

                if (progress < 0.3) {
                    // 暖色系
                    const hue = 30 + progress * 60;
                    borderColor = `hsla(${hue}, 90%, 65%, ${0.9 - progress * 0.5})`;
                } else if (progress < 0.6) {
                    // 过渡色
                    const hue = 90 + (progress - 0.3) * 150;
                    borderColor = `hsla(${hue}, 80%, 60%, ${0.7 - (progress - 0.3) * 0.5})`;
                } else {
                    // 冷色系
                    const hue = 240 + (progress - 0.6) * 60;
                    borderColor = `hsla(${hue}, 70%, 50%, ${0.5 - (progress - 0.6) * 0.4})`;
                }

                ring.style.borderColor = borderColor;
                ring.style.boxShadow = `0 0 ${8 + i * 2}px 2px ${borderColor}`;

                // 不同的旋转速度和方向
                const duration = 10 + i * 2;
                const direction = i % 2 === 0 ? 1 : -1;
                ring.style.animation = `rotateRing ${duration}s linear infinite ${direction === 1 ? '' : 'reverse'}`;

                // 深度位置
                ring.style.transform = `translate(-50%, -50%) rotateX(75deg) translateZ(${-i * 20}px)`;

                wormhole.appendChild(ring);
            }

            // 创建能量流效果
            const numStreams = 4;
            for (let i = 0; i < numStreams; i++) {
                const stream = document.createElement('div');
                stream.className = 'wormhole-stream';

                // 不同的旋转速度和方向
                const duration = 15 + i * 5;
                const direction = i % 2 === 0 ? 1 : -1;
                stream.style.animation = `rotateStream ${duration}s linear infinite ${direction === 1 ? '' : 'reverse'}`;

                // 在每个流中创建粒子
                const numParticles = 100;
                for (let j = 0; j < numParticles; j++) {
                    const particle = document.createElement('div');
                    particle.className = 'wormhole-stream-particle';

                    // 随机位置和大小
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 10 + Math.random() * 80; // 距中心的距离百分比
                    const x = 50 + Math.cos(angle) * distance;
                    const y = 50 + Math.sin(angle) * distance * 0.3; // 椭圆效果

                    particle.style.left = `${x}%`;
                    particle.style.top = `${y}%`;

                    // 随机大小和深度
                    const size = Math.random() * 3 + 1;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;

                    // 粒子颜色 - 基于位置的渐变
                    const distanceRatio = distance / 100;
                    let color;

                    if (distanceRatio < 0.3) {
                        // 中心区域 - 明亮的白色/暖色
                        color = `rgba(255, ${230 + Math.random() * 25}, ${200 + Math.random() * 55}, ${0.9 - distanceRatio})`;
                    } else if (distanceRatio < 0.6) {
                        // 中间区域 - 过渡色
                        color = `rgba(${200 + Math.random() * 55}, ${150 + Math.random() * 105}, ${220 + Math.random() * 35}, ${0.8 - distanceRatio})`;
                    } else {
                        // 外围区域 - 冷色
                        color = `rgba(${100 + Math.random() * 80}, ${150 + Math.random() * 105}, ${220 + Math.random() * 35}, ${0.7 - distanceRatio})`;
                    }

                    particle.style.backgroundColor = color;
                    particle.style.boxShadow = `0 0 ${size * 2}px ${color}`;

                    // 3D深度效果
                    const zIndex = Math.random() * 100 - 50;
                    particle.style.transform = `translateZ(${zIndex}px)`;

                    // 添加脉冲动画
                    const pulseKeyframes = `
                        @keyframes pulseParticle${i}_${j} {
                            0% {
                                opacity: ${0.7 + Math.random() * 0.3};
                                transform: translateZ(${zIndex}px) scale(1);
                            }
                            50% {
                                opacity: ${0.5 + Math.random() * 0.5};
                                transform: translateZ(${zIndex}px) scale(${1 + Math.random() * 0.5});
                            }
                            100% {
                                opacity: ${0.7 + Math.random() * 0.3};
                                transform: translateZ(${zIndex}px) scale(1);
                            }
                        }
                    `;

                    const style = document.createElement('style');
                    style.textContent = pulseKeyframes;
                    document.head.appendChild(style);

                    const duration = 2 + Math.random() * 3;
                    const delay = Math.random() * 2;
                    particle.style.animation = `pulseParticle${i}_${j} ${duration}s ease-in-out ${delay}s infinite alternate`;

                    stream.appendChild(particle);
                }

                wormhole.appendChild(stream);
            }

            // 创建能量爆发效果
            setInterval(() => {
                if (Math.random() > 0.7) {
                    const burst = document.createElement('div');
                    burst.className = 'energy-burst';
                    document.getElementById('wormhole-container').appendChild(burst);

                    // 移除元素避免内存泄漏
                    setTimeout(() => {
                        burst.remove();
                    }, 6000);
                }
            }, 500);

            // 创建空间涟漪效果
            setInterval(() => {
                if (Math.random() > 0.6) {
                    const ripple = document.createElement('div');
                    ripple.id = 'space-ripple';
                    document.getElementById('wormhole-container').appendChild(ripple);

                    // 移除元素避免内存泄漏
                    setTimeout(() => {
                        ripple.remove();
                    }, 6000);
                }
            }, 800);
        }

        // 主函数
        function init() {
            // 创建时空隧道效果
            createWormholeEffects();

            // 初始化Canvas星星
            initStars();

            // 启动Canvas动画
            requestAnimationFrame(animate);

            // 创建DOM元素
            createDOM();

            // 设置音频
            setupAudio();

            // 设置跳转
            setTimeout(() => {
                window.location.href = 'darkForest-interstellar.html';
            }, animationDuration);
        }

        // 调用初始化函数
        init();
    </script>

</body>

</html>