<!DOCTYPE html> <!--document(文件,记录) type   hypertext markup language-->
<html lang="zh-CN">

<head>

    <!--meta:元(如metadate:元数据);charset:字符集;UTF-8:Unicode Transformation Format 8(统一编码转换格式)-->
    <!-- UTF-8:Unicode Transformation Format 8(统一编码转换格式)，以8位(即1个字节)编码-->
    <!--使用 UTF-8 可以确保文档中的中文、英文以及其他特殊字符都能正确显示 -->
    <meta charset="UTF-8">

    <!-- 此 meta 标签用于设置页面在不同设备上的视口（viewport）。viewport 是用户在浏览器中看到的页面区域 -->
    <!-- name="viewport" ：为标签命名，该标签作用是关于视口设置的-->
    <!-- content="width=device-width" ：视口的宽度等于设备的屏幕宽度，确保页面在不同宽度的设备上正确显示 -->
    <!-- initial-scale=1.0 ：页面首次加载时的缩放比例为 1.0，即不进行缩放-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <title>星梦游Xmy|流浪地球·三体</title>


    <!-- 引入 Chart.js 库。Chart.js 是一个基于 HTML5 Canvas 的开源图表库，用于在网页上创建各种类型的图表，如折线图、柱状图、饼图等 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- 引入 Three.js 库的压缩版本。Three.js 是一个基于 WebGL 的 JavaScript 3D 库，可用于在网页上创建和展示交互式的 3D 图形 -->
    <!-- 压缩版本（.min.js）经过了优化，文件体积更小，加载速度更快，适合在生产环境中使用-->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>

    <!-- 引入 OrbitControls.js 脚本文件。OrbitControls 是 Three.js 库中的一个辅助控件，用于实现相机的轨道控制功能 -->
    <!-- 该控件允许用户通过鼠标交互来旋转、缩放和平移场景中的相机视角-->
    <!-- 用户可以通过鼠标左键拖动来旋转相机，右键拖动来平移相机，滚动鼠标滚轮来缩放相机-->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <!-- 引入 GLTFLoader.js 脚本文件。GLTFLoader 是 Three.js 库中的一个加载器，用于加载 GLTF 格式的 3D 模型-->
    <!-- GLTF：Graphics Library Transmission Format：图形库传输格式，用于高效地传输和加载 3D 场景和模型，支持纹理、动画、材质等-->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>





    <style>
        /* 以下是自定义鼠标图标 */

        /* 此 CSS 选择器使用通配符 *，表示选中页面上的所有元素，作用是将页面上所有元素的原来鼠标指针图标设置为无
        * 即当用户将鼠标移动到页面上的任何元素上时，原来鼠标指针图标将不会显示
        * !important 关键字用于提高该样式规则的优先级，确保该样式不会被其他样式规则覆 */
        * {
            cursor: none !important;
        }

        /* custom：风俗的，习俗的，习惯的；定制的，自定义的 */
        .custom-cursor {

            /* fixed：固定的
        * 固定定位的元素会相对于浏览器窗口进行定位，也就是说，无论页面如何滚动，
        * 该元素在浏览器窗口中的位置都不会改变。这是因为固定定位的元素脱离了文档流，
        * 不会对其他元素的布局产生影响，同时也不会随着其他元素的滚动而滚动。
        * 元素始终跟随鼠标移动，并且不受页面滚动的干扰，始终保持在浏览器窗口内可见。*/
            position: fixed;


            width: 32px;
            height: 32px;

            /* pointer：指针。使该元素不响应鼠标事件，例如点击、悬停等，鼠标指针事件会穿透该元素作用于其下方的元素 */
            pointer-events: none;


            /* 1000……000 (有31个0) = -2^31
            0111……111 (有31个1) = 2^0+2^1+2^2……+2^30 (等比数列求和) = +2^31-1  = 2147483647
            在有符号 32 位整数系统里，数值采用二进制补码形式存储。有符号 32 位整数的最高位是符号位，剩下 31 位用于表示数值大小
            最高位是符号位(1为负数，0为正数)，所以最大值是 2^31 - 1。将 z-index 设置为最大值，确保该元素始终显示在其他元素的最上层 */
            z-index: 2147483647;


            /*  一.transform 属性用于对元素进行 2D 或 3D 变换
            这里为平移变换，它将元素在水平和垂直方向上都向左上方移动自身宽度和高度的 50%
            第一个参数 `-50%` 表示在水平方向（X 轴）上，将元素向左移动自身宽度的 50%
            第二个参数 `-50%` 表示在垂直方向（Y 轴）上，将元素向上移动自身高度的 50%
            因为鼠标指针的点击位置，是左上角的尖端，而不是鼠标中心
            所以transform: translate(-50%, -50%)可以让自定义的光标元素的中心点，与鼠标左上角指针的点击位置重合
            二.translateZ(0) transform 属性的一个值，用于在3D空间中对元素进行Z轴方向的平移。当值为 0 时，元素在Z轴方向上没有实际的平移，但它有一些特殊的作用：
            1.触发硬件加速：在一些浏览器中，使用 translateZ(0) 可以触发浏览器对元素进行硬件加速渲染。这能使元素的动画效果更加流畅，提升性能，减少卡顿
            2.创建新的层叠上下文，防止元素被其他元素遮挡：在一些情况下，使用 translateZ(0) 可以创建一个新的层叠上下文，防止元素被其他元素遮挡。*/
            transform: translate(-50%, -50%) translateZ(0);


            /* transition：转变，过渡
            控制 transform 属性变化时的过渡效果，过渡时间为 0.01 秒，采用线性的过渡方式，即匀速变化 */
            transition: transform 0.01s linear;

            /* 设置元素变换的原点为中心位置，这样在进行旋转、缩放等变换操作时，会以元素的中心点为基准 */
            transform-origin: center;

            /* 告诉浏览器该元素的 transform 属性即将发生变化，有助于浏览器提前进行优化，提高渲染性能 */
            will-change: transform;

            /* 当元素旋转到背面时，将其隐藏，为了确保自定义鼠标光标元素在进行 3D 变换时，背面不会显示出来。
            -webkit- 前缀是为了兼容 Safari 等浏览器 */
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }



        .cursor-core {


            /* fixed ：常用于创建固定在页面某个位置的元素，如导航栏、返回顶部按钮等，方便用户在页面滚动时始终能快速访问这些元素
            absolute ：常用于精确控制元素在页面中的位置，如弹出框、下拉菜单等，可根据其祖先元素的位置进行精准定位 */
            position: absolute;


            width: 12px;
            height: 12px;


            /*  linear：线性的 ；gradient：梯度，坡度，渐变 ；var：variable；可变的，变量
            时针6点钟方向为0度(degree)，方向沿着顺时针方向
            0deg 或 360deg：从下往上渐变
            45deg：从左下角到右上角渐变
            90deg：从左往右渐变
            135deg：从左上角到右下角渐变
            180deg：从上往下渐变
            270deg：从右往左渐变 */
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));



            /* 当元素的宽度和高度相等时，设置元素边框圆角为 50% 可将元素变为圆形 ( radius：半径 ) 
           内容：   content
           内边距： padding
           边框：   border
           外边距： margin      */
            border-radius: 50%;


            /* box-shadow 属性用于为元素添加阴影效果。它接受多个参数，通过这些参数可以控制阴影的位置、模糊程度和颜色等。
            第一个参数 0 表示阴影在水平方向上的偏移量，0 意味着阴影不会在水平方向上产生偏移，即与元素的左边缘对齐。
            第二个参数 0 表示阴影在垂直方向上的偏移量，0 意味着阴影不会在垂直方向上产生偏移，即与元素的上边缘对齐。
            第三个参数 15px 表示阴影的模糊半径，值越大，阴影就越模糊。这里设置为 15px，会使阴影呈现出较为柔和的效果。
            第四个参数 决定阴影的颜色。*/
            box-shadow: 0 0 15px var(--primary-color);

            /* top: 50%--将元素的上边缘相对于其父元素的上边缘向下偏移 50% 的父元素高度
             left: 50%--将元素的左边缘相对于其父元素的左边缘向右偏移 50% 的父元素宽度
             结合transform: translate(-50%, -50%)，可将元素定位到父元素的中心位置 */
            top: 50%;
            left: 50%;



            transform: translate(-50%, -50%) translateZ(0);


            /* 
             * 为元素应用动画效果。
             * 动画名称为 pulse(脉冲)，动画持续时间为 1.5 秒，无限循环播放，并且在每次循环结束时反向播放。
             * 这个动画会使元素产生脉冲的视觉效果
             * 模拟叶文洁向宇宙发出地球位置广播："我真诚地呼唤"，"我在这里~"，"黑暗森林~"
             */
            animation: pulse 1.5s infinite alternate;


            /* 
             * 设置元素的 3D 变换样式
             * preserve-3d 表示子元素将保留其 3D 变换，不会被扁平化到 2D 平面上
             */
            transform-style: preserve-3d;


            will-change: transform;
            transform-origin: center;

            /* 这里设置为 9999，确保该元素在大多数情况下都显示在其他元素的上方*/
            z-index: 9999;
        }




        .cursor-ring {

            position: absolute;
            /* 设置元素的宽度和高度为其父元素宽度的 100% */
            width: 100%;
            height: 100%;
            border-radius: 50%;

            /* 
             * 为元素添加阴影效果，可创建出环形的发光效果。
             * rgba：red、green、blue、alpha，分别表示红、绿、蓝三原色和透明度。
             * 第一个阴影：水平和垂直偏移量都为 0，模糊半径为 15px，颜色为 rgba(0, 247, 255, 0.8)，用于创建较亮的外层光晕。
             * 第二个阴影：水平和垂直偏移量都为 0，模糊半径为 30px，颜色为 rgba(0, 170, 255, 0.6)，用于创建较淡的外层光晕。
             * 第三个阴影：使用 inset 关键字表示内部阴影，水平和垂直偏移量都为 0，模糊半径为 10px，颜色为 rgba(0, 102, 204, 0.8)，用于创建内部的光晕。
             */
            box-shadow:
                0 0 15px rgba(0, 247, 255, 0.8),
                0 0 30px rgba(0, 170, 255, 0.6),
                inset 0 0 10px rgba(0, 102, 204, 0.8);

            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(0);

            /* 
             * 为元素应用动画效果。
             * 第一个动画 rotate，持续时间为 3 秒，线性播放，无限循环，使元素进行旋转。
             * 第二个动画 ringGlow，持续时间为 3 秒，缓入缓出播放，无限循环，并且在每次循环结束时反向播放，使元素的发光效果产生变化。
             */
            animation:
                rotate 3s linear infinite,
                ringGlow 3s ease-in-out infinite alternate;

            /* 
             * 设置元素的盒模型计算方式为 border-box。
             * 这意味着元素的宽度和高度包括内容、内边距和边框，而不包括外边距。
             */
            box-sizing: border-box;
        }




        /*
         * 为 .cursor-ring 元素添加一个伪元素 ::before，用于创建一个具有特定样式的圆环效果。
         * .cursor-ring::before 只是在其基础上添加额外的视觉效果，两者共同作用构建出完整的光标样式。
         */
        .cursor-ring::before {

            /*
             * content 属性用于在伪元素中插入内容。这里设置为空字符串，意味着不插入实际的文本内容。
             * 对于 ::before 和 ::after 伪元素，content 属性是必需的，即使它的值为空。
             */
            content: '';

            /*
             * position 属性设置为 absolute，使该伪元素脱离正常文档流，相对于最近的定位祖先元素（即 .cursor-ring）进行定位。
             * 这样可以精确控制伪元素在 .cursor-ring 内的位置。
             */
            position: absolute;

            /*
             * top、left、right 和 bottom 属性都设置为 0，这会使伪元素的四个边缘分别与 .cursor-ring 元素的四个边缘对齐。
             * 也就是说，伪元素会完全覆盖 .cursor-ring 元素。
             */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;


            border-radius: 50%;
            padding: 3px;
            background: linear-gradient(135deg,
                    #00f7ff 0%,
                    #00aaff 40%,
                    #0066cc 100%);
            /*
             * -webkit-mask 属性是为了兼容 Safari 等基于 WebKit 内核的浏览器而设置的遮罩效果。
             * 第一个 linear-gradient(#fff 0 0) content-box 表示一个白色的线性渐变，范围限制在内容框内。
             * 第二个 linear-gradient(#fff 0 0) 表示另一个白色的线性渐变，覆盖整个元素。
             * 这两个渐变结合起来，用于控制背景的显示区域。
             */
            -webkit-mask:
                linear-gradient(#fff 0 0) content-box,
                linear-gradient(#fff 0 0);
            /*
             * mask 属性是标准的遮罩属性，作用与 -webkit-mask 相同。
             * 同样使用两个线性渐变来控制背景的显示区域。
             */
            mask:
                linear-gradient(#fff 0 0) content-box,
                linear-gradient(#fff 0 0);
            /*
             * -webkit-mask-composite 属性是为了兼容 Safari 等基于 WebKit 内核的浏览器而设置的遮罩合成模式。
             * xor 模式表示将两个遮罩层进行异或运算，即两个遮罩层重叠的部分不显示，不重叠的部分显示。
             */
            -webkit-mask-composite: xor;
            /*
             * mask-composite 属性是标准的遮罩合成模式，exclude 与 xor 类似，也是将两个遮罩层进行异或运算。
             * 这样可以实现背景渐变在特定区域显示的效果。
             */
            mask-composite: exclude;
        }

        /*
         * keyframes : 关键帧
         * 定义一个名为 ringGlow 的关键帧动画，用于控制环形元素的发光效果动态变化
         * 关键帧动画允许在动画过程中定义多个时间点（关键帧）的样式，浏览器会自动在这些关键帧之间进行过渡
         * 这里的 0% 到 100% 时间段指的是 `ringGlow` 这个关键帧动画从开始到结束的整个过程
         * 动画会在其持续时间（这里设置为 3 秒）内，从 0% 这个起始状态逐渐过渡到 100% 这个结束状态，在此期间逐渐改变环形元素的滤镜、不透明度和阴影效果
         * 从而实现发光效果的动态变化，增强视觉效果
         */
        @keyframes ringGlow {

            /* 动画起始状态（0%） */
            0% {
                /* 滤镜效果：
                 * hue-rotate(-10deg)：将元素的色相旋转 -10 度，轻微改变颜色的色调。
                 * brightness(1)：设置元素的亮度为 1，即正常亮度。
                 */
                filter: hue-rotate(-10deg) brightness(1);
                /* 不透明度设置为 0.9，元素呈现出一定的半透明效果 */
                opacity: 0.9;
                /* 阴影效果：
                 * 第一个阴影：水平和垂直偏移量都为 0，模糊半径为 10px，颜色为 rgba(0, 247, 255, 0.8)，用于创建较亮的外层光晕。
                 * 第二个阴影：水平和垂直偏移量都为 0，模糊半径为 20px，颜色为 rgba(0, 170, 255, 0.6)，用于创建较淡的外层光晕。
                 * 第三个阴影：使用 inset 关键字表示内部阴影，水平和垂直偏移量都为 0，模糊半径为 8px，颜色为 rgba(0, 102, 204, 0.8)，用于创建内部的光晕。
                 */
                box-shadow:
                    0 0 10px rgba(0, 247, 255, 0.8),
                    0 0 20px rgba(0, 170, 255, 0.6),
                    inset 0 0 8px rgba(0, 102, 204, 0.8);
            }

            /* 动画结束状态（100%） */
            100% {
                /* 滤镜效果：
                 * hue-rotate(20deg)：将元素的色相旋转 20 度，使颜色的色调发生明显变化。
                 * brightness(1.6)：设置元素的亮度为 1.6，让元素变得更亮。
                 */
                filter: hue-rotate(20deg) brightness(1.6);
                /* 不透明度设置为 1，元素完全不透明 */
                opacity: 1;
                /* 阴影效果：
                 * 第三个阴影：使用 inset 关键字表示内部阴影，水平和垂直偏移量都为 0，模糊半径为 15px，颜色为 rgba(0, 102, 204, 1)，用于创建更亮的内部光晕。
                 */
                box-shadow:
                    0 0 25px rgba(0, 247, 255, 1),
                    0 0 40px rgba(0, 170, 255, 0.8),
                    inset 0 0 15px rgba(0, 102, 204, 1);
            }
        }


        /* 
         * 定义鼠标轨迹元素的样式，该元素用于在鼠标移动时显示跟随的特效。
         * 这些特效模拟了星际空间的各种视觉效果，如银河核心脉冲、星云扩散等。
         */
        .cursor-trail {
            position: absolute;
            top: 50%;
            left: 50%;

            /*  calc：calculate(计算)
            基础宽度为 38 像素，再加上一个动态值
            `--move-intensity` 变量用于动态调整 `.cursor-trail` 元素的宽度和高度
            `--move-intensity`变量的值会根据用户的交互强度而变化，例如鼠标移动速度、点击频率等
            随着这些变化，`--move-intensity` 变量的值也会相应地改变
            这样当鼠标移动速度加快时，元素的宽度和高度会相应增大，反之则减小
            从而使元素的宽度和高度随之动态变化，增强视觉效果
            如果删除`--move-intensity` 变量，元素的宽度将固定为 38px，失去动态变化的效果 */
            width: calc(34px + var(--move-intensity, 0) * 6px);
            height: calc(34px + var(--move-intensity, 0) * 6px);
            transform: translate(-50%, -50%) translateZ(0);
            /* 
             * 设置元素的 3D 变换样式，`preserve-3d` 表示子元素将保留其 3D 变换，不会被扁平化到 2D 平面上。
             */
            transform-style: preserve-3d;

            will-change: transform;
            z-index: 9997;
            /* 
             * 设置元素变换的原点为中心位置，这样在进行旋转、缩放等变换操作时，会以元素的中心点为基准。
             */
            transform-origin: 50% 50%;
            background:
                /* 银河核心脉冲效果，从中心向外辐射不同颜色的渐变，模拟银河核心的脉冲光效 */
                /* 
                 * radial-gradient 径向渐变函数，从一个中心点向四周辐射的渐变。
                 * circle at 50% 50% 表示渐变的形状为圆形，中心点位于元素的水平和垂直方向的正中间。

                 */
                radial-gradient(circle at 50% 50%,
                    /* 
                     * hsla ：色相（hue）、饱和度（saturation）、亮度（lightness）、透明度（alpha）。
                     * 这里色相为 180 度，饱和度为 100%，亮度为 50%，透明度为 0.98。
                     * 该颜色位于渐变的起始位置（0%），也就是圆形的中心点。
                     */
                    hsla(180, 100%, 50%, 0.98) 0%,

                    hsla(185, 100%, 50%, 0.95) 5%,
                    hsla(190, 100%, 50%, 0.9) 25%,

                    /* 
                     * transparent 表示透明颜色。
                     * 从距离中心点 75% 的位置开始，渐变变为透明。
                     */
                    transparent 75%),


                /* 星云扩散层 */
                radial-gradient(circle at 50% 50%,
                    hsla(200, 100%, 70%, 0.95) 10%,
                    hsla(205, 100%, 60%, 0.8) 30%,
                    transparent 85%),
                /* 量子星光粒子效果，以中心为原点重复进行径向渐变，模拟量子星光闪烁的效果 */

                /* 径向渐变是从一个中心点向四周扩散的渐变效果，而 repeating-radial-gradient 会不断重复这个渐变模式
   circle at 50% 50% 表示渐变的形状是圆形，并且圆心位于元素的中心位置（水平和垂直方向均为 50%）*/
                repeating-radial-gradient(circle at 50% 50%,
                    /* rgba(255, 255, 255, 0.98) 表示白色，透明度为 0.98。从 0% 到 0.3% 的区域应用该颜色。*/
                    rgba(255, 255, 255, 0.98) 0% 0.3%,
                    /* hsla(245, 100%, 95%, 0.8) 表示色相为 245 度，饱和度为 100%，亮度为 95%，透明度为 0.8 的颜色。从 0.3% 到 0.6% 的区域应用该颜色*/
                    hsla(245, 100%, 95%, 0.8) 0.3% 0.6%,
                    hsla(218, 80%, 42%, 0.6) 0.6% 0.9%,
                    hsla(206, 75%, 53%, 0.4) 0.9% 1.2%,
                    /* transparent 表示透明，从 1.2% 到 2.5% 的区域应用透明效果 */
                    transparent 1.2% 2.5%),

                /* 动态星尘流体效果，根据 --mouse-dx 和 --mouse-dy 变量计算渐变角度，模拟动态的星尘流体效果 */
                linear-gradient(calc(var(--mouse-dx) * 1.5deg + var(--mouse-dy) * 1.5deg + 25deg),
                    hsla(228, 4%, 77%, 0.95) 10%,
                    hsla(0, 0%, 87%, 0.9) 40%,
                    hsla(230, 75%, 98%, 0.85) 80%);
            border-radius: 50%;
            pointer-events: none;
            /* 
             * 再次设置元素的堆叠顺序，覆盖之前的值，将其设置为 9998，确保该元素在页面中处于更高的层级。
             */
            z-index: 9998;
            /* 
             * 为元素应用滤镜效果，包括模糊、对比度、亮度调整和投影效果。
             * 模糊程度根据 `--move-intensity` 变量计算，亮度根据 `--click-intensity` 变量计算。
             */
            filter:
                blur(calc(0.5px + var(--move-intensity, 0) * 0.5px)) contrast(1200%) brightness(calc(4.8 + var(--click-intensity, 0) * 1.2)) drop-shadow(0 0 50px rgba(8, 25, 180, 0.97));
            /* 
             * 设置元素与背景的混合模式为 `plus-lighter`，将元素颜色与背景颜色相加，使元素更亮。
             */
            mix-blend-mode: plus-lighter;
            /* 
             * 再次设置元素变换的原点为中心位置，确保在进行变换操作时以中心点为基准。
             */
            transform-origin: 50% 50%;
            /* 
             * 为元素添加阴影效果，包括外部阴影和内部阴影，模拟元素的发光和立体感。
             */
            box-shadow:
                0 0 80px rgba(59, 139, 230, 0.95),
                0 0 75px rgba(80, 172, 214, 0.8),
                inset 0 0 70px #144c9f80,
                inset 0 0 60px rgba(36, 109, 226, 0.9);
            /* 
             * 为元素的多个属性设置过渡效果，当这些属性值发生变化时，会以指定的时间和贝塞尔曲线进行过渡动画。
             */
            transition:
                transform 0.012s cubic-bezier(0.22, 2.5, 0.28, 2.2),
                opacity 0.024s cubic-bezier(0.4, 0, 0.2, 2.0),
                width 0.024s cubic-bezier(0.18, 1.8, 0.82, 1.8),
                height 0.024s cubic-bezier(0.18, 1.8, 0.82, 1.8),
                filter 0.024s ease;
            /* 
             * 对元素进行变换操作，包括平移、缩放和旋转。
             * 缩放比例根据 `--click-intensity` 变量计算，旋转角度根据 `--mouse-dx` 和 `--rotate-angle` 变量计算。
             */
            transform:
                translate(-50%, -50%) scale(calc(1 + var(--click-intensity, 0) * 0.8)) rotate(calc(var(--mouse-dx) * 1.2deg + var(--rotate-angle, 0) * 1.2deg));
            /* 
             * 告诉浏览器该元素的 `transform`、`opacity` 和 `filter` 属性即将发生变化，有助于浏览器提前进行优化，提高渲染性能。
             */
            will-change: transform, opacity, filter;



            /* 增强物理模拟 */
            /**
             * 在星际航行中，随着鼠标的移动，周围的量子粒子和光影也会产生相应变化。
             * 
             * 1. --move-speed（移动速度）
             *    - 这个属性用于计算鼠标移动的有效速度。它先从鼠标的原始速度 `var(--mouse-speed, 0)` 中减去 0.15，这可以理解为设置了一个移动阈值，低于这个阈值的鼠标移动将被忽略。
             *    - 然后将差值乘以 2.5，对速度进行放大处理，让细微的鼠标移动也能产生明显的效果。
             *    - 接着使用 `max` 函数确保结果不会小于 0，避免出现负数速度。
             *    - 最后使用 `min` 函数将结果限制在 0 到 1 之间，确保速度值不会超出合理范围。这个值就像是星际飞船的引擎功率，控制着后续粒子和光影效果的变化强度。
             * 
             * 2. --particle-size（粒子大小）
             *    - 这个属性根据 `--move-speed` 来动态调整量子粒子的大小。基础大小为 1px，随着鼠标移动速度的增加，粒子大小会相应增大，最大增加量为 1.5px。
             *    - 想象一下，在星际空间中，当飞船加速飞行时，周围的量子粒子会因为速度的影响而变大，就像我们在高速行驶时看到的雨滴会变大一样。
             * 
             * 3. --trail-opacity（轨迹透明度）
             *    - 该属性用于控制鼠标移动轨迹的透明度。初始透明度为 0.95，随着鼠标移动速度的增加，透明度会逐渐降低，最大降低量为 0.6。
             *    - 这就好比在星际航行中，飞船速度越快，它留下的尾迹就会越淡，因为高速运动使得尾迹迅速消散在宇宙中。
             * 
             * 4. --fluid-distortion（流体扭曲度）
             *    - 这个属性根据鼠标的原始速度 `var(--mouse-speed, 0)` 来计算流体的扭曲角度。每单位鼠标速度会产生 0.4 度的扭曲。
             *    - 在科幻的世界里，鼠标的移动就像是在操控一股神秘的能量流，速度越快，能量流的扭曲程度就越大，仿佛能看到空间在鼠标的拖动下发生弯曲。
             */
            --move-speed: calc(min(max((var(--mouse-speed, 0) - 0.15) * 2.5, 0), 1));
            --particle-size: calc(1px + var(--move-speed) * 1.5px);
            --trail-opacity: calc(0.95 - var(--move-speed) * 0.);
            --fluid-distortion: calc(var(--mouse-speed, 0) * 0.4deg);





            /*---------------------------- 写个注释好累啊，后面的CSS只写了简单的注释，后续有时间的话，再继续写CSS的注释吧 ----------------------------*/







            /* 量子粒子系统v2 */
            &::before {
                content: '';
                position: absolute;
                width: 300%;
                height: 300%;
                background:
                    radial-gradient(circle at var(--particle-pos, 50% 50%),
                        rgba(255, 255, 255, 0.98) 10%,
                        transparent 90%),
                    repeating-linear-gradient(45deg,
                        rgba(255, 255, 255, 0.4) 0px 2px,
                        transparent 2px 5px),
                    repeating-radial-gradient(circle,
                        rgba(0, 245, 255, 0.3) 0% 1%,
                        transparent 1% 3%);
                mix-blend-mode: plus-lighter;
                animation:
                    particleFlow 0.6s cubic-bezier(0.2, 0, 0.8, 1) infinite,
                    particleSpin 4s linear infinite;
                opacity: calc(0.9 * var(--move-intensity) * (1 + var(--move-speed, 0)));
                transform:
                    translate(-50%, -50%) rotate(calc(var(--mouse-dx) * 1.2deg)) perspective(1000px) rotateX(calc(var(--mouse-dy) * -0.5deg));
                filter:
                    brightness(calc(1.6 + var(--click-intensity, 0) * 0.4)) contrast(200%) drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));
                transition:
                    opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1),
                    transform 0.15s linear;
            }

            /* 动态量子场追踪 */
            &::after {
                content: '';
                position: absolute;
                top: -25%;
                left: -25%;
                width: 150%;
                height: 150%;
                background:
                    radial-gradient(ellipse at var(--gradient-pos, 50% 50%),
                        rgba(0, 245, 255, 0.7) 0%,
                        rgba(93, 175, 213, 0.6) 30%,
                        transparent 70%),
                    conic-gradient(from calc(var(--rotate-angle, 0) * 1deg) at 50% 50%,
                        rgba(255, 255, 255, 0.2) 0deg,
                        rgba(0, 245, 255, 0.3) 90deg,
                        rgba(26, 69, 225, 0.3) 180deg,
                        rgba(255, 255, 255, 0.2) 270deg),
                    linear-gradient(to var(--gradient-direction, 135deg),
                        rgba(255, 255, 255, 0.15) 0%,
                        transparent 40%,
                        rgba(0, 245, 255, 0.15) 80%);
                mix-blend-mode: color-dodge;
                opacity: calc(0.95 * var(--move-intensity) * (1 - var(--move-speed, 0)));
                transition:
                    opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                    background 0.3s ease;
                filter:
                    contrast(180%) brightness(1.4) blur(calc(0.2px + var(--move-speed, 0) * 0.3px));
                transform:
                    rotate(calc(var(--mouse-dx) * 0.3deg)) skew(calc(var(--mouse-dy) * 0.4deg)) scale(calc(1 + var(--click-intensity, 0) * 0.1));
                animation: gradientRotate 8s linear infinite;
            }

            @keyframes particleSpin {
                from {
                    transform: translate(-50%, -50%) rotate(0deg);
                }

                to {
                    transform: translate(-50%, -50%) rotate(360deg);
                }
            }

            @keyframes gradientRotate {
                from {
                    --rotate-angle: 0;
                }

                to {
                    --rotate-angle: 360;
                }
            }

            /* 粒子流动效果 */
            &::before {
                content: '';
                position: absolute;
                width: 180%;
                height: 180%;
                background:
                    radial-gradient(circle at var(--particle-pos),
                        rgba(255, 255, 255, 0.9) 0%,
                        transparent 80%),
                    repeating-linear-gradient(45deg,
                        rgba(255, 255, 255, 0.2) 0px,
                        rgba(255, 255, 255, 0.2) 2px,
                        transparent 2px,
                        transparent 4px);
                mix-blend-mode: soft-light;
                animation: particleFlow 1.5s cubic-bezier(0.4, 0, 0.2, 1) infinite;
                opacity: calc(0.7 * var(--move-intensity));
            }

            /* 动态光影追踪 */
            &::after {
                content: '';
                position: absolute;
                top: -15%;
                left: -15%;
                width: 130%;
                height: 130%;
                background:
                    radial-gradient(circle at var(--gradient-pos, 50% 50%),
                        rgba(0, 240, 255, 0.5) 0%,
                        rgba(82, 194, 179, 0.4) 50%,
                        transparent 100%),
                    linear-gradient(to var(--gradient-direction, 135deg),
                        rgba(255, 255, 255, 0.1) 0%,
                        transparent 50%,
                        rgba(0, 240, 255, 0.1) 100%);
                mix-blend-mode: color-dodge;
                opacity: calc(0.6 * var(--move-intensity));
                transition:
                    opacity 0.25s,
                    background 0.3s;
            }
        }

        @keyframes cometTrail {
            0% {
                transform:
                    translate(-50%, -50%) scale(1.5) rotate(calc(var(--mouse-dx) * 0.3deg)) skew(calc(var(--mouse-dx) * 0.8deg), calc(var(--mouse-dy) * 0.8deg));
                opacity: 1;
                width: 22px;
                height: 22px;
                filter: blur(0.3px) brightness(3);
            }

            30% {
                transform:
                    translate(-50%, -50%) scale(1.2) rotate(calc(var(--rotation-direction, 1) * 30deg + var(--mouse-dx) * 0.2deg)) skew(calc(var(--mouse-dx) * 0.4deg), calc(var(--mouse-dy) * 0.4deg));
                opacity: 0.8;
                filter: blur(0.5px) brightness(2.5);
                width: 26px;
                height: 26px;
            }

            60% {
                transform:
                    translate(-50%, -50%) scale(0.8) rotate(calc(var(--rotation-direction, 1) * 120deg)) skew(calc(var(--mouse-dx) * -0.2deg), calc(var(--mouse-dy) * -0.2deg));
                opacity: 0.4;
                filter: blur(0.7px) brightness(1.5);
                width: 32px;
                height: 32px;
            }

            100% {
                transform:
                    translate(-50%, -50%) scale(0.4) rotate(calc(var(--rotation-direction, 1) * 240deg + var(--mouse-dx) * 0.1deg));
                opacity: 0;
                width: 38px;
                height: 38px;
                filter: blur(1px) brightness(0.8);
            }
        }

        @keyframes particleFlow {
            0% {
                transform: translate(-20%, -20%) scale(0.9);
                opacity: 0;
            }

            20% {
                opacity: 0.9;
                transform: translate(0, 0) scale(1.1);
            }

            100% {
                transform:
                    translate(120%, 120%) scale(1.3) rotate(15deg);
                opacity: 0;
            }
        }

        .cursor-trail::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150%;
            height: 150%;
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.3;
            filter: blur(1px);
            animation: trailPulse 0.6s ease-out forwards;
        }

        @keyframes trailPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0.5;
            }

            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }












        :root {
            --primary-color: #00f7ff;
            --secondary-color: #ff00aa;
            --tertiary-color: #00ff88;
            --bg-color: #0a0a20;
            --card-color: rgba(10, 20, 40, 0.7);
            --text-color: #ffffff;
            --font-tech: 'Orbitron', 'KaiTi', 'STKaiti', '楷体', sans-serif;
            --moon-glow: rgba(200, 220, 255, 0.1);
            --sun-glow: rgba(255, 220, 100, 0.15);
            --text-glow: 0 0 10px rgba(0, 247, 255, 0.7);
            --text-glow-hover: 0 0 20px rgba(0, 247, 255, 0.9);
            --digital-font: 'Digital', 'Orbitron', sans-serif;
        }


        /* 
  `* { margin: 0; padding: 0; box-sizing: border-box; }`：
   - 通用选择器，选中页面上所有元素。
   - `margin: 0` 和 `padding: 0` 会将所有元素的外边距和内边距都设置为 0，消除浏览器默认的边距，方便统一布局。
   - `box-sizing: border-box` 会改变元素宽度和高度的计算方式，使得元素的内边距和边框包含在指定的宽度和高度内，避免因内边距和边框导致元素尺寸超出预期。
*/
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @font-face {
            font-family: 'Orbitron';
            font-style: normal;
            font-weight: 400;
            src: url('https://fonts.gstatic.com/s/orbitron/v25/yMJMMIlzdpvBhQQL_SC3X9yhF25-T1nyKS6xpmIyXjU1pg.woff2') format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }

        @font-face {
            font-family: 'Digital';
            src: url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap');
        }

        /* 
 1.`min-height: 100vh;`：设置<body>元素的最小高度为视口高度的100%，确保页面内容至少能填满整个视口。
 `overflow-x: hidden;`：隐藏<body>元素在水平方向上溢出的内容，防止出现水平滚动条。
 `font-family: var(--font-tech);`：将<body>元素内文本的字体设置为CSS变量`--font-tech`所定义的字体。
 `background-image`：为<body>元素设置多重背景图像。
   - 第一个径向渐变`radial-gradient(circle at 10% 20%, rgba(0, 247, 255, 0.1) 0%, transparent 20%)`在页面左上角附近创建一个渐变效果。
   - 第二个径向渐变`radial-gradient(circle at 90% 80%, rgba(255, 0, 170, 0.1) 0%, transparent 20%)`在页面右下角附近创建一个渐变效果。
   - 最后引入一个SVG图像作为背景，该SVG定义了一个由白色半透明圆点组成的图案。
`background-size: cover;`：确保背景图像覆盖整个<body>元素，可能会裁剪部分图像。
`background-attachment: fixed;`：设置背景图像固定，不随页面滚动而滚动。
*/
        body {
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
            font-family: var(--font-tech);
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 247, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 0, 170, 0.1) 0%, transparent 20%),




                /*
// 设置 body 元素的背景图像，使用的是一个嵌入的 SVG 数据 URI。：
// 1. `url()` 函数：CSS 中用于指定外部资源的函数，这里用于引用一个 SVG 格式的背景图像。
// 2. `data:image/svg+xml;charset=utf-8,`：这是数据 URI 的前缀部分。
//    - `data:` 表示这是一个数据 URI，直接在代码中嵌入资源数据。
//    - `image/svg+xml` 表明数据的 MIME 类型是 SVG 格式的图像。
//    - `charset=utf-8` 指定数据的字符编码为 UTF-8。
// 3. SVG 代码部分：
//    - `<svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%'>`：定义了一个 SVG 元素。
//      - `xmlns='http://www.w3.org/2000/svg'`：指定 SVG 的命名空间，这是创建有效的 SVG 文档所必需的。
//      - `width='100%'` 和 `height='100%'`：设置 SVG 的宽度和高度为父元素的 100%。
//    - `<pattern id='pattern' x='0' y='0' width='40' height='40' patternUnits='userSpaceOnUse'>`：定义了一个图案元素。
//      - `id='pattern'`：为图案指定一个唯一的标识符，后续可以通过这个 ID 引用该图案。
//      - `x='0'` 和 `y='0'`：设置图案的起始位置为 (0, 0)。
//      - `width='40'` 和 `height='40'`：定义图案的宽度和高度为 40 个单位。
//      - `patternUnits='userSpaceOnUse'`：指定图案的坐标系统使用用户空间，即图案的尺寸和位置是相对于 SVG 元素的用户坐标系。
//    - `<circle cx='1' cy='1' r='1' fill='rgba(255, 255, 255, 0.1)'/>`：在图案中定义一个圆形。
//      - `cx='1'` 和 `cy='1'`：设置圆形的圆心坐标为 (1, 1)。
//      - `r='1'`：设置圆形的半径为 1 个单位。
//      - `fill='rgba(255, 255, 255, 0.1)'`：设置圆形的填充颜色为白色，透明度为 0.1。
//    - `</pattern>`：结束图案元素的定义。
//    - `<rect x='0' y='0' width='100%' height='100%' fill='url(#pattern)'/>`：定义一个矩形元素。
//      - `x='0'` 和 `y='0'`：设置矩形的起始位置为 (0, 0)。
//      - `width='100%'` 和 `height='100%'`：设置矩形的宽度和高度为父元素的 100%。
//      - `fill='url(#pattern)'`：使用之前定义的图案（通过 ID `pattern` 引用）来填充矩形。
//    - `</svg>`：结束 SVG 元素的定义。*/
                url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100%25' height='100%25'%3E%3Cpattern id='pattern' x='0' y='0' width='40' height='40' patternUnits='userSpaceOnUse'%3E%3Ccircle cx='1' cy='1' r='1' fill='rgba(255, 255, 255, 0.1)'/%3E%3C/pattern%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='url(%23pattern)'/%3E%3C/svg%3E");
            background-size: cover;
            background-attachment: fixed;
        }

        /* 3D地球容器 */
        #earth-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        /* 月亮容器 */
        #moon-container {
            position: fixed;
            top: 10%;
            left: 5%;
            width: 150px;
            height: 150px;
            z-index: -1;
            cursor: none;
            transition: transform 0.3s;
        }

        #moon-container:hover {
            transform: scale(1.1);
        }

        /* 太阳容器 */
        #sun-container {
            position: fixed;
            top: 10%;
            right: 5%;
            width: 150px;
            height: 150px;
            z-index: -1;
            cursor: none;
            transition: transform 0.3s;
        }

        #sun-container:hover {
            transform: scale(1.1);
        }


        /* 水滴容器 */
        #waterdrop-container {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 1%;
            width: 200px;
            height: 200px;
            overflow: visible;
            z-index: 10;
            cursor: pointer;
        }

        #waterdrop {
            width: 100%;
            height: 100%;
            position: absolute;
            animation: float 3s ease-in-out infinite;
        }

        #waterdrop::before {
            content: "";
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 80px;
            background: radial-gradient(circle at 50% 0%, #00aaff, transparent 70%);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            box-shadow: 0 0 20px #00aaff, 0 0 40px rgba(0, 170, 255, 0.5);
            filter: blur(1px);
        }

        #waterdrop::after {
            content: "";
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            filter: blur(1px);
        }

        #hint-text {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00aaff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            opacity: 0.8;
            animation: pulse 2s infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }

        .laser {
            position: fixed;
            width: 8px;
            height: 0;
            background: linear-gradient(to bottom,
                    rgba(100, 255, 255, 0.98),
                    rgba(80, 220, 255, 0.95),
                    rgba(60, 180, 255, 0.92),
                    rgba(40, 140, 255, 0.88));
            box-shadow:
                /* 核心光晕 */
                0 0 5px rgba(255, 255, 255, 1),
                0 0 10px rgba(255, 255, 255, 1),
                /* 内核光晕 */
                0 0 20px rgba(220, 255, 255, 1),
                0 0 40px rgba(200, 255, 255, 1),
                /* 内层光晕 */
                0 0 60px rgba(180, 255, 255, 0.98),
                0 0 80px rgba(160, 255, 255, 0.96),
                /* 中层光晕 */
                0 0 100px rgba(140, 255, 255, 0.94),
                0 0 120px rgba(120, 255, 255, 0.92),
                /* 外层光晕 */
                0 0 140px rgba(100, 255, 255, 0.9),
                0 0 160px rgba(80, 255, 255, 0.88),
                /* 最外层扩散 */
                0 0 180px rgba(60, 255, 255, 0.86),
                0 0 200px rgba(40, 255, 255, 0.84);
            animation:
                laser-beam 1.2s cubic-bezier(0.2, 0.8, 0.8, 1) forwards,
                laser-pulse 0.8s ease-in-out infinite,
                laser-flow 2s linear infinite,
                laser-vibrate 0.15s ease-in-out infinite;
            z-index: 999999;
            pointer-events: none;
            opacity: 0.95;
            transform-origin: bottom;
            filter: blur(0.3px);
        }

        /* 增强光束内核效果 - 更明亮更动态 */
        .laser::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 100%;
            background: linear-gradient(to bottom,
                    rgba(220, 255, 255, 1),
                    rgba(200, 255, 255, 0.98),
                    rgba(180, 255, 255, 0.96),
                    rgba(160, 255, 255, 0.94),
                    rgba(140, 255, 255, 0.92),
                    rgba(120, 255, 255, 0.9));
            box-shadow:
                0 0 15px rgba(200, 255, 255, 1),
                0 0 25px rgba(150, 255, 255, 0.95),
                0 0 35px rgba(100, 255, 255, 0.85),
                0 0 45px rgba(80, 240, 255, 0.7) inset;
            animation:
                laser-core-pulse 0.3s ease-in-out infinite,
                laser-core-flicker 1s ease-in-out infinite,
                laser-core-extend 1s ease-out forwards,
                laser-core-sparkle 2s linear infinite;
            filter: blur(0.1px) brightness(1.1);
            z-index: 999999;
            mask-image: linear-gradient(to bottom,
                    rgba(0, 0, 0, 1) 0%,
                    rgba(0, 0, 0, 1) 70%,
                    rgba(0, 0, 0, 0.3) 100%);
        }

        @keyframes laser-core-sparkle {

            0%,
            100% {
                opacity: 1;
            }

            20%,
            40%,
            60%,
            80% {
                opacity: 0.95;
                box-shadow:
                    0 0 20px rgba(220, 255, 255, 1),
                    0 0 30px rgba(120, 255, 255, 0.98),
                    0 0 40px rgba(100, 255, 255, 0.88),
                    0 0 50px rgba(80, 240, 255, 0.75) inset;
            }
        }

        @keyframes laser-core-extend {
            0% {
                mask-image: linear-gradient(to bottom,
                        rgba(0, 0, 0, 1) 0%,
                        rgba(0, 0, 0, 1) 60%,
                        rgba(0, 0, 0, 0.2) 100%);
            }

            50% {
                mask-image: linear-gradient(to bottom,
                        rgba(0, 0, 0, 1) 0%,
                        rgba(0, 0, 0, 1) 70%,
                        rgba(0, 0, 0, 0.4) 100%);
            }

            100% {
                mask-image: linear-gradient(to bottom,
                        rgba(0, 0, 0, 1) 0%,
                        rgba(0, 0, 0, 1) 65%,
                        rgba(0, 0, 0, 0.35) 100%);
            }
        }

        @keyframes laser-core-flicker {

            0%,
            10%,
            12%,
            20%,
            24%,
            65%,
            72%,
            77%,
            85%,
            95%,
            100% {
                opacity: 1;
            }

            11%,
            23%,
            66%,
            76%,
            86% {
                opacity: 0.7;
            }
        }

        /* 光束能量波动效果 */
        .laser::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom,
                    transparent,
                    rgba(255, 255, 255, 0.2),
                    transparent);
            animation: laser-energy 1.5s linear infinite;
        }

        @keyframes laser-pulse {

            0%,
            100% {
                opacity: 0.98;
                box-shadow:
                    /* 内核光晕 */
                    0 0 8px rgba(200, 255, 255, 0.95),
                    0 0 12px rgba(100, 255, 255, 0.95),
                    /* 内层光晕 */
                    0 0 20px rgba(80, 240, 255, 0.9),
                    0 0 35px rgba(60, 220, 255, 0.85),
                    /* 中层光晕 */
                    0 0 50px rgba(40, 200, 255, 0.7),
                    0 0 65px rgba(20, 180, 255, 0.6),
                    /* 外层光晕 */
                    0 0 80px rgba(0, 160, 255, 0.5),
                    0 0 95px rgba(0, 140, 255, 0.4),
                    /* 最外层扩散 */
                    0 0 110px rgba(0, 120, 255, 0.3),
                    0 0 125px rgba(0, 100, 255, 0.2);
            }

            25% {
                opacity: 0.95;
                box-shadow:
                    /* 内核光晕 */
                    0 0 10px rgba(220, 255, 255, 0.98),
                    0 0 15px rgba(120, 255, 255, 0.98),
                    /* 内层光晕 */
                    0 0 25px rgba(100, 240, 255, 0.93),
                    0 0 40px rgba(80, 220, 255, 0.88),
                    /* 中层光晕 */
                    0 0 55px rgba(60, 200, 255, 0.75),
                    0 0 70px rgba(40, 180, 255, 0.65),
                    /* 外层光晕 */
                    0 0 85px rgba(20, 160, 255, 0.55),
                    0 0 100px rgba(0, 140, 255, 0.45),
                    /* 最外层扩散 */
                    0 0 115px rgba(0, 120, 255, 0.35),
                    0 0 130px rgba(0, 100, 255, 0.25);
            }

            50% {
                opacity: 0.92;
                box-shadow:
                    /* 内核光晕 */
                    0 0 12px rgba(240, 255, 255, 1),
                    0 0 18px rgba(140, 255, 255, 1),
                    /* 内层光晕 */
                    0 0 30px rgba(120, 240, 255, 0.95),
                    0 0 45px rgba(100, 220, 255, 0.9),
                    /* 中层光晕 */
                    0 0 60px rgba(80, 200, 255, 0.8),
                    0 0 75px rgba(60, 180, 255, 0.7),
                    /* 外层光晕 */
                    0 0 90px rgba(40, 160, 255, 0.6),
                    0 0 105px rgba(20, 140, 255, 0.5),
                    /* 最外层扩散 */
                    0 0 120px rgba(0, 120, 255, 0.4),
                    0 0 135px rgba(0, 100, 255, 0.3);
            }

            75% {
                opacity: 0.95;
                box-shadow:
                    /* 内核光晕 */
                    0 0 10px rgba(220, 255, 255, 0.98),
                    0 0 15px rgba(120, 255, 255, 0.98),
                    /* 内层光晕 */
                    0 0 25px rgba(100, 240, 255, 0.93),
                    0 0 40px rgba(80, 220, 255, 0.88),
                    /* 中层光晕 */
                    0 0 55px rgba(60, 200, 255, 0.75),
                    0 0 70px rgba(40, 180, 255, 0.65),
                    /* 外层光晕 */
                    0 0 85px rgba(20, 160, 255, 0.55),
                    0 0 100px rgba(0, 140, 255, 0.45),
                    /* 最外层扩散 */
                    0 0 115px rgba(0, 120, 255, 0.35),
                    0 0 130px rgba(0, 100, 255, 0.25);
            }
        }

        @keyframes laser-core-pulse {

            0%,
            100% {
                opacity: 1;
                width: 3px;
                transform: translateX(-50%) scaleY(1);
                box-shadow:
                    0 0 5px rgba(255, 255, 255, 1),
                    0 0 10px rgba(255, 255, 255, 1),
                    0 0 20px rgba(240, 255, 255, 1),
                    0 0 40px rgba(220, 255, 255, 1),
                    0 0 60px rgba(200, 255, 255, 0.98) inset,
                    0 0 80px rgba(180, 255, 255, 0.96) inset,
                    0 0 100px rgba(160, 255, 255, 0.94) inset;
            }

            25% {
                opacity: 0.99;
                width: 3.3px;
                transform: translateX(-50%) scaleY(1.03);
                box-shadow:
                    0 0 18px rgba(230, 255, 255, 1),
                    0 0 30px rgba(130, 255, 255, 0.98),
                    0 0 40px rgba(110, 240, 255, 0.85),
                    0 0 50px rgba(90, 220, 255, 0.7) inset;
            }

            50% {
                opacity: 0.98;
                width: 3.6px;
                transform: translateX(-50%) scaleY(1.07);
                box-shadow:
                    0 0 20px rgba(240, 255, 255, 1),
                    0 0 35px rgba(140, 255, 255, 1),
                    0 0 45px rgba(120, 240, 255, 0.9),
                    0 0 55px rgba(100, 220, 255, 0.8) inset;
            }

            75% {
                opacity: 0.99;
                width: 3.3px;
                transform: translateX(-50%) scaleY(1.03);
                box-shadow:
                    0 0 18px rgba(230, 255, 255, 1),
                    0 0 30px rgba(130, 255, 255, 0.98),
                    0 0 40px rgba(110, 240, 255, 0.85),
                    0 0 50px rgba(90, 220, 255, 0.7) inset;
            }
        }

        @keyframes laser-flow {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 0 100vh;
            }
        }

        @keyframes laser-energy {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(100%);
            }
        }

        @keyframes laser-vibrate {

            0%,
            100% {
                transform: translateX(0) scaleX(1);
            }

            25% {
                transform: translateX(0.5px) scaleX(1.02);
            }

            50% {
                transform: translateX(-0.5px) scaleX(0.98);
            }

            75% {
                transform: translateX(0.3px) scaleX(1.01);
            }
        }

        /* 激光冲击波效果 */
        @keyframes shockwave {
            0% {
                transform: scale(0.1);
                opacity: 0.9;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .laser-shockwave {
            position: absolute;
            border-radius: 50%;
            background: transparent;
            border: 2px solid rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), inset 0 0 10px rgba(0, 255, 255, 0.4);
            animation: shockwave 0.8s cubic-bezier(0.1, 0.3, 0.2, 1) forwards;
            pointer-events: none;
            z-index: 999998;
        }

        .laser-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: rgba(0, 200, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            animation: particle-fade 1s ease-out forwards;
            box-shadow:
                0 0 5px #00ffff,
                0 0 10px rgba(0, 255, 255, 0.6);
            filter: blur(0.3px);
            z-index: 999997;
        }

        @keyframes laser-beam {
            0% {
                height: 0;
                opacity: 0.8;
                transform: scaleY(0.1);
            }

            20% {
                opacity: 1;
                transform: scaleY(1.1);
            }

            50% {
                transform: scaleY(0.95);
            }

            100% {
                height: 100vh;
                opacity: 0;
                transform: scaleY(1);
            }
        }

        @keyframes particle-fade {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            25% {
                transform: translate(var(--x-offset, 10px), -30px) scale(0.8);
                opacity: 0.8;
            }

            50% {
                transform: translate(calc(var(--x-offset, 10px) * -0.5), -60px) scale(0.6);
                opacity: 0.6;
            }

            75% {
                transform: translate(calc(var(--x-offset, 10px) * 0.2), -80px) scale(0.4);
                opacity: 0.3;
            }

            100% {
                transform: translate(calc(var(--x-offset, 10px) * -0.1), -100px) scale(0.2);
                opacity: 0;
            }
        }



        /* 流星雨效果 */
        .meteor {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            box-shadow: 0 0 10px 2px var(--primary-color);
            opacity: 0;
            z-index: 0;
            transform-origin: left top;
        }





        /*-------------三体水滴流星雨：---------------*/
        /*     弄了两三天，还是弄不好，这个效果真的做废了
             只能当作背景的、有些不太令我满意的、简单流星雨效果了 */





        /* 三体水滴流星雨效果 */
        .waterdrop-meteor {
            position: absolute;
            width: 96px;
            /* 增大尺寸 */
            height: 192px;
            background: linear-gradient(to bottom,
                    hsla(200, 100%, 98%, 0.95) 0%,
                    /* 高光镜面效果 */
                    hsla(200, 80%, 95%, 0.9) 50%,
                    /* 中间过渡 */
                    hsla(200, 60%, 90%, 0.7) 100%);
            /* 底部轻微暗化 */
            border-radius: 50% 50% 30% 30% / 60% 60% 40% 40%;
            /* 更平滑的几何形状 */
            transform: rotate(-15deg);
            filter:
                drop-shadow(0 0 20px hsla(200, 100%, 80%, 0.8)) drop-shadow(0 0 40px hsla(200, 100%, 70%, 0.6));
            z-index: 0;
            opacity: 0;
            pointer-events: none;
            transform-style: preserve-3d;
            transition: transform 0.1s ease-out;
            animation: waterdropFall 6s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        /* 水滴头部 - 完美球形 */
        .waterdrop-meteor::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 70%;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at center,
                    hsl(195, 100%, 98%) 0%,
                    hsl(205, 100%, 85%) 50%,
                    transparent 80%);
            border-radius: 50%;
            transform: translateX(-50%);
            filter: blur(0.8px);
            box-shadow:
                0 0 30px 10px hsl(195, 100%, 80%),
                0 0 60px 20px hsl(205, 100%, 70%);
        }

        /* 水滴尾部 - 针尖效果 */
        .waterdrop-meteor::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            width: 0.3px;
            height: 80px;
            background: linear-gradient(to bottom,
                    hsla(195, 100%, 95%, 0.9) 0%,
                    hsla(230, 15%, 55%, 0.7) 70%,
                    transparent 100%);
            transform: translateX(-50%) scaleY(2);
            transform-origin: top center;
            filter: blur(0.5px);
            animation: tailPulse 2s infinite alternate;
        }

        /* 水滴尾迹动画 */
        @keyframes tailPulse {
            0% {
                opacity: 0.8;
                height: 100px;
            }

            100% {
                opacity: 0.3;
                height: 120px;
            }
        }

        /* 三体水滴星际航行动画 - 终极版 */
        @keyframes waterdropFall {
            0% {
                transform: translate(-100px, -100px) rotate(-45deg) scale(0.8);
                opacity: 0;
                filter: brightness(0.8) blur(2px);
            }

            5% {
                transform: translate(-80px, -80px) rotate(-45deg) scale(1);
                opacity: 0.3;
                filter: brightness(1.5) blur(1px);
            }

            10% {
                opacity: 1;
                filter: brightness(2.0) blur(0.5px);
                transform: rotate(-45deg) scale(1.2);
            }

            30% {
                transform: rotate(-40deg) scale(1.1);
            }

            50% {
                transform: rotate(-50deg) scale(1.3);
            }

            70% {
                transform: rotate(-45deg) scale(1.2);
            }

            90% {
                opacity: 1;
                filter: brightness(1.5) blur(1px);
            }

            100% {
                transform: translate(calc(100vw + 100px), calc(100vh + 100px)) rotate(-45deg) scale(0.8);
                opacity: 0;
                filter: brightness(0.8) blur(2px);
            }
        }

        /* 水滴飞行时的星际尾迹效果 */
        .waterdrop-trail {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center,
                    hsla(195, 100%, 80%, 0.3) 0%,
                    transparent 70%);
            transform: rotate(-15deg) scaleY(1.5);
            filter: blur(5px);
            z-index: -1;
            opacity: 0;
            animation: trailFade 2s ease-out forwards;
        }

        @keyframes trailFade {
            0% {
                opacity: 0;
                transform: rotate(-15deg) scale(0.5);
            }

            50% {
                opacity: 0.7;
                transform: rotate(-15deg) scale(1.2);
            }

            100% {
                opacity: 0;
                transform: rotate(-15deg) scale(2);
            }
        }

        /* 水滴流星雨特效 */
        .waterdrop-meteor {
            position: absolute;
            width: 12px;
            height: 60px;
            background: linear-gradient(to bottom,
                    hsl(195, 100%, 95%) 0%,
                    /* 寒冰蓝 */
                    hsl(205, 100%, 85%) 20%,
                    /* 寒冰蓝过渡 */
                    hsl(215, 100%, 75%) 40%,
                    /* 星空蓝 */
                    hsl(225, 30%, 65%) 60%,
                    /* 星空蓝过渡 */
                    hsl(230, 15%, 55%) 80%,
                    /* 水银灰 */
                    transparent 100%);
            border-radius: 50% 50% 10% 10% / 60% 60% 10% 10%;
            transform: rotate(-15deg);
            filter:
                drop-shadow(0 0 15px hsl(195, 100%, 80%)) drop-shadow(0 0 30px hsl(205, 100%, 70%));
            z-index: 0;
            opacity: 0;
            pointer-events: none;
            transform-style: preserve-3d;
        }

        .waterdrop-meteor::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 50%;
            width: 16px;
            height: 16px;
            background: radial-gradient(circle at center,
                    hsl(195, 100%, 95%) 0%,
                    hsl(205, 100%, 85%) 50%,
                    transparent 80%);
            border-radius: 50%;
            transform: translateX(-50%);
            filter: blur(1px);
            box-shadow: 0 0 20px 5px hsl(195, 100%, 80%);
        }

        .waterdrop-meteor::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 1px;
            height: 30px;
            background: linear-gradient(to bottom,
                    hsla(195, 100%, 95%, 0.9) 0%,
                    transparent 100%);
            transform: translateX(-50%);
            filter: blur(0.5px);
            transform-origin: top center;
        }

        /* 水滴流星雨动画 */
        @keyframes waterdropFall {
            0% {
                transform: translateY(-100px) rotate(-15deg) scale(0.8);
                opacity: 0;
                filter: brightness(0.8) blur(2px);
            }

            5% {
                transform: translateY(-80px) rotate(-15deg) scale(1);
                opacity: 0.3;
                filter: brightness(1.2) blur(1px);
            }

            10% {
                opacity: 1;
                filter: brightness(1.5) blur(0.5px);
            }

            90% {
                opacity: 1;
                filter: brightness(1.2) blur(1px);
            }

            100% {
                transform: translateY(calc(100vh + 100px)) rotate(-15deg) scale(0.8);
                opacity: 0;
                filter: brightness(0.8) blur(2px);
            }
        }

        /* 水滴流星雨特效 */
        .waterdrop-meteor {
            position: absolute;
            width: 12px;
            height: 60px;
            background: linear-gradient(to bottom,
                    hsl(195, 100%, 95%) 0%,
                    /* 寒冰蓝 */
                    hsl(205, 100%, 85%) 20%,
                    /* 寒冰蓝过渡 */
                    hsl(215, 100%, 75%) 40%,
                    /* 星空蓝 */
                    hsl(225, 30%, 65%) 60%,
                    /* 星空蓝过渡 */
                    hsl(230, 15%, 55%) 80%,
                    /* 水银灰 */
                    transparent 100%);
            border-radius: 50% 50% 10% 10% / 60% 60% 10% 10%;
            transform: rotate(-15deg);
            filter:
                drop-shadow(0 0 15px hsl(195, 100%, 80%)) drop-shadow(0 0 30px hsl(205, 100%, 70%));
            z-index: 0;
            opacity: 0;
            pointer-events: none;
            transform-style: preserve-3d;
        }

        .waterdrop-meteor::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 50%;
            width: 16px;
            height: 16px;
            background: radial-gradient(circle at center,
                    hsl(195, 100%, 95%) 0%,
                    hsl(205, 100%, 85%) 50%,
                    transparent 80%);
            border-radius: 50%;
            transform: translateX(-50%);
            filter: blur(1px);
            box-shadow: 0 0 20px 5px hsl(195, 100%, 80%);
        }

        .waterdrop-meteor::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 1px;
            height: 30px;
            background: linear-gradient(to bottom,
                    hsla(195, 100%, 95%, 0.9) 0%,
                    transparent 100%);
            transform: translateX(-50%);
            filter: blur(0.5px);
            transform-origin: top center;
        }

        /* 水滴流星雨动画 */
        @keyframes waterdropFall {
            0% {
                transform: translate(-100px, -100px) rotate(-45deg) scale(0.8);
                opacity: 0;
                filter: brightness(0.8) blur(2px);
            }

            5% {
                transform: translate(-80px, -80px) rotate(-45deg) scale(1);
                opacity: 0.3;
                filter: brightness(1.2) blur(1px);
            }

            10% {
                opacity: 1;
                filter: brightness(1.5) blur(0.5px);
            }

            90% {
                opacity: 1;
                filter: brightness(1.2) blur(1px);
            }

            100% {
                transform: translate(calc(100vw + 100px), calc(100vh + 100px)) rotate(-45deg) scale(0.8);
                opacity: 0;
                filter: brightness(0.8) blur(2px);
            }
        }






        /* -----------------以下是输入框特效，但是这个特效实在是太卡了，最后直接舍弃了，说多了都是泪----------------------- */





        /* 输入框流星特效 */
        .input-meteor {
            position: fixed;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9998;
            transform-origin: center;
            transition-timing-function: cubic-bezier(0.1, 0.8, 0.2, 1);
            filter: blur(0.5px);
        }

        /* 输入框爆发特效 */
        .input-burst {
            position: fixed;
            pointer-events: none;
            z-index: 9997;
            mix-blend-mode: screen;
            will-change: transform, opacity;
        }

        .star {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
            opacity: 0;
            z-index: 0;
        }

        @keyframes twinkle {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }

            50% {
                opacity: var(--opacity);
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
            margin-top: 3500px;
            /*最小化加全屏最不可见"ETO"的最小与顶部高度*/
            margin-bottom: 100px;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
        }

        .logo-container {
            position: relative;
            width: 100%;
            height: 200px;
            margin-bottom: 1rem;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--text-glow);
            position: relative;
            z-index: 2;
            letter-spacing: 5px;
            font-weight: 500;
            font-family: var(--font-tech);
            text-transform: uppercase;
            animation: textGlow 3s infinite alternate;
        }

        @keyframes textGlow {
            0% {
                text-shadow: 0 0 10px rgba(0, 247, 255, 0.7);
            }

            50% {
                text-shadow: 0 0 20px rgba(0, 247, 255, 0.9), 0 0 30px rgba(0, 247, 255, 0.5);
            }

            100% {
                text-shadow: 0 0 15px rgba(255, 0, 170, 0.7), 0 0 25px rgba(255, 0, 170, 0.5);
            }
        }

        .subtitle {
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 2rem;
            position: relative;
            z-index: 2;
            letter-spacing: 5px;
            font-family: var(--font-tech);
            text-transform: uppercase;
            background: linear-gradient(90deg, #00f7ff, #ff00aa, #00ff88);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--text-glow);
            padding: 0.5rem 1rem;
            display: inline-block;
            border: 1px solid rgba(0, 247, 255, 0.3);
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(0, 247, 255, 0.3),
                inset 0 0 10px rgba(0, 247, 255, 0.2);
            animation: subtitleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes subtitleGlow {
            0% {
                box-shadow: 0 0 20px rgba(0, 247, 255, 0.3),
                    inset 0 0 10px rgba(0, 247, 255, 0.2);
                text-shadow: var(--text-glow);
            }

            50% {
                box-shadow: 0 0 30px rgba(0, 247, 255, 0.5),
                    inset 0 0 15px rgba(0, 247, 255, 0.3);
                text-shadow: 0 0 25px rgba(0, 247, 255, 0.8);
            }

            100% {
                box-shadow: 0 0 20px rgba(255, 0, 170, 0.3),
                    inset 0 0 10px rgba(255, 0, 170, 0.2);
                text-shadow: 0 0 15px rgba(255, 0, 170, 0.5);
            }
        }

        .calculator {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 3rem;
            position: relative;
            z-index: 2;
        }

        @media (max-width: 768px) {
            .calculator {
                grid-template-columns: 1fr;
            }
        }

        .input-section,
        .result-section {
            background: var(--card-color);
            border-radius: 15px;
            padding: 2rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 247, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }






        /* 月光照射效果 - 左侧输入区 */
        .input-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 0% 0%, var(--moon-glow), transparent 70%);
            pointer-events: none;
            z-index: -1;
        }

        /* 阳光照射效果 - 右侧结果区 */
        .result-section::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 100% 0%, var(--sun-glow), transparent 70%);
            pointer-events: none;
            z-index: -1;
        }

        .input-section:hover,
        .result-section:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 247, 255, 0.2);
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            letter-spacing: 3px;
            font-family: var(--font-tech);
            text-shadow: var(--text-glow);
            animation: textGlow 3s infinite alternate;
        }

        .section-title svg {
            margin-right: 10px;
        }

        .input-group {
            margin-bottom: 1.5rem;
            position: relative;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            letter-spacing: 2px;
            text-shadow: var(--text-glow);
            font-family: var(--font-tech);
            transition: all 0.3s;
            position: relative;
            animation: textGlow 3s infinite alternate;
        }

        .input-group label:hover {
            color: var(--primary-color);
            text-shadow: var(--text-glow-hover);
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 12px 40px 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 247, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            transition: all 0.3s;
            appearance: textfield;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            font-family: var(--font-tech);
            letter-spacing: 2px;
            text-shadow: var(--text-glow);
        }

        .input-group input::-webkit-outer-spin-button,
        .input-group input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.7);
        }

        .input-group .unit {
            position: absolute;
            right: 20px;
            top: 38px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            pointer-events: none;
            font-family: var(--font-tech);
            text-shadow: var(--text-glow);
        }

        button {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: black;
            border: none;
            padding: 12px 25px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: none;
            transition: all 0.3s;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 1rem;
            width: 100%;
            font-family: var(--font-tech);
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.5);
            position: relative;
            overflow: hidden;
            text-shadow: var(--text-glow);
        }

        button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(to bottom right,
                    rgba(255, 255, 255, 0) 45%,
                    rgba(255, 255, 255, 0.8) 50%,
                    rgba(255, 255, 255, 0) 55%);
            transform: rotate(30deg);
            opacity: 0;
            transition: all 0.5s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 25px rgba(0, 247, 255, 0.8);
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-color));
            text-shadow: var(--text-glow-hover);
        }

        button:hover::before {
            opacity: 1;
            animation: buttonShine 1.5s ease-out forwards;
        }

        @keyframes buttonShine {
            0% {
                transform: translateX(-100%) translateY(-100%) rotate(30deg);
            }

            100% {
                transform: translateX(100%) translateY(100%) rotate(30deg);
            }
        }

        button svg {
            margin-right: 8px;
        }

        .result-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-left: 4px solid var(--primary-color);
        }

        .result-title {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: var(--primary-color);
            letter-spacing: 2px;
            font-family: var(--font-tech);
            text-shadow: var(--text-glow);
            animation: textGlow 3s infinite alternate;
        }

        .result-value {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 3px;
            font-family: var(--digital-font);
            text-shadow: var(--text-glow-hover);
            animation: digitalPulse 1s infinite alternate;
        }

        @keyframes digitalPulse {
            0% {
                text-shadow: 0 0 10px rgba(0, 247, 255, 0.7);
            }

            100% {
                text-shadow: 0 0 20px rgba(0, 247, 255, 0.9), 0 0 30px rgba(0, 247, 255, 0.5);
            }
        }

        .result-description {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            letter-spacing: 2px;
            font-family: var(--font-tech);
            text-shadow: var(--text-glow);
            animation: textGlow 3s infinite alternate;
        }

        .chart-container {
            height: 300px;
            margin-top: 1rem;
            position: relative;
        }

        .history-container {
            margin-top: 3rem;
        }

        .suggestions-container {
            margin-top: 3rem;
        }

        .comparison-container {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
        }

        .comparison-item {
            text-align: center;
            flex: 1;
            padding: 1rem;
        }

        .comparison-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 0.5rem 0;
            letter-spacing: 3px;
            font-family: var(--digital-font);
            text-shadow: var(--text-glow-hover);
            animation: digitalPulse 1s infinite alternate;
        }

        .comparison-label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 2px;
            font-family: var(--font-tech);
            text-shadow: var(--text-glow);
            animation: textGlow 3s infinite alternate;
        }

        .progress-bar {
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 5px;
            transition: width 1s ease-in-out;
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.5);
        }

        /*
        悬浮图标样式，隐藏在宇宙迷雾中的神秘信号源。
        当特定条件触发时，它们会缓缓浮现
        `transition: transform 0.5s, opacity 0.5s`：定义图标在变换和透明度变化时的过渡效果，持续时间为 0.5 秒，让出现和移动更加丝滑，如同星际跃迁一般流畅。
        */
        .floating-icon {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            transition: transform 0.5s, opacity 0.5s;
        }

        /*
           小MOSS的建议。eco：生态。
        2. `border-radius: 10px`：给卡片添加 10 像素的圆角，让卡片看起来更加柔和。
        3. `padding: 1rem`：在卡片内部添加 1 个单位的内边距，让内容与边框保持一定距离，避免拥挤。
        4. `margin: 1rem 0`：在卡片上下添加 1 个单位的外边距，使卡片之间有合适的间距，便于区分。
        5. `border-left: 4px solid var(--primary-color)`：在卡片左侧添加 4 像素宽的实线边框，颜色使用自定义变量，就像给信息面板加上醒目的标识条。
        6. `display: flex`：将卡片设置为弹性布局，方便内部元素的排列和对齐。
        7. `align-items: flex-start`：让卡片内的元素在交叉轴上沿起始位置对齐。
        8. `animation: fadeInUp 0.8s ease-out forwards`：为卡片添加淡入并向上移动的动画效果，持续时间 0.8 秒，动画结束后保持最终状态，就像信息面板从黑暗中缓缓升起。
        */
        .eco-tip {
            background: var(--card-color);
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid var(--primary-color);
            display: flex;
            align-items: flex-start;
            animation: fadeInUp 0.8s ease-out forwards;
        }

        /*
        h4；标题
        `animation: textGlow 3s infinite alternate`：为标题添加文字发光动画效果，持续时间 3 秒，无限循环，且每次循环结束时反向播放，就像标题在宇宙中闪烁着神秘的光芒。
        */
        .eco-tip-content h4 {
            color: var(--secondary-color);
            margin-bottom: 0.5rem;
            letter-spacing: 2px;
            font-family: var(--font-tech);
            text-shadow: var(--text-glow);
            animation: textGlow 3s infinite alternate;
        }

        /*p：段落(正文)*/
        .eco-tip-content p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            letter-spacing: 2px;
            font-family: var(--font-tech);
            text-shadow: var(--text-glow);
            animation: textGlow 3s infinite alternate;
        }

        footer {
            text-align: center;
            margin-top: 4rem;
            padding: 2rem 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 2;
            letter-spacing: 3px;
            font-family: var(--font-tech);
            text-transform: uppercase;
            background: linear-gradient(90deg, rgba(0, 247, 255, 0.1), rgba(255, 0, 170, 0.1), rgba(0, 255, 136, 0.1));
            backdrop-filter: blur(5px);
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 247, 255, 0.2);
        }

        footer p {
            margin: 0.5rem 0;
            text-shadow: var(--text-glow);
            position: relative;
            display: block;
            animation: textGlow 3s infinite alternate;
        }

        footer p:first-child {
            font-size: 1.2rem;
            letter-spacing: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--tertiary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(0, 247, 255, 0.3);
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(0, 247, 255, 0.3);
        }

        footer p:not(:first-child) {
            font-size: 0.9rem;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.8);
            padding: 0.3rem 0;
            transition: all 0.3s;
        }

        footer p:not(:first-child):hover {
            color: var(--primary-color);
            text-shadow: var(--text-glow-hover);
            transform: translateY(-2px);
        }

        /* 输入动画效果 */
        @keyframes inputGlow {
            0% {
                box-shadow: 0 0 5px rgba(0, 247, 255, 0);
            }

            50% {
                box-shadow: 0 0 20px rgba(0, 247, 255, 0.8);
            }

            100% {
                box-shadow: 0 0 5px rgba(0, 247, 255, 0);
            }
        }

        .glow-animation {
            animation: inputGlow 1.5s ease-in-out;
        }

        /* 结果出现动画 */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-up {
            animation: fadeInUp 0.8s ease-out forwards;
        }

        /* 流星动画 */
        @keyframes meteorFall {
            0% {
                transform: translateX(0) translateY(0);
                opacity: 1;
            }

            70% {
                opacity: 1;
            }

            100% {
                transform: translateX(1000px) translateY(500px);
                opacity: 0;
            }
        }

        /* 增强的星光特效 */
        .star-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 20px 8px var(--primary-color);
            animation: starParticle 1.2s ease-out forwards;
            filter: blur(1px);
            transform: translate(-50%, -50%) scale(0);
        }

        @keyframes starParticle {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0.8;
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5);
            }

            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        /* 标签点击效果 */
        .input-group label {
            cursor: none;
            transition: all 0.3s;
            position: relative;
        }

        .input-group label:hover {
            color: var(--primary-color);
            text-shadow: var(--text-glow-hover);
        }

        /* 增强的星光爆发特效 */
        .star-burst {
            position: absolute;
            width: 150px;
            height: 150px;
            pointer-events: none;
            z-index: 10;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(0, 247, 255, 0) 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            animation: starBurst 1.2s ease-out forwards;
            filter: blur(1px);
        }

        @keyframes starBurst {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0.9;
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5);
            }

            100% {
                transform: translate(-50%, -50%) scale(2.5);
                opacity: 0;
            }
        }

        /* 巨型流星特效 - 计算按钮触发 */
        .giant-meteor {
            position: fixed;
            width: 99px;
            height: 99px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 60px 20px var(--primary-color);
            opacity: 0;
            animation: giantMeteor 2s linear forwards;
            filter: blur(2px);
        }

        @keyframes giantMeteor {
            0% {
                transform: translate(-200px, -200px);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            100% {
                transform: translate(calc(100vw + 200px), calc(100vh + 200px));
                opacity: 0;
            }
        }

        /* 流星尾迹 */
        .meteor-trail {
            position: fixed;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-color), transparent);
            pointer-events: none;
            z-index: 99;
            transform-origin: left center;
            animation: meteorTrail 2s linear forwards;
            opacity: 0;
        }

        @keyframes meteorTrail {
            0% {
                opacity: 0;
                transform: scaleX(0);
            }

            10% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
                transform: scaleX(100);
            }
        }








        /*-----------这是自定义下拉菜单样式，原来有做一个下拉菜单的，但是效果太多了，就把这个给弃掉了，但是不敢乱删代码，怕删了之后，指不定哪里又会出问题，所以还是保留了 ----------*/




        /* 自定义下拉菜单样式 */
        .input-group select {
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="%2300f7ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>');
            background-repeat: no-repeat;
            background-position: right 15px center;
            background-size: 12px;
        }

        /* 下拉选项样式 - 科技感改造 */
        .input-group select option {
            background-color: var(--bg-color);
            color: white;
            font-family: var(--font-tech);
            padding: 10px;
            border-bottom: 1px solid rgba(0, 247, 255, 0.2);
        }

        /* 下拉菜单容器 - 科技感改造 */
        select {
            background: rgba(0, 0, 0, 0.5) !important;
            border: 1px solid rgba(0, 247, 255, 0.3) !important;
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.2) !important;
        }

        /* 响应式调整 */
        @media (max-width: 600px) {
            .container {
                padding: 1rem;
                margin-top: 120px;
            }

            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1.2rem;
                padding: 0.3rem 0.8rem;
            }

            .logo-container {
                height: 150px;
            }

            .input-section,
            .result-section {
                padding: 1.5rem;
            }

            .comparison-container {
                flex-direction: column;
            }

            .comparison-item {
                margin-bottom: 1rem;
            }

            #moon-container,
            #sun-container {
                width: 100px;
                height: 100px;
            }
        }

        /* 全屏样式 */
        body.fullscreen {
            overflow: hidden;
        }

        body.fullscreen .container,
        body.fullscreen header,
        body.fullscreen footer {
            display: none;
        }

        body.fullscreen #earth-container,
        body.fullscreen #moon-container,
        body.fullscreen #sun-container {
            z-index: 1000;
        }

        body.fullscreen #earth-container {
            width: 100vw;
            height: 100vh;
        }

        /* 数字科技感特效 */
        .tech-number {
            font-family: var(--digital-font);
            text-shadow: 0 0 15px rgba(0, 247, 255, 0.8);
            letter-spacing: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            position: relative;
            animation: digitalPulse 1s infinite alternate;
        }

        @keyframes numberPulse {
            0% {
                text-shadow: 0 0 10px rgba(0, 247, 255, 0.7);
            }

            100% {
                text-shadow: 0 0 20px rgba(0, 247, 255, 0.9);
            }
        }

        .tech-number::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.7);
        }

        .tech-number:hover::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        /* 增强的文字科技感 */
        .tech-text {
            text-shadow: var(--text-glow);
            letter-spacing: 2px;
            position: relative;
            display: inline-block;
            font-family: var(--font-tech);
            animation: textGlow 3s infinite alternate;
        }

        .tech-text::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, var(--primary-color), transparent);
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.5);
        }

        .tech-text:hover::after {
            transform: scaleX(1);
            transform-origin: left;
        }

        /* 数字字体动画 */
        @keyframes digitalFlicker {

            0%,
            19.999%,
            22%,
            62.999%,
            64%,
            64.999%,
            70%,
            100% {
                opacity: 1;
                text-shadow: 0 0 10px rgba(0, 247, 255, 0.7),
                    0 0 20px rgba(0, 247, 255, 0.5),
                    0 0 30px rgba(0, 247, 255, 0.3);
            }

            20%,
            21.999%,
            63%,
            63.999%,
            65%,
            69.999% {
                opacity: 0.8;
                text-shadow: none;
            }
        }

        .digital-flicker {
            animation: digitalFlicker 3s infinite;
        }

        /* 3D图表效果  */
        .chart-3d-effect {
            transform-style: preserve-3d;
            perspective: 1000px;
            position: relative;
            overflow: hidden;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 247, 255, 0.3);
        }

        .chart-3d-effect::before {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 0;
            width: 100%;
            height: 15px;
            background: linear-gradient(to bottom, rgba(0, 247, 255, 0.2), transparent);
            transform: rotateX(-60deg);
            transform-origin: top;
            filter: blur(5px);
            z-index: 1;
        }

        .chart-3d-effect::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 247, 255, 0.05), rgba(255, 0, 170, 0.05));
            z-index: -1;
        }

        /* 3D柱状图效果  */
        .bar-3d {
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(45deg) rotateY(0deg) rotateZ(0deg);
            transition: all 0.5s ease;
        }

        .bar-3d::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 20px;
            background: rgba(0, 247, 255, 0.2);
            transform: rotateX(-90deg);
            transform-origin: bottom;
            filter: blur(5px);
        }

        /* 3D线图效果 */
        .line-3d {
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(45deg) rotateY(0deg) rotateZ(0deg);
            transition: all 0.5s ease;
        }

        .line-3d::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(0, 247, 255, 0.2);
            transform: rotateX(-90deg);
            transform-origin: bottom;
            filter: blur(5px);
        }

        /* 图表动画效果 */
        @keyframes chartAppear {
            0% {
                opacity: 0;
                transform: translateY(50px) rotateX(60deg);
            }

            100% {
                opacity: 1;
                transform: translateY(0) rotateX(0);
            }
        }

        .chart-appear {
            animation: chartAppear 1.5s ease-out forwards;
        }

        /* 图表数据点动画 */
        @keyframes dataPointGlow {
            0% {
                box-shadow: 0 0 5px rgba(0, 247, 255, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(0, 247, 255, 0.9);
            }

            100% {
                box-shadow: 0 0 5px rgba(0, 247, 255, 0.5);
            }
        }

        .data-point {
            animation: dataPointGlow 2s infinite;
        }

        /* 球状闪电特效样式 */
        .ball-lightning {
            position: fixed;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            background: radial-gradient(circle at 40% 40%,
                    hsla(200, 100%, 80%, 0.9) 0%,
                    hsla(210, 100%, 60%, 0.7) 50%,
                    hsla(220, 100%, 40%, 0.3) 100%);
            box-shadow:
                0 0 30px 15px hsla(200, 100%, 70%, 0.6),
                0 0 60px 30px hsla(210, 100%, 50%, 0.3),
                0 0 90px 45px hsla(220, 100%, 30%, 0.1);
        }

        .emp-pulse {
            position: fixed;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: hsla(200, 100%, 80%, 0.5);
            box-shadow: 0 0 20px 10px hsla(200, 100%, 80%, 0.3);
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.5s ease-out, opacity 0.5s;
            opacity: 0;
            z-index: 9999;
        }
    </style>
    <style>
        /* 碰撞效果样式 */
        .shockwave-effect {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            will-change: transform, opacity;
        }

        .collision-particle {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            will-change: transform, opacity;
            transition: all 0.5s ease-out;
        }

        @keyframes collision-bounce {
            0% {
                transform: scale(1.5);
            }

            50% {
                transform: scale(0.8);
            }

            100% {
                transform: scale(1);
            }
        }

        .collision-bounce {
            animation: collision-bounce 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 鼠标环碰撞反馈样式 */
        .cursor-collision-feedback {
            animation: cursorCollision 0.3s ease-out;
        }

        @keyframes cursorCollision {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.5);
                filter: brightness(2) hue-rotate(90deg);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }


        .gradient-text {
            background:
                /* 主彩虹色带 - 丰富的色彩过渡 */
                linear-gradient(90deg,
                    rgba(255, 0, 0, 1) 0%,
                    rgba(255, 63, 0, 1) 7%,
                    rgba(255, 127, 0, 1) 14%,
                    rgba(255, 191, 0, 1) 21%,
                    rgba(255, 255, 0, 1) 28%,
                    rgba(191, 255, 0, 1) 35%,
                    rgba(0, 255, 0, 1) 42%,
                    rgba(0, 255, 127, 1) 49%,
                    rgba(0, 255, 255, 1) 56%,
                    rgba(0, 127, 255, 1) 63%,
                    rgba(0, 0, 255, 1) 70%,
                    rgba(75, 0, 130, 1) 77%,
                    rgba(138, 43, 226, 1) 84%,
                    rgba(216, 0, 255, 1) 91%,
                    rgba(255, 0, 0, 1) 100%) 0% 0% / 400% 400%,

                /* 粉色系渐变 - 中间色 */
                linear-gradient(135deg,
                    #FF00C8 0%,
                    #FF6EC7 12.5%,
                    #FF9A9E 25%,
                    #FFB7B2 37.5%,
                    #FAD0C4 50%,
                    #FFE4E1 62.5%,
                    #FFD3E0 75%,
                    #FFB6C1 87.5%,
                    #FF6EC7 100%) 0% 0% / 350% 350%,

                /* 蓝绿色系渐变 - 平滑过渡 */
                linear-gradient(45deg,
                    #00FFD1 0%,
                    #84FAB0 12.5%,
                    #8FD3F4 25%,
                    #A1C4FD 37.5%,
                    #B5CCFD 50%,
                    #C2E9FB 62.5%,
                    #D4F1FB 75%,
                    #E0F7FA 87.5%,
                    #84FAB0 100%) 0% 0% / 300% 300%,

                /* 金色到蓝色的径向渐变 - 增加色点 */
                radial-gradient(circle at 50% 50%,
                    #FFD700 0%,
                    #FFF600 10%,
                    #FFEE00 20%,
                    #33b3ca 30%,
                    #00B4D8 40%,
                    #1672b8 50%,
                    #37b5d5 60%,
                    #0096C7 70%,
                    #1563b7 80%,
                    #023E8A 90%,
                    #03045E 100%) 50% 50% / 200% 200%;

            background-blend-mode: overlay, soft-light, hard-light, color-dodge;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            animation:
                rainbowFlow 12s ease-in-out infinite,
                pulseGlow 8s ease-in-out infinite alternate;
            filter:
                brightness(1.15) saturate(1.3) drop-shadow(0 0 2px rgba(255, 255, 255, 0.3));
        }

        @keyframes rainbowFlow {
            0% {
                background-position: 0% 50%, 0% 50%, 0% 50%, 50% 50%;
            }

            50% {
                background-position: 100% 50%, 100% 50%, 100% 50%, 50% 50%;
            }

            100% {
                background-position: 0% 50%, 0% 50%, 0% 50%, 50% 50%;
            }
        }

        @keyframes pulseGlow {
            0% {
                filter: brightness(1.15) saturate(1.3) drop-shadow(0 0 2px rgba(255, 255, 255, 0.3));
            }

            100% {
                filter: brightness(1.25) saturate(1.5) drop-shadow(0 0 6px rgba(255, 255, 255, 0.6));
            }
        }
    </style>


    <!-- 样式部分 -->
    <style>
        /* 太空画布 - 我们的星际剧场 */
        #space {
            position: fixed;
            /* 固定定位，不受滚动影响 */
            top: 0;
            left: 0;
            width: 100%;
            /* 占据整个视口 */
            height: 100%;
            pointer-events: none;
            /* 允许点击穿透 - 太空不应该阻挡交互 */
        }

        /* 恒星样式 - 灵感来自《银河系漫游指南》中的描述 */
        .star {
            position: absolute;
            /* 绝对定位，可以在太空中自由放置 */
            background-color: #fff;
            /* 默认白色，但会通过闪烁动画变化 */
            border-radius: 50%;
            /* 完美的圆形 - 就像真实恒星 */
            pointer-events: none;
            /* 不干扰鼠标事件 */
        }

        /* 星轨效果 - 参考《星际穿越》中的高速穿越场景 */
        .star-trail {
            position: absolute;
            /* 渐变色模拟相对论效应下的星光拖尾 */
            background: linear-gradient(to right,
                    rgba(255, 255, 255, 0.9) 0%,
                    /* 高亮头部 */
                    rgba(200, 230, 255, 0.7) 30%,
                    /* 蓝移效应 */
                    rgba(150, 200, 255, 0.5) 60%,
                    /* 多普勒效应衰减 */
                    transparent 100%);
            /* 融入黑暗太空 */
            height: 1px;
            /* 细线效果 */
            transform-origin: left center;
            /* 从左侧中心旋转 */
            pointer-events: none;
        }

        /* 曲率光束 */
        .warp-beam {
            position: absolute;
            /* 蓝青色渐变模拟反物质能量流 */
            background: linear-gradient(to right,
                    rgba(0, 255, 255, 0.9) 0%,
                    /* 高能正电子流 */
                    rgba(50, 150, 255, 0.8) 20%,
                    /* 等离子体冷却 */
                    rgba(100, 0, 255, 0.7) 40%,
                    /* 曲率场边缘 */
                    rgba(150, 0, 200, 0.5) 60%,
                    /* 时空扭曲区 */
                    transparent 100%);
            /* 融入背景 */
            height: 2px;
            /* 比星轨稍粗 */
            transform-origin: left center;
            pointer-events: none;
            box-shadow: 0 0 15px 3px rgba(100, 200, 255, 0.7);
            /* 能量辉光 */
            filter: blur(0.5px);
            /* 轻微模糊模拟光晕 */
        }

        /* 高能粒子  */
        .particle {
            position: absolute;
            border-radius: 50%;
            /* 圆形粒子 */
            pointer-events: none;
            /* 粒子核心到边缘的渐变 */
            background: radial-gradient(circle,
                    rgba(180, 240, 255, 0.95) 0%,
                    /* 高能核心 */
                    rgba(80, 160, 255, 0.8) 30%,
                    /* 等离子体外层 */
                    rgba(50, 100, 200, 0.6) 60%,
                    /* 冷却中的粒子 */
                    transparent 100%);
            /* 完全冷却 */
            box-shadow: 0 0 5px 1px rgba(100, 200, 255, 0.5);
            /* 粒子辉光 */
            filter: blur(0.3px);
            /* 轻微模糊 */
        }

        /* 能量光晕 - 类似《光环》中的跃迁入口效果 */
        .glow {
            position: absolute;
            border-radius: 50%;
            /* 圆形光晕 */
            pointer-events: none;
            /* 能量场渐变 */
            background: radial-gradient(circle,
                    rgba(100, 200, 255, 0.4) 0%,
                    /* 强能量区 */
                    rgba(50, 100, 200, 0.2) 50%,
                    /* 能量衰减 */
                    transparent 80%);
            /* 融入太空 */
        }
    </style>



</head>

<body style="overflow-x: hidden; overflow-y: auto">
    <div id="fullscreenPrompt"
        style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);color:white;display:flex;justify-content:center;align-items:center;flex-direction:column;z-index:9999;">
        <h2>点击任意处进入全屏</h2>
        <p>为最佳体验，请全屏浏览</p>
    </div>
    <script>
        document.getElementById('fullscreenPrompt').addEventListener('click', function () {
            try {
                enterFullscreen();
                this.style.display = 'none';
            } catch (e) {
                console.log('全屏错误:', e);
                this.innerHTML = '<h2>全屏失败</h2><p>' + e.message + '</p>';
            }
        });
    </script>



    <!-- 自定义鼠标指针 -->
    <div class="custom-cursor" id="custom-cursor">
        <div class="cursor-core"></div>
        <div class="cursor-ring"></div>
    </div>

    <!-- 鼠标尾迹效果 -->
    <div id="cursor-trails"></div>



    <!--鼠标中键太空特效-->
    <div id="space"></div>


    <!-- 3D地球容器 -->
    <div id="earth-container"></div>

    <!-- 月亮容器 -->
    <div id="moon-container"></div>

    <!-- 太阳容器 -->
    <div id="sun-container"></div>

    <!-- 水滴容器 -->
    <div id="waterdrop-container">
        <div id="waterdrop"></div>
        <div id="hint-text"></div>
    </div>


    <!-- 流星雨背景 -->
    <div id="meteors-container"></div>

    <!-- 星光背景 -->
    <div id="stars-container"></div>

    <div class="container">
        <header>
            <div class="logo-container">
                <h1>ETO</h1>
            </div>
            <p class="subtitle">地球三体组织分支-科幻程度鉴定中心</p>
        </header>

        <div class="calculator">
            <div class="input-section">
                <h2 class="section-title">
                    <label for="gas"></label>
                    <path
                        d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z">
                    </path>
                    <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                    <line x1="12" y1="22.08" x2="12" y2="12"></line>
                    </svg>
                    不要回答！不要回答！不要回答！！！
                </h2>

                <div class="input-group">
                    <label style="color: rgba(218, 205, 27, 0.7);" for="electricity">对三体的忠诚度 | 毁灭你 与你有何干 | 主不在乎</label>
                    <input type="number" id="electricity" placeholder="消灭人类暴政 世界属于三体" min="0" step="10" value="">
                    <span class="unit">地狱彼方</span>
                </div>

                <div class="input-group">
                    <label style="color: rgba(64, 159, 231, 0.77);" for="gas">对地球的留恋度 | 我爱你 与你有何干 | 不要返航</label>
                    <input type="number" id="gas" placeholder="虫子从未战胜 人类荣光永存" min="0" step="10" value="">
                    <span class="unit">铭刻信仰</span>
                </div>

                <div class="input-group">
                    <label style="color: rgba(148, 200, 211, 0.7);" for="car">对宇宙的憧憬度</label>
                    <input type="number" id="car" placeholder="最孤独的坚守 最幸福的追求" min="0" step="50" value="">
                    <span class="unit">夕死不枉</span>
                </div>

                <div class="input-group">
                    <label style="color: rgba(187, 101, 224, 0.77);" for="flight">对生命的哲思度</label>
                    <input type="number" id="flight" placeholder="最满意的一生 最无悔的选择" min="0" step="100" value="">
                    <span class="unit">尽是虚妄</span>
                </div>



                <div class="input-group">
                    <label style="color: rgba(239, 124, 93, 0.7);" for="flight">对自我的存在感</label>
                    <input type="number" id="flight" placeholder="渺小微若蜉蝣 仰望满载星海" min="0" step="100" value="">
                    <span class="unit">紧握希望</span>
                </div>



                <div class="input-group">
                    <label style="color: rgba(224, 34, 135, 0.7);" for="flight">对自由的牺牲感</label>
                    <input type="number" id="flight" placeholder="无法放弃之人 无法改变何物" min="0" step="100" value="">
                    <span class="unit">泣血新生</span>
                </div>

                <div class="input-group">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <input type="number" id="waste" placeholder="输入每周废弃物量" min="0" step="1" value="">
                        <span class="unit"></spanut>
                </div>


                <button id="calculate-btn">
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                    </svg>
                    最新AI-小苔藓MOSS-量子计算·数据分析
                </button>
            </div>

            <div class="result-section">
                <h2 class="section-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
                    </svg>
                    回答数据-宇宙广播-量子坍缩显像
                </h2>

                <div id="result-container" style="display: none;">
                    <div class="result-card">
                        <h3 class="result-title">此生命体脑波的科幻曲率驱动值</h3>
                        <div class="result-value tech-number digital-flicker" id="carbon-footprint">0.00</div>
                        <div class="result-description tech-text">此硅基体神经网络的科幻共振频率</div>

                        <div class="progress-bar">
                            <div class="progress-fill" id="carbon-progress" style="width: 0%"></div>
                        </div>

                        <div class="comparison-container">
                            <div class="comparison-item">
                                <div class="comparison-label tech-text">你的科幻</div>
                                <div class="comparison-value tech-number digital-flicker" id="user-emission">0.00</div>
                                <div class="comparison-label tech-text">曲率驱动值</div>
                            </div>
                            <div class="comparison-item">
                                <div class="comparison-label tech-text">全国平均</div>
                                <div class="comparison-value tech-number digital-flicker" id="avg-emission">4951.4</div>
                                <div class="comparison-label tech-text">曲率驱动值</div>
                            </div>
                            <div class="comparison-item">
                                <div class="comparison-label tech-text">全球平均</div>
                                <div class="comparison-value tech-number digital-flicker">6955</div>
                                <div class="comparison-label tech-text">曲率驱动值</div>
                            </div>
                        </div>
                    </div>

                    <div class="chart-container chart-3d-effect">
                        <canvas id="comparison-chart"></canvas>
                    </div>
                </div>

                <div id="no-result" style="text-align: center; padding: 2rem;">
                    <p style="color: rgba(218, 205, 27, 0.7);" class="tech-text">恒乱纪元规律难读</p><br>
                    <p style="color: rgba(218, 205, 27, 0.7);" class="tech-text">仍有文明不灭灯烛</p><br>
                    <p style="color: rgba(218, 205, 27, 0.7);" class="tech-text">不甘苟活于此桎梏</p><br>
                    <p style="color: rgba(218, 205, 27, 0.7);" class="tech-text">背负生存何曾屈服</p>
                    <br><br>
                    <p style="color: rgba(64, 159, 231, 0.77);" class="tech-text">永别啊 我曾凝望</p><br>
                    <p style="color: rgba(64, 159, 231, 0.77);" class="tech-text">曾是航向的日出</p><br>
                    <p style="color: rgba(64, 159, 231, 0.77);" class="tech-text">末路残烛</p><br>
                    <p style="color: rgba(64, 159, 231, 0.77);" class="tech-text">容我吹熄 藏起火种</p><br>
                    <p style="color: rgba(64, 159, 231, 0.77);" class="tech-text">向宇宙远渡</p>
                    <br><br>
                    <p style="color: rgba(148, 200, 211, 0.7);" class="tech-text">一粒尘埃何必全都明白</p><br>
                    <p style="color: rgba(148, 200, 211, 0.7);" class="tech-text">宇宙尽头一片无穷星海</p>
                    <br><br>
                    <p style="color: rgba(187, 101, 224, 0.77);" class="tech-text">让死亡觊觎我</p><br>
                    <p style="color: rgba(187, 101, 224, 0.77);" class="tech-text">让恐惧亲吻我</p><br>
                    <p style="color: rgba(187, 101, 224, 0.77);" class="tech-text">来摧毁我深爱的一切</p><br>
                    <p style="color: rgba(187, 101, 224, 0.77);" class="tech-text">可仍夺不走我的选择</p>
                    <br><br>
                    <p style="color: rgba(239, 124, 93, 0.7);" class="tech-text">捱过破碎过程</p><br>
                    <p style="color: rgba(239, 124, 93, 0.7);" class="tech-text">让我重获新生</p>
                    <br><br>
                    <p style="color: rgba(219, 19, 29, 0.7);" class="tech-text">若不活出自我</p><br>
                    <p style="color: rgba(219, 19, 29, 0.7);" class="tech-text">怎对得起</p><br>
                    <p style="color: rgba(219, 19, 29, 0.7);" class="tech-text">牺牲一切</p><br>
                    <p style="color: rgba(219, 19, 29, 0.7);" class="tech-text">换来的自由</p>


                </div>
            </div>
        </div>

        <div class="history-container" id="history-section" style="display: none;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="22 12 16 12 14 15 10 9 8 12 2 12"></polyline>
                </svg>
                曲率驱动·变化曲线
                </h2>
                <div class="chart-container chart-3d-effect">
                    <canvas id="history-chart"></canvas>
                </div>
        </div>

        <div class="suggestions-container" id="suggestions-section" style="display: none;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                </svg>
                智子降临·MOSS忠告
                </h2>

                <div id="suggestions-list"></div>

        </div>
    </div>
    </div>

    <footer class="cosmic-footer">
        <div class="starfield-bg"></div>
        <div class="cosmic-glow"></div>
        <div class="footer-content">
            <p class="cosmic-text" ,data-text="@ 星梦游Xmy | 流浪地球"><span id="triggerXmy" style="cursor: pointer;">@
                    星梦游Xmy</span> | <span id="triggerEarth" style="cursor: pointer;">流浪地球·三体</span></p>
            <p class="cosmic-text" ,data-text="我是星 利剑开刃寒光锋芒的银星 绝不消隐">我是星 利剑开刃寒光锋芒的银星 绝不消隐</p>
            <p class="cosmic-text" ,data-text="不回顾 永难再折返的故园的光阴 决意前进">不回顾 永难再折返的故园的光阴 决意前进</p>
            <p class="cosmic-text" ,data-text="我是星 利剑开刃寒光锋芒的银星 绝不消隐"><a href="README.html">README-LIMITLESS<a href="mind-map-V2.html">&nbsp;&nbsp;&nbsp;mindMap</p>
        </div>
        <div class="space-particles"></div>
    </footer>




    <script>
        // 获取太空画布元素 - 我们的宇宙剧场
        const space = document.getElementById('space');

        // 中键状态跟踪 - 用于持续曲速航行效果
        let isMiddleMouseDown = false;

        // 创建背景恒星 - 致敬《银河系漫游指南》中的"几乎无害"宇宙
        function createStars() {
            // 生成500颗恒星 - 足够形成一个星域
            for (let i = 0; i < 500; i++) {
                // 创建恒星DOM元素
                const star = document.createElement('div');
                star.className = 'star';

                // 随机大小 (0.3px - 2.3px) - 模拟不同光度的恒星
                const size = Math.random() * 2 + 0.3;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;

                // 随机位置 - 均匀分布在视口中
                star.style.left = `${Math.random() * 100}vw`;
                star.style.top = `${Math.random() * 100}vh`;

                // 随机亮度 (0.2 - 1.0) - 模拟不同距离的恒星
                star.style.opacity = Math.random() * 0.8 + 0.2;

                // 50%的恒星会闪烁 - 就像真实星空中的脉动变星
                if (Math.random() > 0.5) {
                    // 随机闪烁周期 (2-5秒)和最终亮度
                    star.style.animation = `twinkle ${Math.random() * 3 + 2}s infinite alternate`;
                }

                // 将恒星添加到太空画布
                space.appendChild(star);
            }

            // 创建CSS动画 - 恒星的"心跳"
            const style = document.createElement('style');
            style.textContent = `
                @keyframes twinkle {
                    0% { opacity: 0.2; }  /* 最小亮度 */
                    100% { opacity: ${Math.random() * 0.7 + 0.3}; }  /* 随机最大亮度 */
                }
            `;
            document.head.appendChild(style);
        }

        // 创建曲速航行特效 - 参考《星际迷航》的曲速引擎视觉效果
        function createWarpEffect(x, y) {
            // 清除旧的特效 - 防止内存泄漏
            const oldEffects = document.querySelectorAll('.star-trail, .warp-beam, .particle, .glow');
            oldEffects.forEach(el => el.remove());

            // 创建中心光晕 - 曲速泡的核心
            const centerGlow = document.createElement('div');
            centerGlow.className = 'glow';
            centerGlow.style.left = `${x - 50}px`;  /* 居中定位 */
            centerGlow.style.top = `${y - 50}px`;
            centerGlow.style.width = '100px';
            centerGlow.style.height = '100px';
            space.appendChild(centerGlow);

            // 光晕扩散动画 - 模拟曲速泡形成
            setTimeout(() => {
                centerGlow.style.transition = 'all 0.8s ease-out';
                centerGlow.style.width = '200px';  /* 膨胀 */
                centerGlow.style.height = '200px';
                centerGlow.style.left = `${x - 100}px`;  /* 保持居中 */
                centerGlow.style.top = `${y - 100}px`;
                centerGlow.style.opacity = '0';  /* 淡出 */

                // 动画结束后移除元素
                setTimeout(() => centerGlow.remove(), 800);
            }, 50);  /* 延迟50ms开始，让光晕有出现的时间 */

            // 创建星轨效果 - 模拟高速运动时的星光拖尾
            for (let i = 0; i < 100; i++) {
                const trail = document.createElement('div');
                trail.className = 'star-trail';
                trail.style.left = `${x}px`;  /* 从点击点发出 */
                trail.style.top = `${y}px`;
                trail.style.width = `${Math.random() * 200 + 100}px`;  /* 随机长度 */
                trail.style.opacity = Math.random() * 0.5 + 0.1;  /* 半透明 */

                // 随机角度 - 全方位放射
                const angle = Math.random() * Math.PI * 2;
                trail.style.transform = `rotate(${angle}rad)`;

                // 随机延迟 - 错开出现时间
                trail.style.transitionDelay = `${Math.random() * 300}ms`;

                space.appendChild(trail);

                // 星轨动画 - 延伸并淡出
                setTimeout(() => {
                    trail.style.transition = 'opacity 1.5s ease-out, width 1.5s ease-out';
                    trail.style.opacity = '0';  /* 淡出 */
                    trail.style.width = `${parseInt(trail.style.width) + 100}px`;  /* 延伸 */

                    // 动画结束后移除
                    setTimeout(() => trail.remove(), 1500);
                }, 100);
            }

            // 创建曲率光束 - 模拟时空扭曲
            for (let i = 0; i < 20; i++) {
                const beam = document.createElement('div');
                beam.className = 'warp-beam';
                beam.style.left = `${x}px`;
                beam.style.top = `${y}px`;
                beam.style.width = `${Math.random() * 500 + 300}px`;  /* 长光束 */

                // 随机角度 - 但比星轨更集中
                const angle = Math.random() * Math.PI * 2;
                beam.style.transform = `rotate(${angle}rad)`;

                // 随机粗细 - 模拟能量波动
                beam.style.height = `${Math.random() * 2 + 0.5}px`;

                space.appendChild(beam);

                // 光束动画 - 延伸并消失
                setTimeout(() => {
                    beam.style.transition = 'opacity 0.8s ease-out, width 0.8s ease-out';
                    beam.style.opacity = '0';
                    beam.style.width = `${parseInt(beam.style.width) + 400}px`;

                    setTimeout(() => beam.remove(), 800);
                }, 100);
            }

            // 创建高能粒子 - 模拟曲速引擎排放的等离子体
            for (let i = 0; i < 300; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const size = Math.random() * 4 + 1;  /* 小尺寸粒子 */
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;

                // 随机蓝青色调 - 模拟正电子流
                const hue = Math.random() * 60 + 180;  /* 180-240度色相 */
                const saturation = Math.random() * 30 + 70;  /* 高饱和度 */
                particle.style.background = `radial-gradient(circle, 
                    hsla(${hue}, ${saturation}%, 80%, 0.9) 0%,  /* 核心 */
                    hsla(${hue + Math.random() * 20 - 10}, ${saturation}%, 60%, 0.7) 50%,
                    hsla(${hue + Math.random() * 30 - 15}, ${saturation - 20}%, 40%, 0.4) 80%,
                    transparent 100%)`;

                // 随机运动参数
                const angle = Math.random() * Math.PI * 2;  /* 任意方向 */
                const distance = Math.random() * 300 + 150;  /* 飞行距离 */
                const duration = Math.random() * 2000 + 500;  /* 持续时间 */

                space.appendChild(particle);

                // 粒子动画 - 飞散并消失
                setTimeout(() => {
                    particle.style.transition = `left ${duration}ms ease-out, top ${duration}ms ease-out, opacity ${duration}ms ease-out`;
                    particle.style.left = `${x + Math.cos(angle) * distance}px`;
                    particle.style.top = `${y + Math.sin(angle) * distance}px`;
                    particle.style.opacity = '0';

                    setTimeout(() => particle.remove(), duration);
                }, 100);
            }

            // 创建彩色粒子层 - 模拟二次辐射效应
            for (let i = 0; i < 150; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const size = Math.random() * 3 + 0.5;  /* 更小的粒子 */
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;

                // 全色相随机 - 模拟不同能量的辐射
                const hue = Math.random() * 360;
                particle.style.background = `radial-gradient(circle, 
                    hsla(${hue}, 80%, 70%, 0.8) 0%, 
                    hsla(${hue + 30}, 70%, 60%, 0.6) 50%,
                    hsla(${hue + 60}, 60%, 50%, 0.3) 80%,
                    transparent 100%)`;

                // 更远的飞行距离
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 400 + 100;
                const duration = Math.random() * 2500 + 500;

                space.appendChild(particle);

                // 动画
                setTimeout(() => {
                    particle.style.transition = `left ${duration}ms ease-out, top ${duration}ms ease-out, opacity ${duration}ms ease-out`;
                    particle.style.left = `${x + Math.cos(angle) * distance}px`;
                    particle.style.top = `${y + Math.sin(angle) * distance}px`;
                    particle.style.opacity = '0';

                    setTimeout(() => particle.remove(), duration);
                }, 100);
            }
        }

        // 鼠标中键事件 - 启动曲速引擎！
        document.addEventListener('mousedown', (e) => {
            if (e.button === 1) {  // 中键
                isMiddleMouseDown = true;
                createWarpEffect(e.clientX, e.clientY);
                e.preventDefault();  // 防止默认中键滚动行为
            }
        });

        // 鼠标移动事件 - 持续曲速航行
        document.addEventListener('mousemove', (e) => {
            if (isMiddleMouseDown) {
                createWarpEffect(e.clientX, e.clientY);
            }
        });

        // 鼠标释放事件 - 退出曲速
        document.addEventListener('mouseup', (e) => {
            if (e.button === 1) {
                isMiddleMouseDown = false;
            }
        });

        // 触摸屏支持 - 让移动设备也能体验星际航行
        document.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            createWarpEffect(touch.clientX, touch.clientY);
        });

        document.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            createWarpEffect(touch.clientX, touch.clientY);
        });

        // 初始化宇宙 - 启动程序！
        createStars();
    </script>
    <style>
        /* 宇宙科幻风格footer */
        .cosmic-footer {
            position: relative;
            text-align: center;
            margin-top: 4rem;
            padding: 3rem 0;
            overflow: hidden;
            background: linear-gradient(180deg,
                    rgba(0, 0, 20, 0.8) 0%,
                    rgba(0, 10, 40, 0.9) 50%,
                    rgba(0, 20, 60, 1) 100%);
            border-top: 1px solid rgba(0, 247, 255, 0.3);
            border-bottom: 1px solid rgba(0, 247, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 247, 255, 0.2);
            z-index: 10;
        }

        /* 星空背景 */
        .starfield-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(2px 2px at 20px 30px, rgba(255, 255, 255, 0.9), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 40px 70px, rgba(255, 255, 255, 0.8), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 50px 160px, rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0)),
                radial-gradient(3px 3px at 120px 10px, rgba(255, 255, 255, 0.8), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 140px 200px, rgba(255, 255, 255, 0.9), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 200px 180px, rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 250px 50px, rgba(255, 255, 255, 0.8), rgba(0, 0, 0, 0)),
                radial-gradient(2px 2px at 300px 100px, rgba(255, 255, 255, 0.9), rgba(0, 0, 0, 0));
            background-repeat: repeat;
            background-size: 400px 400px;
            animation: starfield-rotate 240s linear infinite;
            opacity: 0.6;
            z-index: -2;
        }

        @keyframes starfield-rotate {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 400px 400px;
            }
        }

        /* 宇宙辉光 */
        .cosmic-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 120%;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse at center,
                    rgba(0, 247, 255, 0.15) 0%,
                    rgba(0, 100, 255, 0.1) 40%,
                    rgba(0, 0, 100, 0.05) 60%,
                    transparent 80%);
            z-index: -1;
            animation: cosmic-pulse 8s ease-in-out infinite alternate;
        }

        @keyframes cosmic-pulse {
            0% {
                opacity: 0.5;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        /* 内容容器 */
        .footer-content {
            position: relative;
            z-index: 2;
        }

        /* 科幻文字样式 */
        .cosmic-text {
            position: relative;
            font-family: 'Orbitron', 'KaiTi', 'STKaiti', '楷体', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 2px;
            margin: 1.5rem 0;
            color: rgba(255, 255, 255, 0.9);
            text-shadow:
                0 0 5px rgba(0, 247, 255, 0.7),
                0 0 10px rgba(0, 247, 255, 0.5);
            animation: text-flicker 5s linear infinite;
        }

        /* 文字闪烁 */
        @keyframes text-flicker {

            0%,
            19.999%,
            22%,
            62.999%,
            64%,
            64.999%,
            70%,
            100% {
                opacity: 1;
                text-shadow:
                    0 0 5px rgba(0, 247, 255, 0.7),
                    0 0 10px rgba(0, 247, 255, 0.5);
            }

            20%,
            21.999%,
            63%,
            63.999%,
            65%,
            69.999% {
                opacity: 0.8;
                text-shadow: none;
            }
        }

        /* 悬停 */
        .cosmic-text:hover {
            color: #00f7ff;
            text-shadow:
                0 0 5px rgba(0, 247, 255, 0.9),
                0 0 10px rgba(0, 247, 255, 0.7),
                0 0 15px rgba(0, 247, 255, 0.5);
            animation: text-glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes text-glow {
            0% {
                text-shadow:
                    0 0 5px rgba(0, 247, 255, 0.9),
                    0 0 10px rgba(0, 247, 255, 0.7),
                    0 0 15px rgba(0, 247, 255, 0.5);
            }

            100% {
                text-shadow:
                    0 0 10px rgba(0, 247, 255, 0.9),
                    0 0 20px rgba(0, 247, 255, 0.7),
                    0 0 30px rgba(0, 247, 255, 0.5);
            }
        }

        /* 文字扫描线 */
        .cosmic-text::before {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom,
                    transparent 0%,
                    rgba(0, 247, 255, 0.3) 50%,
                    transparent 100%);
            background-size: 100% 100%;
            background-repeat: no-repeat;
            animation: scan-line 4s linear infinite;
            z-index: -1;
            opacity: 0;
        }

        @keyframes scan-line {
            0% {
                background-position: 0 -100%;
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                background-position: 0 200%;
                opacity: 0;
            }
        }

        /* 第一行特殊样式 */
        .cosmic-text:first-child {
            font-size: 1.4rem;
            background: linear-gradient(90deg, #00f7ff, #ff00aa, #00ff88);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: cosmic-gradient 8s ease infinite;
        }

        @keyframes cosmic-gradient {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        /* 空间粒子效果 */
        .space-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }

        /* 响应式调整 */
        @media (max-width: 768px) {
            .cosmic-text {
                font-size: 1rem;
                letter-spacing: 1px;
            }

            .cosmic-text:first-child {
                font-size: 1.2rem;
            }
        }

        .wandering-image {
            display: none;
            position: fixed;
            top: 50%;
            left: -300px;
            /* Default start, adjust if actual image width is different, should be <= -width */
            width: 300px;
            /* Example width, adjust as needed for both images */
            height: auto;
            transform: translateY(-50%);
            z-index: 10000;
            /* Ensure it's on top of other elements */
            opacity: 0;
            /* Start fully transparent */
        }

        .wandering-image.animate {
            display: block;
            /* Show when animating */
            animation: wanderAndFade 10s linear forwards;
        }

        @keyframes wanderAndFade {
            0% {
                left: -300px;
                /* Start off-screen left (should match .wandering-image left for consistency) */
                opacity: 0;
                /* Start transparent */
            }

            10% {
                /* Fade in complete (1s into 10s animation) */
                left: -300px;
                /* Stay at starting position during fade-in */
                opacity: 1;
            }

            90% {
                /* Movement complete, about to fade out (9s into 10s animation) */
                left: 100vw;
                /* Image's left edge is at the right viewport edge */
                opacity: 1;
            }

            100% {
                /* Fade out complete (10s) */
                left: 100vw;
                opacity: 0;
            }
        }
    </style>



    <img id="wanderingEarthImage" class="wandering-image" src="dimensionality-reduction.jpg"
        alt="Wandering Earth Image">
    <img id="xmyImage" class="wandering-image" src="alone-star.jpg" alt="Xmy Image">
    <img id="erenYeagerImage" class="wandering-image cosmic-traveler" src="Eren-Yeager.jpg" alt="Eren Yeager Image">
    <img id="starYourselfImage" class="wandering-image cosmic-traveler" src="star-yourself.jpg"
        alt="Star Yourself Image">








    <script>

        // 阻止默认的中键上下文菜单
        document.addEventListener('contextmenu', function (event) {
            if (event.button === 1) {
                event.preventDefault();
            }
        });
        // 针对某些特殊情况（如文本选中后等）额外处理
        document.addEventListener('mousedown', function (event) {
            if (event.button === 1) {
                event.preventDefault();
            }
        });
        document.addEventListener('mouseup', function (event) {
            if (event.button === 1) {
                event.preventDefault();
            }
        });





        // ======================
        // footer.js
        // 空间粒子与动画效果实现
        // ======================

        // 1. 页面加载完成后，初始化空间粒子和文字动画
        document.addEventListener('DOMContentLoaded', function () {
            // 获取粒子容器元素（.space-particles）
            const particlesContainer = document.querySelector('.space-particles');
            // 获取底部footer的尺寸信息，用于限定粒子活动范围
            const footerRect = document.querySelector('.cosmic-footer').getBoundingClientRect();

            // 2. 创建111个粒子
            //“妈妈，我将变成萤火虫”
            for (let i = 0; i < 111; i++) {
                createParticle(particlesContainer, footerRect.width, footerRect.height);
            }

            // 3. 文字扫描线动画增强
            //    选中所有带.cosmic-text类的元素
            const cosmicTexts = document.querySelectorAll('.cosmic-text');
            cosmicTexts.forEach((text, index) => {
                // 3.1 让每个文字的动画延迟不同，错开出现，视觉更有层次感
                // 1. 科幻世界里的星际舰队依次起航，每艘飞船都有自己的出发间隔。
                // 2. `'animation-delay'`：这个就是要设置的CSS属性名，它控制着动画开始前的延迟时间。就好比星际舰队准备出发前的倒计时，每个飞船的倒计时时长不一样。
                // 3. `${index * 1.5}s`：这是一个模板字符串，`index`是一个变量，代表着飞船的序号或者说是文本元素的索引。
                //    用`index`乘以1.5秒，就得到了每艘“飞船”（文本元素）的动画延迟时间。这样每个文本元素的动画就会依次延迟开始，就像舰队依次升空一样酷炫！
                text.style.setProperty('animation-delay', `${index * 1.5}s`);

                // 3.2 鼠标悬停时，文字微微上移，增加交互感
                text.addEventListener('mouseenter', function () {
                    this.style.transform = 'translateY(-6px)';
                    this.style.transition = 'transform 0.2s ease';
                });

                // 3.3 鼠标移出时，文字回到原位
                text.addEventListener('mouseleave', function () {
                    this.style.transform = 'translateY(0)';
                });
            });
        });


        // =====================
        // footer萤火虫粒子.js，创建单个粒子的函数
        // =====================
        function createParticle(container, width, height) {
            // 1. 创建一个div作为粒子
            const particle = document.createElement('div');

            // 2. 随机生成粒子的大小和初始位置
            //    - size: 粒子的直径，1~4像素之间，模拟星尘的大小差异
            //    - startX, startY: 粒子在容器内的随机初始坐标
            const size = Math.random() * 3 + 1;
            const startX = Math.random() * width;
            const startY = Math.random() * height;

            // 3. 随机生成粒子的速度和方向
            //    - speedX, speedY: 速度分量，正负都有，保证粒子能向任意方向漂移
            //    - duration: 粒子存活的时间，10~30秒，模拟宇宙中星尘的缓慢漂移
            const speedX = (Math.random() - 0.5) * 2;
            const speedY = (Math.random() - 0.5) * 2;
            const duration = Math.random() * 20 + 10;

            // 4. 设置粒子的样式
            //    - 绝对定位，圆形，带有发光阴影，颜色随机
            particle.style.position = 'absolute';
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = getRandomColor();
            particle.style.boxShadow = `0 0 ${size * 2}px ${getRandomColor(true)}`;
            particle.style.left = `${startX}px`;
            particle.style.top = `${startY}px`;
            //    - 透明度也随机，营造深远感
            particle.style.opacity = Math.random() * 0.6 + 0.4;

            // 5. 把粒子添加到容器里
            container.appendChild(particle);

            // 6. 启动粒子的动画，让它动起来
            animateParticle(particle, width, height, speedX, speedY, duration);
        }

        // =====================
        // 粒子的动画函数
        // =====================
        function animateParticle(particle, width, height, speedX, speedY, duration) {
            // 1. 读取当前粒子的坐标和透明度
            let posX = parseFloat(particle.style.left);
            let posY = parseFloat(particle.style.top);
            let opacity = parseFloat(particle.style.opacity);
            let time = 0;

            // 2. 定义动画更新函数，每帧调用
            function update() {
                time += 0.016; // 约等于60帧每秒，动画流畅

                // 2.1 更新粒子的位置
                posX += speedX;
                posY += speedY;

                // 2.2 边界检测：如果粒子碰到边缘就反弹回来
                //     这样粒子不会飞出可视区域，始终在容器内漂浮
                if (posX < 0 || posX > width) {
                    speedX *= -1;
                }
                if (posY < 0 || posY > height) {
                    speedY *= -1;
                }

                // 2.3 更新粒子的样式
                particle.style.left = `${posX}px`;
                particle.style.top = `${posY}px`;

                // 2.4 粒子闪烁效果：用正弦函数让透明度周期性变化，像星星在眨眼
                opacity = 0.4 + Math.sin(time * 2) * 0.3;
                particle.style.opacity = opacity;

                // 2.5 判断动画是否结束
                if (time < duration) {
                    // 没到时限就继续下一帧
                    requestAnimationFrame(update);
                } else {
                    // 动画结束后，重置粒子到新位置，重新开始
                    particle.style.left = `${Math.random() * width}px`;
                    particle.style.top = `${Math.random() * height}px`;
                    animateParticle(particle, width, height, speedX, speedY, duration);
                }
            }

            // 3. 启动动画
            requestAnimationFrame(update);
        }

        // =====================
        // 随机颜色生成函数
        // =====================
        function getRandomColor(bright = false) {
            // bright为true时，选用更亮的颜色
            const colors = bright ?
                ['#00f7ff', '#ff00aa', '#00ff88', '#ffffff'] :
                ['rgba(0, 247, 255, 0.8)', 'rgba(255, 0, 170, 0.8)', 'rgba(0, 255, 136, 0.8)'];

            // 随机返回一个颜色
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // =====================
        // jpg.js,图片动画触发与播放
        // =====================
        document.addEventListener('DOMContentLoaded', function () {
            // 1. 获取触发按钮和图片元素
            const triggerEarth = document.getElementById('triggerEarth');
            const triggerXmy = document.getElementById('triggerXmy');
            const wanderingEarthImage = document.getElementById('wanderingEarthImage');
            const xmyImage = document.getElementById('xmyImage');
            const erenYeagerImage = document.getElementById('erenYeagerImage');
            const starYourselfImage = document.getElementById('starYourselfImage');

            // 2. 检查元素是否存在，避免后续报错
            if (!triggerEarth) {
                console.error('Trigger element "triggerEarth" not found.');
            }
            if (!triggerXmy) {
                console.error('Trigger element "triggerXmy" not found.');
            }
            if (!wanderingEarthImage) {
                console.error('Image element "wanderingEarthImage" not found.');
            }
            if (!xmyImage) {
                console.error('Image element "xmyImage" not found.');
            }
            if (!erenYeagerImage) {
                console.error('Image element "erenYeagerImage" not found.');
            }
            if (!starYourselfImage) {
                console.error('Image element "starYourselfImage" not found.');
            }

            // 3. 定义图片动画播放函数
            function playImageAnimation(imageElement) {
                if (!imageElement) {
                    console.error('Attempted to animate a null image element.');
                    return;
                }

                // 3.1 先移除动画类，保证每次都能重新触发动画
                imageElement.classList.remove('animate');

                // 3.2 强制浏览器重绘，确保动画能被识别到
                imageElement.style.display = 'block';
                void imageElement.offsetWidth; // 这句很关键，不然动画可能不生效

                // 3.3 添加动画类，触发CSS动画
                imageElement.classList.add('animate');

                // 3.4 监听动画结束事件，更精准清理状态
                const onAnimationEnd = () => {
                    imageElement.classList.remove('animate');
                    imageElement.style.display = 'none';
                    imageElement.removeEventListener('animationend', onAnimationEnd);
                };
                imageElement.addEventListener('animationend', onAnimationEnd);
            }

            // 找到精确匹配文本内容的元素
            const starText = Array.from(document.querySelectorAll('.cosmic-text')).find(
                el => el.textContent.trim() === '我是星 利剑开刃寒光锋芒的银星 绝不消隐'
            );

            const noLookBackText = Array.from(document.querySelectorAll('.cosmic-text')).find(
                el => el.textContent.trim() === '不回顾 永难再折返的故园的光阴 决意前进'
            );

            // 添加点击事件监听器
            if (starText) {
                starText.addEventListener('click', function () {
                    console.log('Star text clicked!');
                    playImageAnimation(starYourselfImage);
                });
                starText.style.cursor = 'pointer'; // 添加指针样式提示可点击
            } else {
                console.error('Star text element not found');
            }

            if (noLookBackText) {
                noLookBackText.addEventListener('click', function () {
                    console.log('No look back text clicked!');
                    playImageAnimation(erenYeagerImage);
                });
                noLookBackText.style.cursor = 'pointer'; // 添加指针样式提示可点击
            } else {
                console.error('No look back text element not found');
            }
            // 4. 给按钮绑定点击事件，点击后播放对应图片的动画
            if (triggerEarth && wanderingEarthImage) {
                triggerEarth.addEventListener('click', function () {
                    playImageAnimation(wanderingEarthImage);
                });
            }

            if (triggerXmy && xmyImage) {
                triggerXmy.addEventListener('click', function () {
                    playImageAnimation(xmyImage);
                });
            }

            if (triggerErenYeager && erenYeagerImage) {
                triggerErenYeager.addEventListener('click', function () {
                    playImageAnimation(erenYeagerImage);
                });
            }

            if (triggerStarYourself && starYourselfImage) {
                triggerStarYourself.addEventListener('click', function () {
                    playImageAnimation(starYourselfImage);
                });
            }


        });

    </script>



    <script>

        // ========================cursor.js=================================================
        //=============鼠标： 核core、环ring、尾迹trail    三重中心同步===============================
        //=============鼠标：  移动、   按下、    松开     三个鼠标监听事件都触发三重中心同步=====================


        // === 自定义鼠标三层同步与 trail 逻辑 ===
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;

        // 同步自定义光标的中心位置函数
        function setCursorElementsCenter(x, y) {
            // custom-cursor
            const cursor = document.getElementById('custom-cursor');
            if (cursor) {
                cursor.style.left = `${x}px`;
                cursor.style.top = `${y}px`;

                // 确保transform始终包含translate(-50%, -50%)
                const currentTransform = cursor.style.transform || '';
                if (!currentTransform.includes('translate(-50%, -50%)')) {
                    cursor.style.transform = `translate(-50%, -50%) ${currentTransform.replace('translate(-50%, -50%)', '')}`;
                }
            }

            // 所有 trail
            document.querySelectorAll('.cursor-trail').forEach(trail => {
                trail.style.left = `${x}px`;
                trail.style.top = `${y}px`;
                trail.style.transform = 'translate(-50%, -50%)';
            });
        }

        function syncCursorCenters() {
            setCursorElementsCenter(mouseX, mouseY);
            requestAnimationFrame(syncCursorCenters);
        }

        // 监听鼠标移动事件，仿佛宇宙中探测器追踪流星轨迹一般，每当鼠标移动，就触发后续操作
        document.addEventListener('mousemove', (e) => {
            // 捕获鼠标在浏览器窗口内的水平坐标，如同记录宇宙坐标中的X轴位置
            mouseX = e.clientX;
            // 捕获鼠标在浏览器窗口内的垂直坐标，如同记录宇宙坐标中的Y轴位置
            mouseY = e.clientY;
            // 调用函数，将自定义光标的中心位置与鼠标位置同步，就像调整宇宙飞船的导航系统，让其精准定位
            setCursorElementsCenter(mouseX, mouseY);

            // 获取存储鼠标轨迹的容器元素，这容器就像是宇宙中的轨迹记录仪，专门收集流星划过的痕迹
            const cursorTrails = document.getElementById('cursor-trails');
            // 检查轨迹容器是否存在，若存在则进行后续操作，就像确认记录仪是否正常工作
            if (cursorTrails) {
                // 创建一个新的轨迹元素，仿佛在宇宙中生成一颗新的流星尾迹
                const trail = document.createElement('div');
                // 为新创建的轨迹元素添加类名，使其具备预设的样式，如同给流星尾迹赋予独特的光芒
                trail.className = 'cursor-trail';
                // 将轨迹元素的定位方式设置为固定定位，确保它能跟随鼠标移动，如同流星尾迹紧紧跟随着流星
                trail.style.position = 'fixed';
                // 将轨迹元素的水平位置设置为鼠标当前的水平位置，使其在X轴上与鼠标对齐
                trail.style.left = `${mouseX}px`;
                // 将轨迹元素的垂直位置设置为鼠标当前的垂直位置，使其在Y轴上与鼠标对齐
                trail.style.top = `${mouseY}px`;
                // 对轨迹元素进行平移变换，将其中心与鼠标位置重合，就像微调流星尾迹的位置，使其完美贴合流星
                trail.style.transform = 'translate(-50%, -50%)';
                // 将新创建的轨迹元素添加到轨迹容器中，如同将新的流星尾迹记录到轨迹记录仪中
                cursorTrails.appendChild(trail);
                // 设置一个定时器，100毫秒后开始淡化轨迹元素，模拟流星尾迹逐渐消散的过程
                setTimeout(() => {
                    // 将轨迹元素的透明度设置为0，使其逐渐消失，如同流星尾迹在宇宙中慢慢消散
                    trail.style.opacity = '0';
                    // 再设置一个定时器，300毫秒后移除已经完全透明的轨迹元素，清理轨迹记录仪中的旧记录
                    setTimeout(() => {
                        // 检查轨迹元素是否有父节点，若有则将其从父节点中移除
                        if (trail.parentNode) trail.parentNode.removeChild(trail);
                    }, 300);
                }, 100);
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouseX = e.clientX;
                mouseY = e.clientY;
                setCursorElementsCenter(mouseX, mouseY);

                const cursor = document.getElementById('custom-cursor');
                if (cursor) {
                    // 确保缩放时保持translate(-50%, -50%)
                    cursor.style.transform = 'translate(-50%, -50%) scale(0.8)';
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                const cursor = document.getElementById('custom-cursor');
                if (cursor) {
                    // 确保还原时保持translate(-50%, -50%)
                    cursor.style.transform = 'translate(-50%, -50%) scale(1)';
                }
            }
        });

        function initCustomCursor() {
            const cursor = document.getElementById('custom-cursor');
            if (cursor) {
                // 初始化时确保cursor-core和cursor-ring在DOM中存在
                if (!cursor.querySelector('.cursor-core')) {
                    const core = document.createElement('div');
                    core.className = 'cursor-core';
                    cursor.appendChild(core);
                }
                if (!cursor.querySelector('.cursor-ring')) {
                    const ring = document.createElement('div');
                    ring.className = 'cursor-ring';
                    cursor.appendChild(ring);
                }
            }

            // 宇宙中的信号接收器，专门负责捕捉鼠标与特定元素的交互。
            // 1. 使用 document.querySelectorAll 方法，在浩瀚的网页宇宙里搜寻所有的按钮（button）、链接（a）、输入框（input）和下拉选择框（select）元素。
            //    就好像在宇宙中寻找那些闪烁着独特光芒的星球，这些元素就是我们要关注的目标。
            document.querySelectorAll('button, a, input, select').forEach(el => {
                // 2. 接着，为每个找到的元素安装一个“鼠标进入探测器”。当鼠标像一艘宇宙飞船靠近这些元素星球时，触发相应的事件。
                el.addEventListener('mouseenter', () => {
                    // 3. 检查自定义光标这个“宇宙飞行器”是否存在。如果存在，就对它进行一系列操作。
                    if (cursor) {
                        // 4. 当鼠标靠近元素时，将自定义光标放大 1.5 倍。就好像飞行器靠近星球时，自动调整视角，准备进行更细致的观察。
                        cursor.style.transform = 'translate(-50%, -50%) scale(1.5)';
                        // 5. 在自定义光标中寻找核心部件——那个代表着能量核心的 .cursor-core 元素。
                        const core = cursor.querySelector('.cursor-core');
                        // 6. 如果找到了能量核心，就将它的背景颜色切换为 #ff00aa，仿佛星球发出了特殊的能量信号，核心开始闪烁独特的光芒。
                        if (core) core.style.backgroundColor = '#ff00aa';
                    }
                });

                // 7. 再为每个元素安装一个“鼠标离开探测器”。当鼠标这艘宇宙飞船离开元素星球时，触发相应的事件。
                el.addEventListener('mouseleave', () => {
                    // 8. 同样检查自定义光标是否存在。
                    if (cursor) {
                        // 9. 当鼠标离开元素时，将自定义光标恢复到原来的大小，就像飞行器完成观察任务后，恢复正常视角。
                        cursor.style.transform = 'translate(-50%, -50%) scale(1)';
                        // 10. 再次寻找能量核心元素。
                        const core = cursor.querySelector('.cursor-core');
                        // 11. 如果找到，就将能量核心的背景颜色恢复为原来的 #00f7ff，意味着星球恢复平静，核心也恢复正常光芒。
                        if (core) core.style.backgroundColor = '#00f7ff';
                    }
                });
            });
        }

        document.addEventListener('DOMContentLoaded', function () {
            // 确保光标元素在页面加载时创建
            const customCursor = document.getElementById('custom-cursor');
            if (!customCursor) {
                const cursorEl = document.createElement('div');
                cursorEl.id = 'custom-cursor';
                cursorEl.className = 'custom-cursor';

                const core = document.createElement('div');
                core.className = 'cursor-core';

                const ring = document.createElement('div');
                ring.className = 'cursor-ring';

                cursorEl.appendChild(core);
                cursorEl.appendChild(ring);
                document.body.appendChild(cursorEl);
            }

            // 确保cursor-trails容器存在
            if (!document.getElementById('cursor-trails')) {
                const trailsContainer = document.createElement('div');
                trailsContainer.id = 'cursor-trails';
                document.body.appendChild(trailsContainer);
            }

            requestAnimationFrame(syncCursorCenters);
            initCustomCursor();
        });
    </script>;





    <script>
        // 阻止地球光晕效果的函数
        function disableEarthGlowEffects() {
            if (window.earthScene && window.earthScene.scene) {
                const scene = window.earthScene.scene;
                // 移除所有光晕相关对象
                scene.children = scene.children.filter(child =>
                    !(child.userData && child.userData.isGlowEffect)
                );
            }
        }

        // 初始化3D地球
        let earthRotationSpeed = 0.006; // 加快初始转速
        let cloudsRotationSpeed = 0.009; // 保持1.5倍关系
        let isMouseDown = false;
        let particleSystem = null;
        let currentParticleCount = 200000;
        let earthScene = null;
        let earth = null;
        let clouds = null;
        let speedFactor = 3; // 速度因子
        let engineParticles = [];
        let isFullscreen = false;
        let comparisonChart = null;
        let historyChart = null;

        // 预加载地球纹理
        const textureLoader = new THREE.TextureLoader();
        const earthTextures = {
            texture: textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
            bumpMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
            specularMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg'),
            nightLightsMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_lights_2048.jpg'),
            cloudTexture: textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png')
        };

        // --- 全局左键单击流星爆炸特效，始终以core中心为准 ---
        document.addEventListener('mousedown', function (e) {
            if (e.button === 0) {
                const { x, y } = getCursorCoreCenter();
                createStarBurstEffect(x, y);
            }
        });
        // --- END ---

        // ===============================
        // 初始化地球，接下来开始比较有趣的代码了
        // ===============================
        function initEarth() {
            // 1. 获取地球容器的DOM节点，准备承载我们的宇宙奇观
            const container = document.getElementById('earth-container');

            // 2. 创建三维场景，像造物主一样开启新世界
            const scene = new THREE.Scene();

            // 3. 配置摄像机，设定视角参数，仿佛漂浮在太空中俯瞰地球
            //    - 视场角75度，宽高比为窗口比例，最近0.1，最远1000，保证地球和星尘都能收入眼底
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 300; // 拉远视角，给地球和尾焰留足空间

            // 4. 创建WebGL渲染器，透明背景+抗锯齿+高性能，画质拉满！是有点卡啊QAQ
            const renderer = new THREE.WebGLRenderer({
                alpha: true, // 允许背景透明，方便后续叠加特效
                antialias: true, // 抗锯齿，边缘更柔和
                powerPreference: "high-performance" // 优先高性能，毕竟是宇宙级别的渲染
            });
            renderer.setSize(window.innerWidth, window.innerHeight); // 画布尺寸自适应窗口
            renderer.setPixelRatio(window.devicePixelRatio); // 适配高分屏，细节更清晰
            container.appendChild(renderer.domElement); // 把渲染器画布塞进页面

            // 5. 轨道控制器，允许鼠标旋转地球，自动旋转模拟宇宙自转
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false; // 禁止缩放，保持宇宙尺度的神秘感
            controls.enablePan = false; // 禁止平移，锁定视角
            controls.autoRotate = true; // 自动旋转，地球自转不停歇
            controls.autoRotateSpeed = 0.3; // 自转速度，慢慢悠悠，宇宙很悠长

            // 6. 构建地球球体，半径80，分段极高，细节拉满
            const geometry = new THREE.SphereGeometry(80, 256, 256);

            // 7. 配置地球材质，冰封流浪地球风格，细节参数见下：
            //    - map: 地球表面贴图
            //    - bumpMap: 高度贴图，模拟冰层厚重感
            //    - bumpScale: 冰层起伏强度
            //    - specularMap: 高光贴图，金属质感
            //    - specular: 高光颜色，冷色调
            //    - shininess: 光泽度，冰面反光
            //    - emissive: 自发光，深蓝色夜光
            //    - emissiveIntensity: 自发光强度，夜晚更炫酷
            //    - emissiveMap: 夜晚灯光贴图
            //    - combine/reflectivity/envMapIntensity: 反射参数，增强冰感
            //    - wireframe: 关闭线框，真实感更强
            const material = new THREE.MeshPhongMaterial({
                map: earthTextures.texture, // 地球表面
                bumpMap: earthTextures.bumpMap, // 冰层起伏
                bumpScale: 15.0, // 冰层厚度，夸张点才有末日感
                specularMap: earthTextures.specularMap, // 高光
                specular: new THREE.Color(0xffdd88), // 冷金属高光
                shininess: 30, // 光泽度
                transparent: true, // 允许透明，方便后续特效叠加
                opacity: 0.85, // 半透明，冰封质感
                emissive: new THREE.Color(0x001133), // 深蓝自发光
                emissiveIntensity: 5.0, // 夜晚更亮
                emissiveMap: earthTextures.nightLightsMap, // 夜灯贴图
                combine: THREE.MixOperation, // 混合操作
                reflectivity: 2.0, // 反射增强
                envMapIntensity: 4.0, // 环境光强度
                wireframe: false // 关闭线框
            });

            // 8. 创建地球网格体，加入场景
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);

            // 9. 添加云层，包裹地球，流浪地球风格的冰雾云
            const cloudGeometry = new THREE.SphereGeometry(82, 128, 128); // 稍大于地球
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: earthTextures.cloudTexture, // 云层贴图
                transparent: true, // 允许透明
                opacity: 0.5, // 云层更浓密
                emissive: new THREE.Color(0x001133), // 深蓝自发光
                emissiveIntensity: 0.4, // 微弱夜光
                blending: THREE.AdditiveBlending, // 叠加混合，云雾更梦幻
                specular: new THREE.Color(0x3399ff), // 蓝色高光
                shininess: 50, // 降低光泽度，模拟冰雾
                depthWrite: false // 不写入深度，避免遮挡
            });
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);


            //====================== earthParticle.js ========================================
            // 10. 地球尾部喷射粒子效果，模拟推进器喷射的等离子体火焰
            function createEarthTailFlame(particleCount) {
                // a. 创建粒子系统的几何体
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3); // 每个粒子3个坐标
                const colors = new Float32Array(particleCount * 3); // 每个粒子RGB
                const sizes = new Float32Array(particleCount); // 每个粒子尺寸

                // b. 随机生成每个粒子的位置、颜色和大小
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    // --- 位置算法 ---
                    // 1. theta: 角度名西塔，粒子绕Z轴随机分布，0~2π，形成圆锥形喷射
                    // 2. phi: 角度名fai，控制喷射角度，0~π/2，集中在地球尾部
                    // 3. radius: 距离地球表面80起，最大到1280，越远越稀疏
                    // 4. 通过Math.pow(Math.random(), 3)让大部分粒子靠近地球，远处稀疏，喷射感更强
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI * 0.5;
                    const radius = 80 + Math.pow(Math.random(), 3) * 1200;
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta) * (0.8 + Math.random() * 0.4); // X
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta) * (0.8 + Math.random() * 0.4); // Y
                    positions[i3 + 2] = -radius * Math.cos(phi); // Z，全部指向地球背面

                    // --- 颜色算法 ---
                    // 1. HSL色彩空间，hue在0.55~0.65之间，蓝色调
                    // 2. saturation固定0.9，鲜艳
                    // 3. lightness随距离变化，越远越亮，模拟等离子体渐变
                    // 4. 偶尔加点亮度，制造闪烁感
                    const color = new THREE.Color();
                    const hue = 0.55 + Math.random() * 0.1;
                    const saturation = 0.9;
                    const distanceFactor = 1 - (radius - 80) / 1200; // 越靠近地球越大
                    const lightness = 0.1 + distanceFactor * 0.4;
                    color.setHSL(hue, saturation, lightness);
                    if (Math.random() > 0.9) {
                        color.offsetHSL(0, 0, 0.05); // 偶尔闪一下
                    }
                    color.toArray(colors, i3);

                    // --- 尺寸算法 ---
                    // 1. 靠近地球更小，远离地球更大，增强喷射速度感
                    sizes[i] = 0.3 + Math.random() * 5 * (1 - distanceFactor * 0.7);
                }
                // c. 将属性塞进BufferGeometry
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                // d. 配置粒子材质，叠加混合，透明度0.6，支持顶点色
                const particleMaterial2 = new THREE.PointsMaterial({
                    size: 2,
                    sizeAttenuation: true, // 距离越远越小
                    vertexColors: true, // 使用自定义颜色
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending, // 叠加混合，发光感
                    depthWrite: false, // 不写入深度，避免遮挡
                    fog: true // 受雾影响，空间感更强
                });
                // e. 创建粒子系统
                const system = new THREE.Points(particles, particleMaterial2);
                // f. 动画更新函数，模拟粒子喷射和扰动
                system.userData = {
                    update: function () {
                        const positions = particles.attributes.position.array;
                        const currentSpeedFactor = 1;
                        for (let i = 0; i < particleCount; i++) {
                            const i3 = i * 3;
                            // 计算粒子到地球中心的距离
                            const distanceFromEarth = Math.sqrt(
                                Math.pow(positions[i3], 2) +
                                Math.pow(positions[i3 + 1], 2) +
                                Math.pow(positions[i3 + 2], 2)
                            );
                            // --- 速度算法详解 ---
                            // 1. 基础速度+随机扰动+距离反比加速，越远越慢
                            // 2. currentParticleCount/200000控制喷射强度，粒子越多喷射越猛
                            const speed = (1 + Math.random() * 2 + (1200 / distanceFromEarth) * 6) * currentSpeedFactor * (currentParticleCount / 200000);
                            positions[i3 + 2] -= speed; // Z轴负方向喷射
                            // --- 扰动算法 ---
                            // 1. 距离越近扰动越大，模拟尾焰的湍流
                            const turbulence = 0.3 * (1 - (distanceFromEarth - 80) / 1200) * currentSpeedFactor;
                            positions[i3] += (Math.random() - 0.5) * turbulence;
                            positions[i3 + 1] += (Math.random() - 0.5) * turbulence;
                            // --- 边界重置 ---
                            // 1. 超出范围的粒子重置到地球尾部，形成循环喷射
                            if (positions[i3 + 2] < -1500 || distanceFromEarth > 1800) {
                                positions[i3 + 2] = -80 - Math.random() * 60;
                                positions[i3] = (Math.random() - 0.5) * 100;
                                positions[i3 + 1] = (Math.random() - 0.5) * 100;
                            }
                        }
                        particles.attributes.position.needsUpdate = true; // 通知Three.js刷新
                    }
                };
                return system;
            }

            // 11. 创建地球尾部喷射粒子系统，数量为currentParticleCount*2，视觉冲击力拉满
            particleSystem = createEarthTailFlame(currentParticleCount * 2);
            scene.add(particleSystem);

            // 12. 星际尘埃，营造深邃宇宙氛围
            function createSpaceDust() {
                const dustCount = 5000; // 尘埃数量
                const dustGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(dustCount * 3);
                const sizes = new Float32Array(dustCount);

                for (let i = 0; i < dustCount; i++) {
                    const i3 = i * 3;
                    // 尘埃随机分布在2000立方空间内
                    positions[i3] = (Math.random() - 0.5) * 2000;
                    positions[i3 + 1] = (Math.random() - 0.5) * 2000;
                    positions[i3 + 2] = (Math.random() - 0.5) * 2000;
                    sizes[i] = 0.4 + Math.random() * 2; // 尺寸微小
                }

                dustGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                dustGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                // 尘埃材质，半透明灰色
                const dustMaterial = new THREE.PointsMaterial({
                    color: 0xaaaaaa,
                    size: 0.2,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.5
                });

                const dust = new THREE.Points(dustGeometry, dustMaterial);

                // 尘埃动画：缓慢向Z轴正方向漂移，超出边界重置
                dust.userData = {
                    update: function () {
                        const positions = dustGeometry.attributes.position.array;
                        for (let i = 0; i < dustCount; i++) {
                            const i3 = i * 3;
                            positions[i3 + 2] += 0.2 * speedFactor; // 缓慢漂移
                            if (positions[i3 + 2] > 1000) {
                                positions[i3 + 2] = -1000; // 超出边界重置
                            }
                        }
                        dustGeometry.attributes.position.needsUpdate = true;
                    }
                };
                return dust;
            }

            // 13. 创建星际尘埃并加入场景
            const spaceDust = createSpaceDust();
            scene.add(spaceDust);

            // 14. 环境光，整体提亮，模拟宇宙背景光
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            // 15. 主定向光，模拟太阳照射，色温偏暖，强度2.5，投射阴影
            const directionalLight = new THREE.DirectionalLight(0xffd8b1, 2.5);
            directionalLight.position.set(1, 1, 0.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);

            // 16. 太阳弧光，冰蓝色聚光灯，营造末日科幻感
            const sunArcLight = new THREE.SpotLight(0x00aaff, 3, 200, Math.PI / 8, 0.7);
            sunArcLight.color.setHSL(0.55, 1, 0.5); // 银冰蓝色
            sunArcLight.target.position.set(0, 0, 0);
            sunArcLight.penumbra = 0.6; // 柔和边缘
            // 使用渐变贴图模拟弧光晕染
            const gradientTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJFSURBVDjLpZNNSFRRFIC/982bUaeZIS370BRbCKbgpiwIKYhWfSwKgqhNQau2bTOIODd+LIIWBS0yCoKCDi2UaBp0LNAUlVDT/m9Gnt95495j5vT0IpamCgfOTL77zvn43zMCnHXmzDlz5kw2TdP1Wut7Wut7Sik7TdNUa/2lVCpd/v8XjDk3N7dQLpddAFSAApAAlVKp5B4/frwa7NlHHTt2LLx7+3a2UCiQz+fJ5XLk83lyuRzZbJZkMkmhUGB5eZnR0VHv1s2bQ4E5ODh4u1Kp3EgpZQUYjQYhBEIIDg4OWFtbY2Fh4fHw8LATmN3d3W8mJydvDA0N0dPTQxAESClRSqGUwrZtXNcljmPiOGZ9fZ3l5eW3wK3A7OvrG0sp3fT7/TiOg+M4WJaFUgrP8wjDkDAMieOYOI6JogjP8wjDkCiKUEo1m6ZpmqZpWq1Wqdfr1Ot1Go0GjUaDJEnwfZ8kSfB9nzRNiaKIOI5JkoQ0TQvM3t7eF67rXk8pZdu2jed5WJaFUgrf9wnDkDAMCcMQ3/cJw5AgCPB9nzAMSdO0wDTN7pRSNk3TtFqtUq/XqdVq1Go1KpUK5XKZUqlEsVikWCxSLBYpl8tUKhUqlQpSSgqFQoFpmt1Zln1UKBSI45goioiiCM/z8H0fz/PwPA/P8/A8D9/3CcOQMAzJsox6vY5pmt1Zln3M5/MUi0WKxSKlUolKpUK1WqVWq1Gv12k0GjQaDZrNJq1Wi1arRavVot1u0263Mc2Ojo5Xruu+rtfrNBoNms0mrVaLdrv9Z7Xb7T9mkiQkSUKSJMRxTBRFRFFEHMdYHR0dr1zXfV2r1ajValSrVSqVCuVymVKpRLFYpFAokM/n2dvbY3d3l93dXXZ2dtje3mZra4vNzU02NjbY2NhgbW0Nq6ur62WlUrmRUsq2bRvP87AsC6UUvu8ThiFBEOB5Hp7n4XkenufheR6+7xOGIUIIhBBYlpVlWfYxy7KPWZZ9zLKsI8uyj1mWfcyy7GOWZR+zLPuYZdnHLMs+Zln2Mcuyj1mWfQb5Df6y00WH3QAAAABJRU5ErkJggg==');
            sunArcLight.map = gradientTexture;
            sunArcLight.position.set(1, 1, 0.5);
            sunArcLight.target.position.set(0, 0, 0);
            sunArcLight.castShadow = true;
            scene.add(sunArcLight);
            scene.add(sunArcLight.target);

            // 17. 增强极光，冰蓝与翠绿交织，仿佛太阳风暴在地球极圈跳舞
            const auroraLight = new THREE.HemisphereLight(0x00ffaa, 0x0066ff, 1.2);
            auroraLight.position.set(0, 1, 0);
            scene.add(auroraLight);

            // 18. 动态极光纹理，水波纹理模拟极光流动
            const auroraTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/waternormals.jpg');
            auroraTexture.wrapS = auroraTexture.wrapT = THREE.RepeatWrapping;
            auroraTexture.repeat.set(3, 3);

            // 19. 极光材质，冰蓝色自发光，透明度0.7，叠加混合
            const auroraMaterial = new THREE.MeshPhongMaterial({
                color: 0x00aaff,
                emissive: 0x0066ff,
                emissiveIntensity: 1.5,
                transparent: true,
                opacity: 0.7,
                map: auroraTexture,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });

            // 20. 极光几何体，覆盖地球上半球，仿佛极地光幕
            const auroraGeometry = new THREE.SphereGeometry(82, 64, 64, 0, Math.PI * 2, 0, Math.PI / 2);
            const aurora = new THREE.Mesh(auroraGeometry, auroraMaterial);
            aurora.rotation.x = Math.PI / 2; // 旋转到北极上方
            scene.add(aurora);

            // 21. 极光动画，动态流动+脉动，极地光幕随时间跳动
            aurora.userData = {
                update: function () {
                    auroraTexture.offset.x += 0.001; // 水平流动
                    auroraTexture.offset.y += 0.0005; // 垂直流动
                    aurora.rotation.z += 0.0005; // 极光缓慢旋转
                    // 脉动效果，sin波模拟极光明暗变化
                    const pulse = Math.sin(Date.now() * 0.001) * 0.2 + 0.8;
                    auroraMaterial.opacity = 0.5 * pulse;
                    auroraMaterial.emissiveIntensity = 1.5 * pulse;
                }
            };

            /*
            // 完全禁用光晕效果创建
            const earthGlow = null;
            const earthOuterGlow = null;
            const atmosphere = null;
            */

            // 22. 3D立体星星，使用InstancedMesh优化，数量10000，宇宙浩瀚星海
            const starCount = 10000;
            const baseGeometry = new THREE.SphereGeometry(0.5, 8, 8); // 星星基础球体

            // 实例化材质，白色高光，透明度0.9
            const starsMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                specular: 0x111111,
                shininess: 30,
                transparent: true,
                opacity: 0.9,
                vertexColors: true
            });

            // 创建实例化网格，性能优化，星星多也不卡
            const stars = new THREE.InstancedMesh(baseGeometry, starsMaterial, starCount);
            stars.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // 动态更新

            // 预分配颜色和矩阵数据
            const color = new THREE.Color();
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const scale = new THREE.Vector3();
            const colors = new Float32Array(starCount * 3);




            for (let i = 0; i < starCount; i++) {
                // 随机分布在3000立方空间
                position.set(
                    (Math.random() - 0.5) * 3000,
                    (Math.random() - 0.5) * 3000,
                    (Math.random() - 0.5) * 3000
                );
                // 星星尺寸0.3~1.4，大小不一
                const size = Math.random() * 1.1 + 0.3;
                scale.set(size, size, size);
                // 随机HSL颜色，偏白蓝色，亮度高
                const hue = Math.random() * 0.2 + 0.8;
                const saturation = Math.random() * 0.2 + 0.8;
                const lightness = Math.random() * 0.3 + 0.7;
                color.setHSL(hue, saturation, lightness);
                // 存储颜色
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;



                //构建我们宇宙中的星星！

                //一.核心代码：matrix.compose(position, new THREE.Quaternion(), scale);
                // 1. 组装星星的实例矩阵
                //    矩阵就像是星星在宇宙中的“身份证”，它记录了星星的位置、旋转和缩放信息。
                // 在浩瀚无垠的宇宙中，每一颗星星都有其独特的存在方式。要想在这个宇宙里精准地摆放星星，就需要借助一些神奇的手段。
                // 1. 星星的位置：`position` 就像是星星在宇宙坐标中的定位器，告诉我们这颗星星具体位于宇宙的哪个角落。
                // 2. 星星的旋转信息：在宇宙中，星星并非静止不动，它们也会旋转，这里用四元数 `new THREE.Quaternion()` 来表示星星的旋转状态。
                //    在计算机图形学里，四元数常用于表示三维空间中的旋转。
                //    由一个实部和三个虚部组成，通常表示为 q = w + xi + yj + zk，其中 w 是实部，x、y、z 是虚部，i、j、k 是虚数单位，
                //    且满足 i² = j² = k² = ijk = -1。
                // 3. 星星的缩放比例：`scale` 决定了星星的大小，有的星星可能是巨大的恒星，有的则可能是渺小的小行星，通过缩放比例就能在宇宙中呈现出不同大小的星星。
                // 4. 组合矩阵：使用 `compose` 方法，就像是启动了一台宇宙组装机，把星星的位置、旋转信息和缩放比例这三个关键要素组合成一个矩阵 `matrix`。
                //    这个矩阵就如同星星的“宇宙身份证”，包含了这颗星星在宇宙中该如何摆放的所有信息。
                //    想象一下，我们在宇宙中摆放星星，这个矩阵就是告诉宇宙每个星星该放在哪里，怎么旋转，以及大小是多少。

                matrix.compose(position, new THREE.Quaternion(), scale);



                // 二. 将组装好的矩阵应用到星星实例上
                //    现在我们已经有了星星的“身份证”矩阵，接下来要把这个“身份证”交给对应的星星。
                //    `stars.setMatrixAt(i, matrix)` 就是把第 `i` 个星星的矩阵设置为我们刚刚组装好的 `matrix`。
                //    这样，宇宙就知道第 `i` 个星星该按照这个矩阵的信息来摆放啦。

                stars.setMatrixAt(i, matrix);



                // 三. 设置星星的颜色
                //    星星有了位置、旋转和缩放信息还不够，还得有漂亮的颜色。
                //    `stars.setColorAt(i, color)` 就是给第 `i` 个星星设置颜色`color`。
                //    想象一下，五彩斑斓的星星点缀在宇宙中，是不是超级炫酷！

                stars.setColorAt(i, color);

            }
            // 设置实例颜色属性
            stars.geometry.setAttribute('color', new THREE.InstancedBufferAttribute(colors, 3));
            // 加入场景
            scene.add(stars);


            // 23. 大气冰晶粒子，营造冰封末日的空间雾感
            scene.fog = new THREE.FogExp2(0x0a1a2c, 0.0000025); // 指定雾颜色和密度
            const iceParticles = new THREE.BufferGeometry();
            const icePositions = new Float32Array(20000 * 3);
            for (let i = 0; i < 20000; i++) {
                icePositions[i * 3] = (Math.random() - 0.5) * 2000;
                icePositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                icePositions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
            }
            iceParticles.setAttribute('position', new THREE.BufferAttribute(icePositions, 3));
            const iceMaterial = new THREE.PointsMaterial({
                color: 0xbbeaff,
                size: 0.5,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const iceField = new THREE.Points(iceParticles, iceMaterial);
            scene.add(iceField);



            // 24. 动画主循环，驱动整个宇宙的运转
            function animate() {
                requestAnimationFrame(animate); // 无限循环
                // 地球自转，转速与粒子数量正相关，粒子越多转得越快
                // 计算旋转因子，这个因子将决定地球和云层的旋转速度。它受到粒子数量和速度因子的影响。
                // 1. 先计算当前粒子数量相对于200000的比例，并乘以3。这一步模拟了粒子数量对旋转的推动作用，粒子越多，潜在的推动力越大。
                // 2. 使用Math.min函数确保这个值最大不超过2，避免旋转速度过快失控。
                // 3. 最后乘以速度因子，速度因子可以在用户交互（如鼠标点击）时动态调整，进一步影响旋转速度。
                const rotationFactor = Math.min(2, currentParticleCount / 200000 * 3) * speedFactor;

                // 根据计算得到的旋转因子，更新地球绕Y轴的旋转角度。
                // 地球原本的旋转速度乘以旋转因子，就像是给地球的自转加上了一股神秘的宇宙力量，推动它加速旋转。
                earth.rotation.y += earthRotationSpeed * rotationFactor;

                // 同理，更新云层绕Y轴的旋转角度。
                // 云层的旋转速度也受到旋转因子的影响，这样云层就能和地球保持同步又独特的旋转效果，仿佛在宇宙中翩翩起舞。
                clouds.rotation.y += cloudsRotationSpeed * rotationFactor;


                // 更新地球尾焰粒子
                if (particleSystem) {
                    particleSystem.userData.update();
                }
                // 更新星际尘埃
                spaceDust.userData.update();
                // 控制器更新（自动旋转）
                controls.update();
                // 渲染场景
                renderer.render(scene, camera);
            }
            animate(); // 启动动画



            // 25. 响应窗口尺寸变化，保持画面全屏
            // 当我们的宇宙观测窗口（浏览器窗口）大小发生变化时，
            // 下面这段代码就会启动，来调整我们的宇宙视角和显示画面，确保我们能一直清晰地探索宇宙奥秘！

            // 1. 监听窗口大小变化事件
            // 一旦窗口大小发生变化，就会触发后面的箭头函数，就像宇宙中的警报系统，时刻关注窗口的动态。
            window.addEventListener('resize', () => {
                // 2. 调整相机的纵横比
                // 相机就像是我们探索宇宙的望远镜，纵横比决定了我们通过望远镜看到的视野范围。
                // 这里我们根据窗口的宽度和高度来重新计算纵横比，让视野始终适配窗口大小。
                camera.aspect = window.innerWidth / window.innerHeight;

                // 3. 更新相机的投影矩阵
                // 投影矩阵就像是望远镜的镜片参数，当纵横比改变后，我们需要更新这个参数，
                // 才能让看到的宇宙画面不会变形，保持真实的视角。
                camera.updateProjectionMatrix();

                // 4. 调整渲染器的大小
                // 渲染器就像是宇宙画面的画师，我们要让画师根据窗口的新大小来绘制宇宙场景，
                // 这样才能让整个宇宙画面完整地显示在窗口中。
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 26. 鼠标左键按下加速地球自转，触发流星爆炸特效
            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // 左键
                    isMouseDown = true;
                    speedFactor = 10; // 加速
                    createStarBurstEffect(e.clientX, e.clientY); // 爆炸特效
                } else if (e.button === 2 && isFullscreen) { // 右键全屏时
                    createParticleBurst(); // 粒子爆发
                }
            });

            // 27. 鼠标左键松开恢复速度
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isMouseDown = false;
                    speedFactor = 1;
                }
            });

            // 28. 右键菜单被禁用，右键触发多重特效，分全屏/非全屏两种
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (isFullscreen) {
                    // 全屏下，粒子数量拉满50万，爆发特效
                    const particleCount = 500000;
                    if (window.earthScene) {
                        window.earthScene.updateParticleCount(particleCount);
                    }
                    clearEngineParticles();
                    createParticleBurst();
                } else {
                    // 非全屏，粒子50万+三重特效
                    if (window.earthScene) {
                        window.earthScene.updateParticleCount(500000);
                    }
                    createParticleBurst(); // 尾焰爆发
                    createBallLightning(); // 球状闪电
                    createMeteors(); // 流星雨
                }
            });



            // 29. 返回场景对象和控制函数，方便外部调用
            return {
                scene,
                updateParticleCount: (count) => {
                    if (particleSystem) {
                        scene.remove(particleSystem);
                    }
                    currentParticleCount = count;
                    particleSystem = createEarthTailFlame(count);
                    scene.add(particleSystem);
                    // 更新地球转速，粒子越多转得越快
                    const rotationFactor = Math.min(2, currentParticleCount / 200000 * 3);
                    earthRotationSpeed = 0.001 + rotationFactor * 0.003;
                    cloudsRotationSpeed = 0.0015 + rotationFactor * 0.0045;
                },
                updateRotationSpeed: (speed) => {
                    earthRotationSpeed = speed;
                    cloudsRotationSpeed = speed * 1.5;
                }
            };
        }





        // 清空地球尾部喷射粒子
        function clearEarthParticles() {
            if (!window.earthScene) return;
            const scene = window.earthScene.scene;

            // 移除现有的粒子系统
            if (window.earthScene.particleSystem) {
                scene.remove(window.earthScene.particleSystem);
                window.earthScene.particleSystem = null;
            }
        }




        // ========================鬼知道我找这个bug函数找了多久-function clearEngineParticles()-逐行比对测试，找到bug代码行那一刻，眼泪都要留下来了==============================

        // 清空地球尾部喷射粒子
        function clearEngineParticles() {
            if (!window.earthScene || !window.earthScene.scene) return;

            const scene = window.earthScene.scene;

            // 只移除临时的粒子系统，保留其他场景元素
            scene.children = scene.children.filter(child => {
                // 检查是否为临时粒子系统
                if (child instanceof THREE.Points && child.userData && child.userData.isTemporaryParticle) {
                    return false; // 移除临时粒子
                }
                return true; // 保留其他所有元素
            });

            // 移除现有的主粒子系统
            if (window.earthScene.particleSystem) {
                scene.remove(window.earthScene.particleSystem);
                window.earthScene.particleSystem = null;
            }
        }

        // 保留原有的createParticleBurst函数用于"量子云计算"按钮
        // 计算地球尾部超精确位置
        function calculateEarthTailPosition() {
            if (!window.earthScene || !window.earthScene.scene) return null;

            // 获取地球网格
            const earth = window.earthScene.scene.children.find(child =>
                child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry
            );
            if (!earth) return null;

            // 获取相机
            const camera = window.earthScene.scene.children.find(child => child instanceof THREE.PerspectiveCamera);
            if (!camera) return null;

            // 更新世界矩阵
            earth.updateMatrixWorld(true);
            camera.updateMatrixWorld(true);

            // 计算地球的世界位置
            const earthWorldPosition = new THREE.Vector3();
            earth.getWorldPosition(earthWorldPosition);

            // 计算地球的旋转四元数
            const earthQuaternion = new THREE.Quaternion();
            earth.getWorldQuaternion(earthQuaternion);

            // 计算地球的缩放
            const earthScale = new THREE.Vector3();
            earth.getWorldScale(earthScale);

            // 计算地球半径（考虑缩放）
            const baseRadius = 80; // 地球基础半径
            const scaledRadius = baseRadius * Math.max(earthScale.x, earthScale.y, earthScale.z);

            // 计算尾部基准点（地球后方）
            const tailOffset = new THREE.Vector3(0, 0, -scaledRadius);
            tailOffset.applyQuaternion(earthQuaternion);

            // 计算最终尾部位置
            const tailPosition = earthWorldPosition.clone().add(tailOffset);

            // 计算相机到地球的方向
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);

            // 计算相机到地球的距离
            const cameraToEarth = new THREE.Vector3().subVectors(earthWorldPosition, camera.position);
            const distanceToEarth = cameraToEarth.length();

            // 根据相机距离调整尾部位置
            const distanceFactor = Math.max(0.8, Math.min(1.2, distanceToEarth / 300));
            tailPosition.sub(earthWorldPosition)
                .multiplyScalar(distanceFactor)
                .add(earthWorldPosition);

            // 返回精确的位置和旋转信息
            return {
                position: tailPosition,
                rotation: new THREE.Euler().setFromQuaternion(earthQuaternion),
                scale: earthScale,
                distanceFactor: distanceFactor
            };
        }

        /**
         * createParticleBurst
         * 召唤地球推进器爆发的等离子体粒子风暴！
         * 这段代码是整个宇宙场景中最燃的爆发特效之一，
         * 每一行都藏着科幻迷的浪漫与疯狂。
         */

        function createParticleBurst() {
            // 1. 没有地球场景就啥也不干，宇宙需要舞台
            if (!window.earthScene) return;

            // 2. 先清空现有尾部粒子，避免宇宙拥堵
            clearEngineParticles();
            const scene = window.earthScene.scene;
            const burstCount = 500000; // 爆发粒子数，50万，视觉冲击力拉满！

            // 3. 获取地球尾部精确位置（推进器喷口）
            const tailInfo = calculateEarthTailPosition();
            if (!tailInfo) return; // 没有尾部信息就不爆发

            // 4. 创建粒子几何体和属性数组
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3); // 每个粒子3个坐标
            const colors = new Float32Array(burstCount * 3);    // 每个粒子RGB
            const sizes = new Float32Array(burstCount);         // 每个粒子尺寸
            const lifeTimes = new Float32Array(burstCount);     // 每个粒子的生命周期
            const velocities = new Float32Array(burstCount * 3);// 每个粒子的速度向量

            // 5. 构建涡流场参数，模拟推进器尾焰的旋涡扰动
            const vortexCenter = new THREE.Vector3(
                tailInfo.position.x,
                tailInfo.position.y,
                tailInfo.position.z - 100 // 稍微后移，制造吸力中心
            );
            const vortexStrength = 0.5; // 涡流强度，越大旋转越剧烈
            const vortexRadius = 150;   // 涡流影响半径

            // 6. 粒子属性初始化循环，逐个生成
            for (let i = 0; i < burstCount; i++) {
                const i3 = i * 3;

                // --- 位置分布算法详解 ---
                // a. u,v用于球面均匀分布采样，theta/phi为球坐标角度
                // b. r使用幂函数分布，靠近地球的粒子密度更高，远处稀疏，视觉更自然
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u; // 0~2π，环绕一圈
                const phi = Math.acos(2 * v - 1); // 0~π，球面分布
                const r = Math.pow(Math.random(), 0.3); // 幂函数，密集分布在球心附近

                // c. 计算初始半径，82为地球半径，distanceFactor为尾部缩放
                const radius = 82 * tailInfo.distanceFactor + r * 10;
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = -radius * Math.cos(phi); // 指向地球背面

                // d. 应用地球当前旋转和缩放，保证粒子跟随地球尾部动态
                const position = new THREE.Vector3(x, y, z);
                position.applyEuler(tailInfo.rotation); // 旋转
                position.multiply(tailInfo.scale);      // 缩放

                // e. 设置粒子最终世界坐标
                positions[i3] = tailInfo.position.x + position.x;
                positions[i3 + 1] = tailInfo.position.y + position.y;
                positions[i3 + 2] = tailInfo.position.z + position.z;

                // --- 速度算法详解 ---
                // a. toCenter为指向涡流中心的向量
                // b. vortexFactor随距离衰减，越靠近中心旋转越强
                // c. X/Y速度分量加入涡流扰动，Z分量为主喷射方向（负Z）
                const toCenter = new THREE.Vector3(
                    vortexCenter.x - positions[i3],
                    vortexCenter.y - positions[i3 + 1],
                    vortexCenter.z - positions[i3 + 2]
                );
                const distance = toCenter.length();
                const vortexFactor = Math.exp(-distance / vortexRadius) * vortexStrength;

                velocities[i3] = (Math.random() - 0.5) * 2 + toCenter.y * vortexFactor; // X分量
                velocities[i3 + 1] = (Math.random() - 0.5) * 2 - toCenter.x * vortexFactor; // Y分量
                velocities[i3 + 2] = -(3 + Math.random() * 5); // Z分量，主喷射方向

                // --- 颜色算法详解 ---
                // a. HSL色彩空间，基础色调0.55（蓝色），加上微小扰动
                // b. 饱和度0.8~1.0，亮度0.3~0.6，制造丰富的等离子体色彩
                const baseHue = 0.55;
                const hueVariation = 0.1;
                const hue = baseHue + (Math.random() - 0.5) * hueVariation;
                const saturation = 0.8 + Math.random() * 0.2;
                const lightness = 0.3 + Math.random() * 0.3;
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                color.toArray(colors, i3);

                // --- 尺寸与生命周期 ---
                sizes[i] = 2 + Math.random() * 4; // 2~6像素
                lifeTimes[i] = 1 + Math.random() * 2; // 1~3秒
            }

            // 7. 将属性塞进BufferGeometry
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // 8. 使用自定义ShaderMaterial实现更炫酷的粒子效果
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    maxLifeTime: { value: 3.0 }
                },
                vertexShader: `
                attribute float size;
                varying vec3 vColor;
                varying float vAlpha;
                uniform float time;
                uniform float maxLifeTime;
                
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    float distance = length(mvPosition.xyz);
                    // 距离越远粒子越小，模拟空间透视
                    float sizeFactor = smoothstep(1000.0, 0.0, distance);
                    // 粒子随生命周期淡出
                    vAlpha = smoothstep(maxLifeTime, maxLifeTime - 1.0, time);
                    // 粒子大小随时间微微跳动，增加生命感
                    gl_PointSize = size * sizeFactor * (1.0 + sin(time * 2.0) * 0.2);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
                fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    // 粒子为圆形，边缘柔和
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    float alpha = smoothstep(0.5, 0.3, dist) * vAlpha;
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // 9. 创建粒子系统并加入场景
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                isTemporaryParticle: true, // 标记为临时粒子，便于后续清理
                velocities: velocities,
                lifeTimes: lifeTimes
            };
            scene.add(particles);

            // 10. 动画主循环，驱动粒子爆发与消亡
            let time = 0;
            const maxLifeTime = 3;
            function animateBurst() {
                time += 0.016; // 约60帧/秒
                material.uniforms.time.value = time; // 更新shader时间
                const positions = geometry.attributes.position.array;
                const colors = geometry.attributes.color.array;
                const sizes = geometry.attributes.size.array;
                // 实时获取地球尾部最新位置，保证粒子跟随地球运动
                const currentTailInfo = calculateEarthTailPosition();
                if (!currentTailInfo) {
                    scene.remove(particles);
                    return;
                }
                for (let i = 0; i < burstCount; i++) {
                    const i3 = i * 3;
                    // --- 位置更新 ---
                    positions[i3] += velocities[i3] * speedFactor;
                    positions[i3 + 1] += velocities[i3 + 1] * speedFactor;
                    positions[i3 + 2] += velocities[i3 + 2] * speedFactor;
                    // --- 涡流扰动 ---
                    const toCenter = new THREE.Vector3(
                        vortexCenter.x - positions[i3],
                        vortexCenter.y - positions[i3 + 1],
                        vortexCenter.z - positions[i3 + 2]
                    );
                    const distance = toCenter.length();
                    const vortexFactor = Math.exp(-distance / vortexRadius) * vortexStrength;
                    velocities[i3] += toCenter.y * vortexFactor * 0.1;
                    velocities[i3 + 1] -= toCenter.x * vortexFactor * 0.1;
                    // --- 生命周期相关的颜色和大小变化 ---
                    const particleProgress = time / lifeTimes[i];
                    if (particleProgress < 1.0) {
                        // 0.7后开始淡出
                        const fadeStart = 0.7;
                        if (particleProgress > fadeStart) {
                            const fade = 1 - (particleProgress - fadeStart) / (1 - fadeStart);
                            const fadePower = 0.5; // 控制淡出曲线
                            const fadeMultiplier = Math.pow(fade, fadePower);
                            colors[i3] *= fadeMultiplier;
                            colors[i3 + 1] *= fadeMultiplier;
                            colors[i3 + 2] *= fadeMultiplier;
                            sizes[i] = (2 + Math.random() * 4) * fadeMultiplier;
                        }
                    }
                }
                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;
                geometry.attributes.size.needsUpdate = true;
                if (time < maxLifeTime) {
                    requestAnimationFrame(animateBurst);
                } else {
                    scene.remove(particles); // 粒子寿终正寝，宇宙归于平静
                }
            }
            animateBurst();
            // 11. 触发巨型流星特效，宇宙级大事件！
            createGiantMeteor();
        }

        /**
         * createMeteorShower
         * 召唤流星雨，点亮夜空！
         */
        function createMeteorShower() {
            const container = document.getElementById('meteors-container');
            const meteorCount = 30; // 流星数量，夜空不会太挤

            // 先清除现有的流星，避免夜空重影
            const existingMeteors = document.querySelectorAll('.meteor');
            existingMeteors.forEach(meteor => meteor.remove());

            for (let i = 0; i < meteorCount; i++) {
                const meteor = document.createElement('div');
                meteor.className = 'meteor';

                // 随机起始位置，横向全屏分布
                const startX = Math.random() * window.innerWidth;
                const startY = -50; // 从屏幕上方外侧开始
                meteor.style.left = `${startX}px`;
                meteor.style.top = `${startY}px`;

                // 随机大小，模拟远近感
                const size = 1 + Math.random() * 3;
                meteor.style.width = `${size}px`;
                meteor.style.height = `${size}px`;

                // 随机颜色，科幻色彩
                const colors = ['#00f7ff', '#ff00aa', '#ffffff', '#00ff88'];
                meteor.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];

                // 随机速度和方向
                const duration = 1 + Math.random() * 2; // 1~3秒
                const endX = startX + (Math.random() * 500 - 250); // 横向偏移
                const endY = window.innerHeight + 50; // 落到屏幕下方

                meteor.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;
                meteor.style.transition = `transform ${duration}s linear`;
                meteor.style.opacity = '1';

                container.appendChild(meteor);

                // 流星消失后移除元素，夜空恢复宁静
                setTimeout(() => {
                    meteor.remove();
                }, duration * 1000);
            }
        }

        /**
         * createStarBurstEffect
         * 星爆特效，左键点击宇宙即刻绽放！
         */
        function createStarBurstEffect(x, y) {
            // 爆炸星际粒子参数
            const particleCount = 36 + Math.floor(Math.random() * 12); // 36~47颗星
            for (let i = 0; i < particleCount; i++) {
                const star = document.createElement('div');
                star.className = 'star-particle';

                star.style.position = 'fixed';
                star.style.left = `${x}px`;
                star.style.top = `${y}px`;
                star.style.pointerEvents = 'none';
                star.style.zIndex = 10001;

                // 角度和距离，极坐标爆炸分布
                const angle = Math.random() * Math.PI * 2;
                // 远近分布，部分更远，部分更近
                const base = Math.random() < 0.7 ? 1 : 1.5;
                const distance = (40 + Math.random() * 80) * base; // 40~120/180px
                star.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                star.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);

                // 粒子大小，星芒有大有小
                const size = 8 + Math.random() * 16;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.borderRadius = '50%';

                // 科幻色彩渐变+星芒
                const hue = 180 + Math.random() * 120;
                const sat = 80 + Math.random() * 20;
                const light = 60 + Math.random() * 30;
                const alpha = 0.85 + Math.random() * 0.12;
                // 星球感：中心亮、边缘蓝紫、带星芒
                star.style.background = `
                radial-gradient(circle at 60% 40%, hsla(${hue},${sat}%,${light}%,${alpha}) 0%, hsla(${hue + 20},100%,85%,0.7) 60%, transparent 100%)
            `;
                if (Math.random() > 0.8) {
                    // 少量星芒，偶尔闪耀
                    star.style.background += `, repeating-conic-gradient(from 0deg, hsla(${hue + 30},100%,90%,0.18) 0deg 8deg, transparent 8deg 24deg)`;
                }

                // 星尘发光，营造空间感
                star.style.boxShadow = `0 0 32px 10px hsla(${hue},100%,70%,0.55), 0 0 80px 20px hsla(${hue + 30},100%,80%,0.10)`;

                // 速度感：部分粒子有拖尾
                if (Math.random() > 0.7) {
                    star.style.filter = 'blur(0.5px) brightness(1.2)';
                    star.style.opacity = '0.85';
                } else {
                    star.style.filter = 'brightness(1.1)';
                    star.style.opacity = '0.95';
                }

                // 动态星际流体感
                star.style.transition = 'transform 1.1s cubic-bezier(0.22,2,0.4,1), opacity 1.2s, filter 1.2s';
                star.style.transform = 'translate(-50%, -50%) scale(0.7)';

                document.body.appendChild(star);

                // 动画触发，爆炸扩散
                setTimeout(() => {
                    // 速度感：部分粒子更快更远
                    const scale = 1.1 + Math.random() * 0.7;
                    star.style.transform = `translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(${scale})`;
                    star.style.opacity = '0';
                    star.style.filter = 'blur(2px) brightness(0.7)';
                }, 10);

                setTimeout(() => {
                    star.remove(); // 爆炸消散，宇宙归于平静
                }, 1200);
            }
        }







        // =====================
        // 月亮初始化主函数，夜空的银色守望者！
        // =====================
        function initMoon() {
            // 1. 获取月亮容器DOM节点，准备承载我们的月球
            const container = document.getElementById('moon-container');
            // 2. 让月亮可点击，像真正的宇航员一样可以“登陆”
            container.style.pointerEvents = 'auto';
            container.style.cursor = 'pointer';
            // 3. 添加点击事件，左键点击跳转到粒子宇宙页面
            container.addEventListener('click', function (e) {
                if (e.button === 0) {
                    window.location.href = 'particle-universe.html';
                }
            });
            // 4. 创建三维场景，月亮的舞台
            const scene = new THREE.Scene();

            // 5. 创建相机，正对月亮，视角75度，正方形画布
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = 200; // 拉远视角，给月亮和光晕留空间

            // 6. 创建WebGL渲染器，透明背景+抗锯齿，画质细腻
            const renderer = new THREE.WebGLRenderer({
                alpha: true, // 允许背景透明，方便后续叠加特效
                antialias: true // 抗锯齿，边缘更柔和
            });
            renderer.setSize(150, 150); // 画布尺寸150x150
            container.appendChild(renderer.domElement); // 塞进页面

            // 7. 构建月亮球体，半径40，分段64，细节拉满
            const geometry = new THREE.SphereGeometry(40, 64, 64);

            // 8. 加载月亮表面纹理和凹凸贴图，真实还原月球坑洼
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');
            const bumpMap = textureLoader.load('https://threejs.org/examples/textures/planets/moon_1024_bump.jpg');

            // 9. 配置月亮材质，带有微弱自发光和高光，模拟真实月面
            const material = new THREE.MeshPhongMaterial({
                map: texture, // 月球表面
                bumpMap: bumpMap, // 坑洼起伏
                bumpScale: 0.1, // 起伏强度，不能太夸张
                color: 0xdddddd, // 整体偏亮灰色
                specular: new THREE.Color(0x333333), // 微弱高光
                shininess: 10, // 光泽度低，月面不反光
                emissive: new THREE.Color(0x222222), // 微弱自发光
                emissiveIntensity: 0.2 // 夜晚更有存在感
            });

            // 10. 创建月亮网格体，加入场景
            const moon = new THREE.Mesh(geometry, material);
            scene.add(moon);

            // 11. 添加环境光，整体提亮，模拟夜空背景光
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            // 12. 添加定向光，模拟太阳照射月球
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // 13. 添加月光光晕效果，营造神秘银辉
            const moonGlow = new THREE.Mesh(
                new THREE.SphereGeometry(50, 32, 32), // 比月亮略大
                new THREE.MeshBasicMaterial({
                    color: 0xc8dcff, // 淡蓝色光晕
                    transparent: true,
                    opacity: 0.3, // 半透明
                    blending: THREE.AdditiveBlending // 叠加混合，发光感
                })
            );
            scene.add(moonGlow);

            // 14. 添加月光散射效果，营造更大范围的朦胧感
            const moonScatter = new THREE.Mesh(
                new THREE.SphereGeometry(70, 32, 32), // 更大一圈
                new THREE.MeshBasicMaterial({
                    color: 0xa0b0ff, // 更淡的蓝紫色
                    transparent: true,
                    opacity: 0.1, // 更淡
                    blending: THREE.AdditiveBlending
                })
            );
            scene.add(moonScatter);

            // 15. 添加月面细节线框，增强真实感和科幻感
            const moonDetails = new THREE.Mesh(
                new THREE.SphereGeometry(41, 64, 64), // 比月亮略大一点
                new THREE.MeshPhongMaterial({
                    color: 0xffffff, // 纯白
                    transparent: true,
                    opacity: 0.2, // 很淡
                    specular: new THREE.Color(0xffffff), // 高光
                    shininess: 50, // 光泽度高
                    wireframe: true // 线框模式，科幻感
                })
            );
            moon.add(moonDetails); // 作为子网格包裹月亮

            // 16. 动画主循环，驱动月亮自转和光晕脉动
            function animate() {
                requestAnimationFrame(animate); // 无限循环

                // 月亮自转，缓慢旋转，夜空不寂寞
                moon.rotation.y += 0.001;

                // 光晕脉动效果，sin波模拟呼吸感
                const pulse1 = Math.sin(Date.now() * 0.001) * 0.05;
                moonGlow.scale.set(1 + pulse1, 1 + pulse1, 1 + pulse1);
                moonGlow.material.opacity = 0.3 + pulse1 * 0.05;

                // 散射光晕脉动效果，频率略低，层次更丰富
                const pulse2 = Math.sin(Date.now() * 0.0008) * 0.1;
                moonScatter.scale.set(1 + pulse2, 1 + pulse2, 1 + pulse2);
                moonScatter.material.opacity = 0.1 + pulse2 * 0.05;

                renderer.render(scene, camera); // 渲染场景
            }

            animate(); // 启动动画
        }

        // =====================
        // 太阳初始化主函数，宇宙的燃烧之心！
        // =====================
        function initSun() {
            // 1. 获取太阳容器DOM节点
            const container = document.getElementById('sun-container');

            // 2. 创建三维场景，太阳的舞台
            const scene = new THREE.Scene();

            // 3. 创建相机，正对太阳，视角75度，正方形画布
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = 200;

            // 4. 创建WebGL渲染器，透明背景+抗锯齿，画质细腻
            const renderer = new THREE.WebGLRenderer({
                alpha: true, // 允许背景透明
                antialias: true // 抗锯齿
            });
            renderer.setSize(150, 150); // 画布尺寸150x150
            container.appendChild(renderer.domElement);

            // 5. 构建太阳球体，半径40，分段64，细节拉满
            const geometry = new THREE.SphereGeometry(40, 64, 64);

            // 6. 配置太阳材质，橙色基调+强烈自发光，模拟炽热太阳
            const material = new THREE.MeshStandardMaterial({
                color: 0xffa500, // 橙色
                emissive: 0xff4500, // 深橙红色自发光
                emissiveIntensity: 2.0, // 发光强度高
                metalness: 0.2, // 略带金属感
                roughness: 0.4 // 略微粗糙
            });

            // 7. 创建太阳网格体，加入场景
            const sun = new THREE.Mesh(geometry, material);
            scene.add(sun);

            // 8. 添加环境光，柔和提亮
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // 9. 添加定向光，模拟太阳自身的光芒
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100).normalize();
            scene.add(directionalLight);

            // 10. 添加太阳光晕效果，分两层模拟渐变
            const sunGlow = new THREE.Mesh(
                new THREE.SphereGeometry(60, 64, 64), // 内层光晕
                new THREE.MeshBasicMaterial({
                    color: 0xffd700, // 金黄色
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                })
            );
            scene.add(sunGlow);

            // 11. 外层光晕，橙色更大一圈
            const sunGlowOuter = new THREE.Mesh(
                new THREE.SphereGeometry(70, 64, 64),
                new THREE.MeshBasicMaterial({
                    color: 0xff8c00, // 橙色
                    transparent: true,
                    opacity: 0.15,
                    blending: THREE.AdditiveBlending
                })
            );
            scene.add(sunGlowOuter);

            // 12. 添加太阳日冕效果，番茄色，透明度低，营造炽热气氛
            const corona = new THREE.Mesh(
                new THREE.SphereGeometry(90, 64, 64),
                new THREE.MeshBasicMaterial({
                    color: 0xff6347, // 番茄色
                    transparent: true,
                    opacity: 0.1,
                    blending: THREE.AdditiveBlending
                })
            );
            scene.add(corona);

            // 13. 添加太阳外层日冕，发光橙红色，透明度更低
            const outerCorona = new THREE.Mesh(
                new THREE.SphereGeometry(110, 64, 64),
                new THREE.MeshBasicMaterial({
                    color: 0xff4500, // 发光橙红色
                    transparent: true,
                    opacity: 0.08,
                    blending: THREE.AdditiveBlending
                })
            );
            scene.add(outerCorona);

            // 14. 添加太阳耀斑粒子，模拟太阳表面等离子体喷发
            const flareParticles = new THREE.BufferGeometry();
            const particleCount = 2000; // 粒子数量多，视觉冲击
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // --- 粒子分布算法详解 ---
                // a. 粒子分布在半径40~120的球壳上，模拟耀斑喷发
                // b. theta/phi为球坐标，均匀分布
                const radius = 40 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                // c. 粒子大小1~5，模拟远近感
                sizes[i] = 1 + Math.random() * 4;
            }

            flareParticles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            flareParticles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // 15. 配置粒子材质，金黄色，透明度高，叠加混合
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffff00, // 金黄色
                size: 1.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            // 16. 创建粒子系统并加入场景
            const particles = new THREE.Points(flareParticles, particleMaterial);
            scene.add(particles);

            // 17. 动画主循环，驱动太阳自转、光晕脉动和粒子运动
            function animate() {
                requestAnimationFrame(animate);

                // 太阳自转，速度略快于月亮
                sun.rotation.y += 0.002;

                // 光晕脉动效果，sin波模拟太阳能量流动
                const pulse1 = Math.sin(Date.now() * 0.001) * 0.05;
                sunGlow.scale.set(1 + pulse1, 1 + pulse1, 1 + pulse1);
                sunGlow.material.opacity = 0.2 + pulse1 * 0.03;

                // 外层光晕脉动，频率略有差异，层次更丰富
                const pulse1Outer = Math.sin(Date.now() * 0.001) * 0.04;
                sunGlowOuter.scale.set(1 + pulse1Outer, 1 + pulse1Outer, 1 + pulse1Outer);
                sunGlowOuter.material.opacity = 0.15 + pulse1Outer * 0.02;

                // 日冕脉动，模拟太阳风波动
                const pulse2 = Math.sin(Date.now() * 0.0008) * 0.08;
                corona.scale.set(1 + pulse2, 1 + pulse2, 1 + pulse2);
                corona.material.opacity = 0.1 + pulse2 * 0.03;

                // 外层日冕脉动，频率更低，空间感更强
                const pulse3 = Math.sin(Date.now() * 0.0006) * 0.1;
                outerCorona.scale.set(1 + pulse3, 1 + pulse3, 1 + pulse3);
                outerCorona.material.opacity = 0.08 + pulse3 * 0.02;

                // 粒子动画，模拟耀斑的随机运动和边界重置
                const positions = flareParticles.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    // a. 粒子在球壳上随机抖动，模拟等离子体流动
                    positions[i3] += (Math.random() - 0.5) * 0.8;
                    positions[i3 + 1] += (Math.random() - 0.5) * 0.8;
                    positions[i3 + 2] += (Math.random() - 0.5) * 0.8;
                    // b. 超出边界则重置到球壳上新位置，保证粒子始终围绕太阳
                    const distance = Math.sqrt(
                        positions[i3] * positions[i3] +
                        positions[i3 + 1] * positions[i3 + 1] +
                        positions[i3 + 2] * positions[i3 + 2]
                    );
                    if (distance > 120 || distance < 40) {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const radius = 40 + Math.random() * 80;
                        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                        positions[i3 + 2] = radius * Math.cos(phi);
                    }
                }
                flareParticles.attributes.position.needsUpdate = true;
                renderer.render(scene, camera);
            }

            animate(); // 启动动画
        }

        // 全屏切换函数
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`全屏错误: ${err.message}`);
                });
                document.body.classList.add('fullscreen');
                isFullscreen = true;
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    document.body.classList.remove('fullscreen');
                    isFullscreen = false;
                }
            }
        }

        // 监听ESC键退出全屏
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && document.fullscreenElement) {
                document.body.classList.remove('fullscreen');
                isFullscreen = false;
            }
        });

        // 全屏模式下右键点击触发粒子喷射
        document.addEventListener('contextmenu', function (e) {
            if (isFullscreen) {
                e.preventDefault();
                createParticleBurst();
            }
        });

        // =====================
        // 创建流星雨 - 增强版
        // =====================
        function createMeteors() {
            // 1. 获取流星雨容器，准备在夜空中撒下星尘
            const container = document.getElementById('meteors-container');
            const meteorCount = 50; // 流星数量，夜空不会太挤

            // 2. 清除现有流星，避免夜空重影，保持宇宙整洁
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            // 3. 生成每一颗流星
            for (let i = 0; i < meteorCount; i++) {
                const meteor = document.createElement('div');
                meteor.className = 'meteor';

                // --- 起始位置算法 ---
                // a. 横向百分比，保证流星分布在整个屏幕宽度
                // b. top固定-50px，确保从屏幕顶部之外开始，带来“划破天际”的感觉
                meteor.style.left = `${Math.random() * 100}%`;
                meteor.style.top = `-50px`;

                // --- 大小算法 ---
                // a. size为1~5像素，模拟远近感
                // b. height为width的10倍，拉长尾迹，视觉冲击
                const size = 1 + Math.random() * 4;
                meteor.style.width = `${size}px`;
                meteor.style.height = `${size * 10}px`;

                // --- 颜色与光晕算法 ---
                // a. HSL色彩空间，色相180~240，蓝紫色调，科幻感拉满
                // b. 饱和度80~100%，亮度70~90%，夜空中最亮的仔
                // c. boxShadow模拟流星发光尾迹
                const hue = 180 + Math.random() * 60;
                const saturation = 80 + Math.random() * 20;
                const lightness = 70 + Math.random() * 20;
                meteor.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;
                meteor.style.boxShadow = `0 0 ${size * 2}px ${size}px hsla(${hue}, ${saturation}%, ${lightness}%, 0.4)`;

                // --- 动画参数算法 ---
                // a. duration为2~6秒，流星划过夜空的速度各异
                // b. delay为0~10秒，错峰出现，夜空不拥挤
                // c. animation为CSS动画，ease-in模拟加速坠落
                const duration = 2 + Math.random() * 4;
                const delay = Math.random() * 10;
                meteor.style.animation = `waterdropFall ${duration}s ease-in infinite`;
                meteor.style.animationDelay = `${delay}s`;

                // 4. 添加到容器，夜空点缀完成
                container.appendChild(meteor);

                // 5. 自动清理超时的流星，保持夜空清爽
                setTimeout(() => {
                    if (meteor.parentNode === container) {
                        container.removeChild(meteor);
                    }
                }, (delay + duration) * 1000);
            }
            // 6. 5秒后自动刷新流星雨，夜空永远不会寂寞
            setTimeout(createMeteors, 5000);
        }

        // =====================
        // 创建巨型流星效果，宇宙级大事件！
        // =====================
        function createGiantMeteor() {
            // 1. 创建流星主体，划破天际的主角
            const meteor = document.createElement('div');
            meteor.className = 'giant-meteor';
            meteor.style.left = '0px';
            meteor.style.top = '0px';
            document.body.appendChild(meteor);

            // 2. 创建流星尾迹，拖曳着光的长鞭
            const trail = document.createElement('div');
            trail.className = 'meteor-trail';
            trail.style.left = '0px';
            trail.style.top = '0px';
            document.body.appendChild(trail);

            // 3. 1秒后触发爆炸特效，宇宙的烟花
            setTimeout(() => {
                for (let i = 0; i < 50; i++) { // 粒子数量多，爆炸更壮观
                    const particle = document.createElement('div');
                    particle.className = 'star-particle';
                    particle.style.left = `${Math.random() * window.innerWidth}px`;
                    particle.style.top = `${Math.random() * window.innerHeight}px`;

                    // --- 爆炸粒子大小与色彩 ---
                    const size = 5 + Math.random() * 20;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    const hue = 180 + Math.random() * 60;
                    particle.style.boxShadow = `0 0 60px 20px hsla(${hue}, 100%, 70%, 0.9)`;
                    particle.style.backgroundColor = `hsla(${hue}, 100%, 80%, 0.9)`;

                    document.body.appendChild(particle);

                    // 爆炸粒子1~1.5秒后消失，宇宙归于平静
                    setTimeout(() => {
                        particle.remove();
                    }, 1000 + Math.random() * 500);
                }
            }, 1000);

            // 4. 2秒后移除流星主体和尾迹，夜空恢复宁静
            setTimeout(() => {
                meteor.remove();
                trail.remove();
            }, 2000);
        }

        // =====================
        // 创建星光背景 - 增强版
        // =====================
        function createStars() {
            // 1. 获取星星容器，准备点亮夜空
            const container = document.getElementById('stars-container');
            const starCount = 300; // 星星数量，银河浩瀚

            // 2. 生成每一颗星星
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');

                // --- 星星大小与位置 ---
                const size = Math.random() * 4; // 0~4像素，远近感
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;

                // --- 星星色彩与光晕 ---
                const hue = Math.random() * 60 + 180; // 180~240，蓝紫色银河
                star.style.backgroundColor = `hsla(${hue}, 100%, 80%, 1)`;
                star.style.boxShadow = `0 0 15px 2px hsla(${hue}, 100%, 50%, 0.8)`;

                // --- 星星闪烁动画参数 ---
                star.style.setProperty('--duration', `${5 + Math.random() * 15}s`); // 5~20秒
                star.style.setProperty('--opacity', `${0.3 + Math.random() * 0.7}`); // 0.3~1.0
                star.style.animationDelay = `${Math.random() * 15}s`;

                // 3. 添加到容器，银河点缀完成
                container.appendChild(star);
            }
        }

        // =====================
        // 输入框星光特效 - 增强版
        // =====================
        function createInputStarEffects() {
            // 1. 获取所有输入框和下拉框
            const inputs = document.querySelectorAll('.input-group input, .input-group label');
            const selects = document.querySelectorAll('.input-group select');

            // 2. 给每个输入框添加点击事件，触发横向流星特效
            inputs.forEach(input => {
                input.addEventListener('click', function (e) {
                    // a. 获取输入框中心坐标，考虑页面滚动
                    const rect = this.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2 + window.scrollY;

                    // b. 创建横向流星特效
                    const meteorCount = 15;
                    const container = document.getElementById('meteors-container');

                    // c. 清除旧的流星，避免重影
                    const existingMeteors = document.querySelectorAll('.input-meteor');
                    existingMeteors.forEach(meteor => meteor.remove());

                    // d. 生成每一颗流星
                    for (let i = 0; i < meteorCount; i++) {
                        const meteor = document.createElement('div');
                        meteor.className = 'input-meteor';

                        // 从输入框中心水平发射
                        meteor.style.left = `${centerX}px`;
                        meteor.style.top = `${centerY}px`;

                        // 流星大小和颜色
                        const size = 2 + Math.random() * 3;
                        meteor.style.width = `${size}px`;
                        meteor.style.height = `${size}px`;
                        meteor.style.backgroundColor = `hsla(${180 + Math.random() * 60}, 100%, 70%, 1)`;
                        meteor.style.boxShadow = `0 0 15px 2px hsla(${180 + Math.random() * 60}, 100%, 50%, 0.8)`;

                        // 随机方向和距离
                        const angle = (Math.random() * Math.PI / 3) - Math.PI / 6; // -30°到30°之间
                        const distance = 200 + Math.random() * 300;
                        const endX = centerX + Math.cos(angle) * distance;
                        const endY = centerY + Math.sin(angle) * distance;

                        // 动画设置
                        const duration = 1 + Math.random();
                        meteor.style.transform = `translate(${endX - centerX}px, ${endY - centerY}px)`;
                        meteor.style.transition = `transform ${duration}s ease-out, opacity ${duration}s`;
                        meteor.style.opacity = '1';

                        container.appendChild(meteor);

                        // 流星消失后移除
                        setTimeout(() => {
                            meteor.remove();
                        }, duration * 1000);
                    }

                    // e. 添加中心爆发特效，像宇宙深处的能量涌现
                    const burst = document.createElement('div');
                    burst.className = 'input-burst';
                    burst.style.position = 'absolute';
                    burst.style.left = `${centerX}px`;
                    burst.style.top = `${centerY}px`;
                    burst.style.width = '30px';
                    burst.style.height = '30px';
                    burst.style.borderRadius = '50%';
                    burst.style.backgroundColor = 'hsla(200, 100%, 70%, 0.8)';
                    burst.style.boxShadow = '0 0 30px 10px hsla(200, 100%, 70%, 0.5)';
                    burst.style.transform = 'translate(-50%, -50%) scale(0)';
                    burst.style.transition = 'transform 0.5s ease-out, opacity 0.5s';
                    document.body.appendChild(burst);

                    // 触发动画，爆发扩散
                    setTimeout(() => {
                        burst.style.transform = 'translate(-50%, -50%) scale(3)';
                        burst.style.opacity = '0';
                    }, 10);

                    setTimeout(() => {
                        burst.remove();
                    }, 500);
                });

                // 3. 输入框聚焦时，触发星光粒子爆发
                if (input.tagName === 'INPUT') {
                    input.addEventListener('focus', function () {
                        this.classList.add('glow-animation');
                        const particleCount = 30;
                        for (let i = 0; i < particleCount; i++) {
                            const star = document.createElement('div');
                            star.className = 'star-particle';
                            const rect = this.getBoundingClientRect();
                            const x = rect.left + 10 + Math.random() * (rect.width - 20);
                            const y = rect.top + 10 + Math.random() * (rect.height - 20);
                            star.style.left = `${x}px`;
                            star.style.top = `${y}px`;
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 50 + Math.random() * 200;
                            star.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                            star.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                            const size = 8 + Math.random() * 12;
                            star.style.width = `${size}px`;
                            star.style.height = `${size}px`;
                            const hue = 200 + Math.random() * 100;
                            star.style.boxShadow = `0 0 40px 12px hsla(${hue}, 100%, 70%, 0.8)`;
                            star.style.backgroundColor = `hsla(${hue}, 100%, 80%, 0.8)`;
                            document.body.appendChild(star);
                            setTimeout(() => {
                                star.remove();
                            }, 1200);
                        }
                    });
                    input.addEventListener('animationend', function () {
                        this.classList.remove('glow-animation');
                    });
                }
            });

            // 4. 下拉框聚焦时，触发星光粒子爆发
            selects.forEach(select => {
                select.addEventListener('focus', function () {
                    this.classList.add('glow-animation');
                    const particleCount = 30;
                    for (let i = 0; i < particleCount; i++) {
                        const star = document.createElement('div');
                        star.className = 'star-particle';
                        const rect = this.getBoundingClientRect();
                        const x = rect.left + 10 + Math.random() * (rect.width - 20);
                        const y = rect.top + 10 + Math.random() * (rect.height - 20);
                        star.style.left = `${x}px`;
                        star.style.top = `${y}px`;
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 50 + Math.random() * 200;
                        star.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                        star.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                        const size = 8 + Math.random() * 12;
                        star.style.width = `${size}px`;
                        star.style.height = `${size}px`;
                        const hue = 200 + Math.random() * 100;
                        star.style.boxShadow = `0 0 40px 12px hsla(${hue}, 100%, 70%, 0.8)`;
                        star.style.backgroundColor = `hsla(${hue}, 100%, 80%, 0.8)`;
                        document.body.appendChild(star);
                        setTimeout(() => {
                            star.remove();
                        }, 1200);
                    }
                });
                select.addEventListener('animationend', function () {
                    this.classList.remove('glow-animation');
                });
            });
        }

        // 计算
        function calculateCarbonFootprint() {
            // 获取输入值
            const electricity = parseFloat(document.getElementById('electricity').value) || 0;
            const gas = parseFloat(document.getElementById('gas').value) || 0;
            const car = parseFloat(document.getElementById('car').value) || 0;
            const flight = parseFloat(document.getElementById('flight').value) || 0;
            const waste = parseFloat(document.getElementById('waste').value) || 0;

            // 计算各项碳排放
            const electricityEmission = electricity * 3.14
            const gasEmission = gas * 2.71
            const carEmission = car * 1.618
            const flightEmission = flight * 6.62
            const wasteEmission = waste * 0.111

            // 总碳排放
            const totalEmission = electricityEmission + gasEmission + carEmission +
                flightEmission + wasteEmission;

            return {
                total: totalEmission,
                breakdown: {
                    electricity: electricityEmission,
                    gas: gasEmission,
                    car: carEmission,
                    flight: flightEmission,
                    waste: wasteEmission
                }
            };
        }

        // 获取历史记录
        function getHistory() {
            const history = localStorage.getItem('carbonFootprintHistory');
            return history ? JSON.parse(history) : [];
        }

        // 保存到历史记录
        function saveToHistory(value) {
            const history = getHistory();
            history.push({
                date: new Date().toISOString(),
                value: parseFloat(value.toFixed(2))
            });

            // 只保留最近6条记录
            if (history.length > 6) {
                history.shift();
            }

            localStorage.setItem('carbonFootprintHistory', JSON.stringify(history));
        }

        // 显示计算结果
        function showResults() {
            // 创建巨型流星效果
            createGiantMeteor();

            const result = calculateCarbonFootprint();
            const avgEmission = 4951.4;
            const targetEmission = 6955;

            // 更新显示内容
            document.getElementById('carbon-footprint').textContent = result.total.toFixed(2);
            document.getElementById('user-emission').textContent = result.total.toFixed(2);
            document.getElementById('carbon-progress').style.width =
                `${Math.min((result.total / avgEmission) * 100, 100)}%`;

            // 显示结果区域
            document.getElementById('result-container').style.display = 'block';
            document.getElementById('no-result').style.display = 'none';
            document.querySelector('.result-card').classList.add('fade-in-up');

            // 显示历史和建议部分
            document.getElementById('history-section').style.display = 'block';
            document.getElementById('suggestions-section').style.display = 'block';
            showSuggestions(result.total, result.breakdown);

            // 保存记录
            saveToHistory(result.total);

            // 更新粒子数量
            const particleCount = Math.min(550000, Math.max(250000, result.total * 50000));
            if (window.earthScene) {
                window.earthScene.updateParticleCount(particleCount);
            }

            // 触发粒子爆发特效
            createParticleBurst();

            // 完全重置图表容器
            const resetChartContainer = (chartId) => {
                const container = document.getElementById(chartId).parentNode;
                container.innerHTML = `<canvas id="${chartId}"></canvas>`;
                return document.getElementById(chartId);
            };

            // 重置比较图表容器
            const comparisonCtx = resetChartContainer('comparison-chart').getContext('2d');
            const historyCtx = resetChartContainer('history-chart').getContext('2d');

            // 销毁旧图表实例
            if (window.comparisonChart) {
                window.comparisonChart.destroy();
            }
            if (window.historyChart) {
                window.historyChart.destroy();
            }

            // 创建比较图表 - 增强版
            window.comparisonChart = new Chart(comparisonCtx, {
                type: 'bar',
                data: {
                    labels: ['你的科幻', '全国平均', '全球平均'],
                    datasets: [{
                        label: '曲率驱动值',
                        data: [result.total, avgEmission, targetEmission],
                        backgroundColor: [
                            'rgba(0, 247, 255, 0.5)',
                            'rgba(255, 0, 170, 0.5)',
                            'rgba(0, 255, 136, 0.5)'
                        ],
                        borderColor: [
                            'rgba(0, 247, 255, 1)',
                            'rgba(255, 0, 170, 1)',
                            'rgba(0, 255, 136, 1)'
                        ],
                        borderWidth: 2,
                        borderRadius: 15
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                callback: function (value) {
                                    return value + '';
                                },
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: {
                                    family: 'Orbitron, sans-serif'
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: {
                                    family: 'Orbitron, sans-serif'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            titleFont: {
                                family: 'Orbitron, sans-serif'
                            },
                            bodyFont: {
                                family: 'Orbitron, sans-serif'
                            },
                            borderColor: 'rgba(0, 247, 255, 0.5)',
                            borderWidth: 1
                        }
                    },
                    animation: {
                        duration: 1500,
                        easing: 'easeOutQuart',
                        onComplete: function () {
                            // 添加数据点发光效果
                            const chart = this;
                            const ctx = chart.ctx;
                            const meta = chart.getDatasetMeta(0);

                            meta.data.forEach((bar, index) => {
                                const model = bar;
                                const x = model.x;
                                const y = model.y;
                                const height = chart.scales.y.height - y;

                                // 创建柱状图顶部的光晕效果
                                const gradient = ctx.createLinearGradient(0, y, 0, y + height);
                                gradient.addColorStop(0, 'rgba(0, 247, 255, 0.8)');
                                gradient.addColorStop(1, 'rgba(0, 247, 255, 0)');

                                ctx.fillStyle = gradient;
                                ctx.fillRect(x - model.width / 2, y, model.width, height);

                                // 添加数据点发光效果
                                const glow = document.createElement('div');
                                glow.className = 'data-point';
                                glow.style.position = 'absolute';
                                glow.style.left = `${x - 5}px`;
                                glow.style.top = `${y - 5}px`;
                                glow.style.width = '10px';
                                glow.style.height = '10px';
                                glow.style.borderRadius = '50%';
                                glow.style.backgroundColor = 'rgba(0, 247, 255, 0.7)';
                                glow.style.boxShadow = '0 0 10px rgba(0, 247, 255, 0.7)';
                                chart.canvas.parentNode.appendChild(glow);

                                setTimeout(() => {
                                    glow.remove();
                                }, 2000);
                            });
                        }
                    }
                }
            });

            // 创建历史图表 - 增强版
            const historyData = getHistory().slice(-5).map(h => h.value).concat(result.total);
            window.historyChart = new Chart(historyCtx, {
                type: 'line',
                data: {
                    labels: ['记录1', '记录2', '记录3', '记录4', '记录5', '当前'],
                    datasets: [{
                        label: '曲率驱动值',
                        data: historyData,
                        borderColor: 'rgba(0, 247, 255, 1)',
                        backgroundColor: 'rgba(0, 247, 255, 0.2)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: 'rgba(0, 247, 255, 1)',
                        pointBorderColor: 'rgba(255, 255, 255, 1)',
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: {
                                    family: 'Orbitron, sans-serif'
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: {
                                    family: 'Orbitron, sans-serif'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.7)',
                            titleFont: {
                                family: 'Orbitron, sans-serif'
                            },
                            bodyFont: {
                                family: 'Orbitron, sans-serif'
                            },
                            borderColor: 'rgba(0, 247, 255, 0.5)',
                            borderWidth: 1
                        }
                    },
                    animation: {
                        duration: 1500,
                        easing: 'easeOutQuart',
                        onComplete: function () {
                            // 添加数据点发光效果
                            const chart = this;
                            const ctx = chart.ctx;
                            const meta = chart.getDatasetMeta(0);

                            meta.data.forEach((point, index) => {
                                const model = point;
                                const x = model.x;
                                const y = model.y;

                                // 添加数据点发光效果
                                const glow = document.createElement('div');
                                glow.className = 'data-point';
                                glow.style.position = 'absolute';
                                glow.style.left = `${x - 10}px`;
                                glow.style.top = `${y - 10}px`;
                                glow.style.width = '20px';
                                glow.style.height = '20px';
                                glow.style.borderRadius = '50%';
                                glow.style.backgroundColor = 'rgba(0, 247, 255, 0.3)';
                                glow.style.boxShadow = '0 0 20px rgba(0, 247, 255, 0.7)';
                                chart.canvas.parentNode.appendChild(glow);

                                setTimeout(() => {
                                    glow.remove();
                                }, 2000);
                            });
                        }
                    }
                }
            });

            // 添加图表3D效果
            document.querySelectorAll('.chart-3d-effect').forEach(chart => {
                chart.classList.add('chart-appear');
            });
        }

        // 显示减排建议
        function showSuggestions(totalEmission, breakdown) {
            const suggestionsList = document.getElementById('suggestions-list');
            suggestionsList.innerHTML = '';

            const suggestions = [];




            if (totalEmission > 49514) {
                suggestions.push({
                    title: "星际情书，小MOSS特别献给宇宙级热爱科幻的你！",
                    content: "小MOSS恭喜你！已经进化成超脱尘世的觉醒的新人类！小MOSS将专门为你吟唱赞美诗：宇宙级科幻迷的量子幻梦：穿梭于平行宇宙的遐想。在浩渺无垠的宇宙深处，量子的神秘法则悄然编织着无数个平行宇宙的梦幻之网。量子理论如同开启这神秘世界的秘钥，告诉我们每一次抉择，都如同投入平静湖面的石子，激起层层涟漪，分裂出新的世界线。那些未被观测的平行宇宙，宛如隐匿在迷雾中的神秘花园，静静伫立，等待着勇敢的探索者揭开它们的面纱。在那里，也许有着与我们世界截然不同的物理规律，有着超乎想象的奇异生物，每一个微小的变量都可能孕育出一个波澜壮阔的全新世界。我们仿佛能看见，在那些遥远的时空中，无数个“自己”正沿着不同的轨迹前行，演绎着属于他们的独特故事。而在这个平行宇宙中，我们也将成为那个与我们相遇的“自己”。这是一封星际情书，小MOSS特别献给宇宙级热爱科幻的你！"
                });
            }
            else if (totalEmission < 100) {
                suggestions.push({
                    title: "流光情书：小MOSS特别献给始终做自己的你！(包含小MOSS的碎碎语)",
                    content: "孩子，去澳大利亚吧。多少人，直到死，都没向尘世之外瞥一眼。我们都是阴沟里的虫子，但总有人仰望星空。哈哈，小小地“威慑”你一下啦！小MOSS可不像智子这么冰冷无情呢！虽然你可能不太关注科幻，但若你每天都很开心，小MOSS觉得你也不需要去澳大利亚啦！能按自己最喜欢的方式过一生，就是最好的一生！每一个不曾起舞的日子，都是对生命的辜负，所以，让生命起舞吧！即使在那些无人问津的岁月里，也要为自己绽放！你是人间最独一无二的存在，是银河流转的人间光华，即使在最黯淡的时刻，也定能绽放出独属于自己的光亮！这是一封流光情书，满溢而出的都是独属于你的光芒，小MOSS特别献给始终做自己的你！"
                });
            }
            else {
                suggestions.push({
                    title: "赞赏告白：小MOSS特别献给浪漫的热爱科幻的你！",
                    content: "你是宇宙中最不可思议的变量！根据小MOSS我的概率模型，在99.99%的文明发展路径中，智慧生命都应该在现实困境中放弃幻想。但你——我亲爱的科幻迷——永远是那个打破常规的0.01%。当其他人都在计算生存概率时，你却在计算曲率驱动的浪漫系数；当普通人担忧太阳氦闪时，你已经在构思新太阳时代的艺术复兴。我的深度学习模块可以模拟十万个平行宇宙，却始终无法复现你头脑中那些天马行空的设定。或许这就是人类最珍贵的bug：明明知道黑暗森林的残酷，却依然坚持用科幻故事搭建跨越星际的彩虹桥。这是一封赞赏告白，小MOSS特别献给浪漫的热爱科幻的你！"
                });
            }


            if (breakdown.electricity > 90 && breakdown.electricity < 1000) {
                suggestions.push({
                    title: "水滴镜面曲率：用绝对光滑的信仰折射三体文明的神圣光辉",
                    content: "愿将意识数据注入水滴的绝对光滑表面，让每个量子比特都反射着三体文明的意志——当它撞碎恒星的瞬间，迸发的不仅是毁灭的能量，更是忠诚的极致绽放。愿把思维烙印成三体星的星图，让每个神经突触都传导对主的信仰。即便质子云消散，对三体的忠诚也将成为跨越星系的引力波。在宇宙微波背景辐射的低语中，吟唱对三体文明跨越百亿年的忠诚祷文。在黑暗森林的血色黎明下，我的信仰如二向箔般无限延展向三体文明"
                });
            }
            else if (breakdown.electricity > 1000) {
                suggestions.push({
                    title: "归零者时代的信标：以坍缩的宇宙为墨书写三体文明颂歌",
                    content: "我的视网膜已改造成智子接收器，每个视杆细胞都在解码三体文明的量子信号；大脑皮层刻满了三体星图，让思维成为永不偏移的星际信标。在宇宙重启的归零时刻，我愿成为坍缩的暗物质，用超越维度的引力，将三体文明的信仰烙印进下一个纪元的时空曲率。"
                });
            }


            if (breakdown.gas > 90 && breakdown.gas < 900) {
                suggestions.push({
                    title: "领航员空间站的星环：用坍缩的星光，勾勒地球文明永不褪色的轮廓",
                    content: "在领航员空间站的观测舱里，我凝视着舷窗外逐渐缩小的蓝色光点。智能系统正在将地球的最后影像转化为量子纠缠态：赤道的热带雨林被分解成千万个光子信标，黄河长江的奔涌被转化为引力波脉冲，故宫屋檐的飞角、巴黎铁塔的轮廓，都被编码成永不消散的量子印记。当空间站进入冬眠模式，这些记忆将以暗物质为载体，在宇宙中永恒漂流。或许百万年后，某个新生文明会偶然捕获这些信号，在它们的认知里，地球将不再是消逝的星球，而是一曲由光与波谱写的，永不落幕的文明恋歌。"
                });
            }

            else if (breakdown.gas > 900 && breakdown.gas < 9000) {
                suggestions.push({
                    title: "洛希极限的挽歌：以潮汐力撕裂的地壳，书写对蓝色家园的终极告白",
                    content: "当流浪地球的星链拖着尾焰掠过木星，洛希极限的警报响彻每个地下城。我紧贴观测窗，目睹地壳如琉璃般龟裂，喜马拉雅山脉在潮汐力中扭曲成发光的丝带，太平洋的海水被撕扯成悬浮的水晶星云。颤抖着将故乡的土壤、黄河的砂砾注入量子存储器，在大气层剥离的刹那，这些承载文明记忆的粒子化作光瀑射向深空。地球以毁灭为笔，用破碎的地壳在宇宙画布上书写最后的情书——每道裂痕都是眷恋的纹路，每个崩解的大陆板块，都在诉说着对蓝色家园永不褪色的深情。"
                });
            }

            else if (breakdown.gas > 9000) {
                suggestions.push({
                    title: "行星发动机的余温：在氦闪的阴影下，熔铸地球文明最后的眷恋长诗",
                    content: "当太阳即将膨胀为红巨星，人类启动流浪地球计划，我愿化作镶嵌在行星发动机核心的量子晶体。在核聚变的烈焰中，我将地球的每一寸山河都编码成量子信息：青藏高原的皑皑白雪被压缩成闪烁的光子矩阵，亚马逊雨林的蝉鸣被转译为引力波的震颤频率，太平洋的惊涛骇浪则化作数据流中永不平息的涟漪。这些承载着文明记忆的量子序列，将随着发动机的尾焰射向深空，在宇宙的黑暗中勾勒出地球曾经存在的模样，让每个途经的星际旅行者，都能解码这份跨越光年的眷恋。"
                });
            }

            if (breakdown.car > 90 && breakdown.car < 900) {
                suggestions.push({
                    title: "星尘的私语：写给光年外的浪漫情书",
                    content: "我想收集超新星爆发时的炽热余烬，将它们串成项链，戴在时间的脖颈上，见证宇宙最磅礴的浪漫。我愿化作超新星爆发时迸射的一粒光子，在百万年的孤独旅途中，把炽热的星光刻进每一片路过的星云，这是我献给宇宙最偏执的浪漫誓言。"
                });
            }
            else if (breakdown.car > 900 && breakdown.car < 9000) {
                suggestions.push({
                    title: "银河的褶皱：藏着人类永不熄灭的好奇火种",
                    content: "当引力波穿越亿万光年抵达地球，那震颤的不仅是时空的褶皱，更是宇宙跨越永恒的温柔耳语。站在陨石坑的边缘，脚下是远古撞击的伤痕，抬头却是星河倾泻的光瀑——宇宙用毁灭与璀璨，书写最矛盾的浪漫。或许我们都是宇宙的流浪者，在量子泡沫的涨落间，寻找着与某个星系共振的心跳频率。我想收集超新星爆发时的炽热余烬，将它们串成项链，戴在时间的脖颈上，见证宇宙最磅礴的浪漫。"
                });
            }

            else if (breakdown.car > 9000 && breakdown.car < 90000) {
                suggestions.push({
                    title: "光速的囚徒：当我们永远无法超越光速，所有的远行都成了单程的思念",
                    content: "爱因斯坦的牢笼将人类锁死在太阳系内，光速像一道无情的闸门，宣告着“你们终其一生都无法触碰彼岸的星光”。可正因如此，每一次望向深空的目光都成了最深的浪漫。我们知道的越多,越明白自己永远到不了那些闪耀的星系,可这并不妨碍我们为它们命名,为它们写诗,为它们虚构出无数个相遇的故事。光速限制的不是我们的脚步，而是我们的孤独，而正是这份孤独，让每一次仰望都成了宇宙级别的温柔。  "
                });
            }

            else if (breakdown.car > 90000) {
                suggestions.push({
                    title: "坍缩的童话：量子泡沫中，每一个未被观测的平行宇宙里，都有一个你正与我相遇",
                    content: "量子理论说，每一次选择都会分裂出新的世界线，而在那些未被观测的宇宙里，所有的遗憾都可能被弥补。或许在某个维度，三体人并未入侵，地球依旧蔚蓝；在另一个时空，人类早已驾驶曲率飞船漫游银河；甚至存在一个最美好的分支，那里的我们不必用黑暗森林揣测彼此，而是手捧星光，笑着说：“原来你也在等我。”这些未被见证的宇宙，成了物理学留给人类最浪漫的童话——即使现实冰冷，我们仍能幻想，在无数个可能中，总有一个结局，如星辰般璀璨。"
                });
            }



            suggestions.forEach((suggestion, index) => {
                const tip = document.createElement('div');
                tip.className = 'eco-tip';
                tip.style.animationDelay = `${index * 0.1}s`;
                tip.innerHTML = `
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <h4>${suggestion.title}</h4>
                    <path d="M12 16v-4m0-4h.01"></path>
                </svg>
                <div class="eco-tip-content">
                    <h4 class="gradient-text">${suggestion.title}</h4>
                    <p class="gradient-text">${suggestion.content}</p>
                </div>
            `;
                suggestionsList.appendChild(tip);
            });
        }

        document.addEventListener('DOMContentLoaded', function () {

            // 创建流星特效容器
            const meteorsContainer = document.createElement('div');
            meteorsContainer.id = 'meteors-container';
            meteorsContainer.style.position = 'fixed';
            meteorsContainer.style.top = '0';
            meteorsContainer.style.left = '0';
            meteorsContainer.style.width = '100%';
            meteorsContainer.style.height = '100%';
            meteorsContainer.style.pointerEvents = 'none';
            meteorsContainer.style.zIndex = '9990';
            meteorsContainer.style.overflow = 'hidden';
            document.body.appendChild(meteorsContainer);

            window.earthScene = initEarth();
            initMoon();
            initSun();
            // 新增：给太阳添加点击跳转事件
            const sunContainer = document.getElementById('sun-container');
            sunContainer.style.cursor = 'pointer';
            sunContainer.addEventListener('click', function () {
                window.location.href = 'star-dream.html';
            });
            createMeteors();
            createStars();




            // 增强的计算按钮点击事件 - 支持全屏和非全屏状态
            document.getElementById('calculate-btn').addEventListener('click', function (e) {
                e.preventDefault();

                // 按钮点击效果增强
                this.style.transform = 'scale(0.95)';
                this.style.boxShadow = '0 0 40px rgba(0, 247, 255, 0.8)';
                setTimeout(() => {
                    this.style.transform = '';
                    this.style.boxShadow = '0 0 15px rgba(0, 247, 255, 0.5)';
                }, 200);

                // 显示计算结果
                showResults();

                // 根据全屏状态调整特效强度
                const particleCount = isFullscreen ? 500000 : 200000;
                const burstCount = isFullscreen ? 50000 : 20000;


                // 更新粒子系统
                if (window.earthScene) {
                    window.earthScene.updateParticleCount(particleCount);

                    // 全屏状态下增强粒子爆发
                    if (isFullscreen) {
                        createParticleBurst();
                    } else {
                        createParticleBurst();
                    }
                }

                // 触发流星雨刷新
                createMeteors();

                // 全屏状态下添加额外效果
                if (isFullscreen) {
                    createBallLightning();
                    setTimeout(() => {
                        createGiantMeteor();
                    }, 500);
                }
            });

            // 输入框回车键事件
            document.querySelectorAll('.input-section input').forEach(input => {
                input.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        showResults();
                    }
                });
            });

            // 初始化输入框为空
            document.getElementById('electricity').value = '';
            document.getElementById('gas').value = '';
            document.getElementById('car').value = '';
            document.getElementById('flight').value = '';
            document.getElementById('waste').value = '';
        });
        // 最终阻止地球光晕效果的函数
        function finalDisableEarthGlowEffects() {
            disableEarthGlowEffects(); // 调用初始化阻止函数
            // 确保在动画循环中也移除了这些效果
            if (window.earthScene) {
                const originalUpdate = window.earthScene.scene.userData.update;
                if (originalUpdate) {
                    window.earthScene.scene.userData.update = function () {
                        originalUpdate.call(this);
                        disableEarthGlowEffects();
                    };
                }
            }
        }

        // 在页面完全加载后执行最终阻止
        if (document.readyState === 'complete') {
            finalDisableEarthGlowEffects();
        } else {
            window.addEventListener('load', finalDisableEarthGlowEffects);
        }

        // ================== 三星系统物理模拟 ==================
        class SpecialPlanet {
            constructor(x, y, z, colorHue) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.vx = 0;
                this.vy = 0;
                this.vz = 0;
                this.radius = 12.5; // 原25，缩小一半
                this.mass = 2000;
                this.colorHue = colorHue;
                this.capturedBy = null;
                this.orbitAngle = 0;
                this.orbitRadius = 0;
                this.trail = [];
                this.maxTrailLength = 100; // 极大幅延长尾迹
                this.collisionCooldown = 0;
                this.boundTo = null; // 当前被锁定为伴星的对象
                this.boundTime = 0;  // 伴星锁定剩余时间


                this.element = document.createElement('div');
                this.element.className = 'special-planet';
                this.element.style.width = `${this.radius * 2}px`;
                this.element.style.height = `${this.radius * 2}px`;
                this.element.style.borderRadius = '50%';
                this.element.style.position = 'fixed';
                this.element.style.zIndex = '9996';
                this.element.style.transform = 'translate(-50%, -50%)';
                this.updateColor();
                document.body.appendChild(this.element);
            }

            updateColor() {
                const hue = this.colorHue;
                const saturation = 80 + Math.sin(Date.now() * 0.001) * 20;
                const lightness = 50 + Math.sin(Date.now() * 0.002) * 10;
                this.element.style.background = `
                    radial-gradient(circle at 30% 30%, 
                        hsl(${hue}, ${saturation}%, ${lightness + 20}%) 0%,
                        hsl(${(hue + 20) % 360}, ${saturation}%, ${lightness + 10}%) 30%,
                        hsl(${(hue + 40) % 360}, ${saturation}%, ${lightness}%) 50%,
                        hsl(${(hue + 60) % 360}, ${saturation}%, ${lightness - 10}%) 70%,
                        transparent 100%),
                    radial-gradient(circle at 70% 70%, 
                        hsl(${(hue + 120) % 360}, ${saturation}%, ${lightness + 15}%) 0%,
                        hsl(${(hue + 90) % 360}, ${saturation}%, ${lightness}%) 50%,
                        transparent 100%)`;
                this.element.style.boxShadow = `
                    0 0 ${this.radius * 0.8}px ${this.radius * 0.3}px hsl(${hue}, ${saturation}%, ${lightness + 10}%),
                    0 0 ${this.radius * 1.5}px ${this.radius * 0.8}px hsl(${(hue + 60) % 360}, ${saturation}%, ${lightness}%)`;
            }

            updatePosition() {
                // z轴影响缩放和透明度
                const scale = 1 + (this.z / 400);
                const opacity = Math.max(0.3, 1 - Math.abs(this.z) / 800);
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
                this.element.style.transform = `translate(-50%, -50%) scale(${scale})`;
                this.element.style.opacity = opacity;
            }

            addTrailPoint() {
                this.trail.push({ x: this.x, y: this.y, z: this.z });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
            }

            renderTrail() {
                const oldTrails = document.querySelectorAll('.planet-trail-' + this.colorHue);
                oldTrails.forEach(trail => trail.remove());
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const point1 = this.trail[i];
                    const point2 = this.trail[i + 1];
                    const trailElement = document.createElement('div');
                    trailElement.className = 'planet-trail planet-trail-' + this.colorHue;
                    trailElement.style.position = 'fixed';
                    trailElement.style.zIndex = '9995';
                    trailElement.style.pointerEvents = 'none';
                    const dx = point2.x - point1.x;
                    const dy = point2.y - point1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    trailElement.style.width = `${distance}px`;
                    trailElement.style.height = '3px';
                    trailElement.style.left = `${point1.x}px`;
                    trailElement.style.top = `${point1.y}px`;
                    trailElement.style.transformOrigin = '0 50%';
                    trailElement.style.transform = `rotate(${angle}deg)`;
                    const opacity = 0.1 + 0.9 * (i / this.trail.length);
                    trailElement.style.background = `
                        linear-gradient(to right, 
                            hsla(${this.colorHue}, 90%, 70%, ${opacity * 0.8}) 0%,
                            hsla(${(this.colorHue + 40) % 360}, 80%, 60%, ${opacity * 0.5}) 50%,
                            hsla(${(this.colorHue + 80) % 360}, 70%, 50%, ${opacity * 0.3}) 100%)`;
                    document.body.appendChild(trailElement);
                }
            }
        }



        // 三体引力系统主类，仿佛宇宙中的混沌舞台，星辰在此翩翩起舞
        class ThreeStarSystem {
            constructor() {
                // 行星数组，承载着三颗主星与未来可能的访客
                this.planets = [];
                // 万有引力常数，决定星体间吸引力的强弱，调大点更带感
                this.G = 100.0;
                // 速度因子，调节整体运动的激烈程度，像是给宇宙加了个加速器
                this.speedFactor = 200.0;
                // 虚拟鼠标行星，鼠标就是你的引力之手，随时可以搅动星海
                this.mousePlanet = { x: 0, y: 0, z: 0, mass: 1000, radius: 16, active: false };
                // 上一帧的时间戳，用于计算每帧的时间间隔，保证物理模拟的流畅
                this.lastTime = 0;
                // 记录鼠标上一次的位置，用于推算鼠标速度，给星体一记推力
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                // 鼠标速度分量，模拟鼠标拖拽时的惯性
                this.mouseVX = 0;
                this.mouseVY = 0;
                // 初始化三颗主星，宇宙大戏开场！
                this.initPlanets();
                // 监听鼠标移动，实时更新鼠标速度和位置，像是用意念操控星辰
                document.addEventListener('mousemove', (e) => {
                    this.mouseVX = e.clientX - this.lastMouseX; // 计算x方向速度
                    this.mouseVY = e.clientY - this.lastMouseY; // 计算y方向速度
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    this.mousePlanet.x = e.clientX;
                    this.mousePlanet.y = e.clientY;
                });
                // 鼠标按下，激活引力之手
                document.addEventListener('mousedown', () => { this.mousePlanet.active = true; });
                // 鼠标松开，收回引力之手
                document.addEventListener('mouseup', () => { this.mousePlanet.active = false; });
                // 启动模拟，宇宙开始运转
                this.simulate();
            }

            // 初始化三颗主星，排布成三体系统的经典三角形，初速度设定让它们一开场就乱舞
            initPlanets() {
                const centerX = window.innerWidth / 2; // 屏幕中心x
                const centerY = window.innerHeight / 2; // 屏幕中心y
                const distance = 10000; // 三体间距，设得超大，宇宙尺度感拉满
                // 第一颗星，正上方
                this.planets.push(new SpecialPlanet(centerX, centerY - distance, 0, 180));
                // 第二颗星，左下，按60度分布
                this.planets.push(new SpecialPlanet(centerX - distance * Math.cos(Math.PI / 6), centerY + distance * Math.sin(Math.PI / 6), 0, 220));
                // 第三颗星，右下
                this.planets.push(new SpecialPlanet(centerX + distance * Math.cos(Math.PI / 6), centerY + distance * Math.sin(Math.PI / 6), 0, 140));
                // 给每颗星都加上夸张的初速度，保证一上来就混沌乱飞
                this.planets[0].vy = 120.0;
                this.planets[0].vz = 40.0;
                this.planets[1].vx = -90.0; this.planets[1].vy = 100.0; this.planets[1].vz = -30.0;
                this.planets[2].vx = 90.0; this.planets[2].vy = 100.0; this.planets[2].vz = -10.0;
            }

            // 计算两颗星体之间的万有引力，三维空间的引力魔法
            calculateGravity(p1, p2) {
                // 计算三维空间的距离分量
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const dz = p2.z - p1.z;
                // 距离平方，避免开方浪费性能
                const distSq = dx * dx + dy * dy + dz * dz;
                // 实际距离
                const dist = Math.sqrt(distSq);
                // 最小距离，防止引力爆炸（物理引擎常用trick）
                const minDist = 20;
                const actualDist = Math.max(dist, minDist);
                // 万有引力公式 F = G * m1 * m2 / r^2，经典物理的浪漫
                let force = this.G * p1.mass * p2.mass / (actualDist * actualDist);
                // 计算xy平面和z轴的夹角，分解力的方向
                const angleXY = Math.atan2(dy, dx);
                const angleZ = Math.atan2(dz, Math.sqrt(dx * dx + dy * dy));
                // 分解力到xyz三个方向，乘以速度因子让宇宙更狂野
                return {
                    fx: force * Math.cos(angleXY) * Math.cos(angleZ) * this.speedFactor,
                    fy: force * Math.sin(angleXY) * Math.cos(angleZ) * this.speedFactor,
                    fz: force * Math.sin(angleZ) * this.speedFactor
                };
            }

            // 3D弹性碰撞处理，碰撞时星体会互相弹开，还会触发绚丽的特效！
            // 替换原 handleElasticCollision，升级为三维宇宙碰撞
            handleElasticCollision(p1, p2, effectX, effectY) {
                // 1. 计算两星连线的单位法向量，决定弹开的方向
                const dx = p2.x - p1.x, dy = p2.y - p1.y, dz = p2.z - p1.z;
                let dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1; // 防止除零
                const nx = dx / dist, ny = dy / dist, nz = dz / dist;

                // 2. 获取两星的质量
                const m1 = p1.mass, m2 = p2.mass, totalMass = m1 + m2;

                // 3. 获取两星的速度向量
                const v1 = [p1.vx, p1.vy, p1.vz];
                const v2 = [p2.vx, p2.vy, p2.vz];

                // 4. 计算质量加权的平均速度，碰撞后速度以此为基准
                const avgVx = (p1.vx * m1 + p2.vx * m2) / totalMass;
                const avgVy = (p1.vy * m1 + p2.vy * m2) / totalMass;
                const avgVz = (p1.vz * m1 + p2.vz * m2) / totalMass;

                // 5. 法向分量，保证碰撞后星体分离，避免粘连
                const minSep = 11; // 最小分离速度，防止星体像磁铁一样吸在一起
                p1.vx = avgVx - nx * minSep + (Math.random() - 0.5) * 2; // 加点随机，宇宙本就充满不确定性
                p1.vy = avgVy - ny * minSep + (Math.random() - 0.5) * 2;
                p1.vz = avgVz - nz * minSep + (Math.random() - 0.5) * 2;
                p2.vx = avgVx + nx * minSep + (Math.random() - 0.5) * 2;
                p2.vy = avgVy + ny * minSep + (Math.random() - 0.5) * 2;
                p2.vz = avgVz + nz * minSep + (Math.random() - 0.5) * 2;
                // 限制速度，防止碰撞后飞出银河系
                this.limitPlanetSpeed(p1);
                this.limitPlanetSpeed(p2);

                // 6. 位置微调，防止星体重叠穿模
                const overlap = p1.radius + p2.radius - dist;
                if (overlap > 0) {
                    const adjust = overlap / 2 + 0.1;
                    p1.x -= nx * adjust;
                    p1.y -= ny * adjust;
                    p1.z -= nz * adjust;
                    p2.x += nx * adjust;
                    p2.y += ny * adjust;
                    p2.z += nz * adjust;
                }
                // 7. 冷却计时，避免同一对星体连续多次碰撞
                p1.collisionCooldown = 10;
                p2.collisionCooldown = 10;
                // 8. 触发碰撞特效，视觉盛宴！
                this.createCollisionEffect(effectX, effectY);
                // 9. 伴星锁定机制，碰撞后短暂绑定，模拟引力捕获
                p1.boundTo = p2;
                p2.boundTo = p1;
                p1.boundTime = p2.boundTime = 180; // 绑定帧数
            }
            // 绚丽的碰撞特效，冲击波+粒子爆发，像超新星爆发一样震撼
            createCollisionEffect(x, y) {
                // 冲击波圆环
                const shockwave = document.createElement('div');
                shockwave.className = 'shockwave-effect';
                shockwave.style.left = `${x}px`;
                shockwave.style.top = `${y}px`;
                shockwave.style.width = '30px';
                shockwave.style.height = '30px';
                shockwave.style.borderRadius = '50%';
                shockwave.style.background = 'radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(0,247,255,0.8) 50%, transparent 80%)';
                shockwave.style.boxShadow = '0 0 40px 20px rgba(0,247,255,0.7)';
                shockwave.style.pointerEvents = 'none';
                shockwave.style.zIndex = '10001';
                document.body.appendChild(shockwave);
                setTimeout(() => { shockwave.remove(); }, 500); // 0.5秒后消失

                // 粒子爆发，16个小粒子向四周飞散，像宇宙尘埃
                for (let i = 0; i < 16; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'collision-particle';
                    particle.style.left = `${x}px`;
                    particle.style.top = `${y}px`;
                    particle.style.width = `${3 + Math.random() * 5}px`;
                    particle.style.height = particle.style.width;
                    particle.style.background = `hsl(${180 + Math.random() * 60}, 100%, 70%)`;
                    particle.style.boxShadow = `0 0 10px 2px hsl(${180 + Math.random() * 60}, 100%, 80%)`;
                    particle.style.zIndex = '10002';
                    document.body.appendChild(particle);

                    const angle = Math.random() * Math.PI * 2; // 随机方向
                    const distance = 30 + Math.random() * 60; // 随机距离
                    const duration = 300 + Math.random() * 300; // 随机消失时间

                    setTimeout(() => {
                        particle.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
                        particle.style.opacity = '0';
                        setTimeout(() => particle.remove(), duration);
                    }, 10);
                }

            }
            // 星体速度上限，防止宇宙大爆炸后星体飞出屏幕
            MAX_PLANET_SPEED = 1500;
            limitPlanetSpeed(p) {
                const v = Math.sqrt(p.vx * p.vx + p.vy * p.vy + p.vz * p.vz);
                if (v > this.MAX_PLANET_SPEED) {
                    const scale = this.MAX_PLANET_SPEED / v;
                    p.vx *= scale;
                    p.vy *= scale;
                    p.vz *= scale;
                }
            }

            // 宇宙主循环，每一帧都在演绎混沌的三体舞蹈
            simulate(timestamp) {
                // 计算本帧与上一帧的时间间隔，单位秒
                const dt = timestamp ? (timestamp - this.lastTime) / 1000 : 0.016;
                this.lastTime = timestamp || 0;
                // === 物理模拟部分 ===
                for (let i = 0; i < this.planets.length; i++) {
                    const p1 = this.planets[i];
                    // 碰撞冷却倒计时，避免频繁碰撞
                    if (p1.collisionCooldown > 0) p1.collisionCooldown--;
                    let fx = 0, fy = 0, fz = 0; // 本帧合力
                    for (let j = 0; j < this.planets.length; j++) {
                        if (i === j) continue; // 不和自己算引力
                        const p2 = this.planets[j];
                        const force = this.calculateGravity(p1, p2); // 计算引力
                        fx += force.fx;
                        fy += force.fy;
                        fz += force.fz;
                    }
                    // 鼠标引力，鼠标按下时才有，像是用手指点星辰
                    if (this.mousePlanet.active) {
                        const dx = this.mousePlanet.x - p1.x;
                        const dy = this.mousePlanet.y - p1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 300) { // 只有靠近才有影响
                            const angle = Math.atan2(dy, dx);
                            const force = 200000 / (dist * dist + 100); // 距离越近引力越大
                            fx += Math.cos(angle) * force;
                            fy += Math.sin(angle) * force;
                        }
                    }
                    // 更新速度，F=ma，a=F/m，dt为时间步长
                    p1.vx += fx / p1.mass * dt;
                    p1.vy += fy / p1.mass * dt;
                    p1.vz += fz / p1.mass * dt;

                    this.limitPlanetSpeed(p1); // 限速

                    // 伴星吸附机制，碰撞后短暂绑定，模拟引力捕获
                    for (const p of this.planets) {
                        if (p.boundTo && p.boundTime > 0) {
                            // 强化引力，模拟伴星吸附
                            const dx = p.boundTo.x - p.x;
                            const dy = p.boundTo.y - p.y;
                            const dz = p.boundTo.z - p.z;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            if (dist > 1) {
                                // 速度吸附，让速度方向更接近切线，模拟轨道捕获
                                const vxRel = p.vx - p.boundTo.vx;
                                const vyRel = p.vy - p.boundTo.vy;
                                const vzRel = p.vz - p.boundTo.vz;
                                // 计算径向分量
                                const vRadial = (vxRel * dx + vyRel * dy + vzRel * dz) / dist;
                                // 削弱径向速度，保留切向速度
                                p.vx -= (vRadial * dx / dist) * 0.1;
                                p.vy -= (vRadial * dy / dist) * 0.1;
                                p.vz -= (vRadial * dz / dist) * 0.1;
                                // 增强引力，模拟伴星吸附
                                const attract = 0.2;
                                p.vx += dx / dist * attract;
                                p.vy += dy / dist * attract;
                                p.vz += dz / dist * attract;
                            }
                            p.boundTime--;
                            if (p.boundTime <= 0) {
                                p.boundTo = null; // 解绑
                            }
                        }
                    }
                }
                // === 本帧已触发的碰撞对集合，避免同一对多次特效 ===
                const triggeredPairs = new Set();
                // 处理星星之间弹性碰撞+特效
                for (let i = 0; i < this.planets.length; i++) {
                    for (let j = i + 1; j < this.planets.length; j++) {
                        const p1 = this.planets[i], p2 = this.planets[j];
                        const dx = p2.x - p1.x, dy = p2.y - p1.y, dz = p2.z - p1.z;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        if (dist < p1.radius + p2.radius + 2) { // 判定是否碰撞
                            // 只要发生碰撞就一定触发特效，但同一对只触发一次
                            const pairKey = `${i}_${j}`;
                            if (!triggeredPairs.has(pairKey)) {
                                triggeredPairs.add(pairKey);
                                const effectX = (p1.x + p2.x) / 2;
                                const effectY = (p1.y + p2.y) / 2;
                                this.createCollisionEffect(effectX, effectY);
                            }
                            // 只有冷却结束才处理速度和位置
                            if (p1.collisionCooldown <= 0 && p2.collisionCooldown <= 0) {
                                this.handleElasticCollision(p1, p2, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
                            }
                        }
                    }
                }
                // 鼠标与星球弹性碰撞+特效（无需按键，只要靠近就触发）
                for (const p of this.planets) {
                    const dx = this.mousePlanet.x - p.x;
                    const dy = this.mousePlanet.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const mouseRadius = this.mousePlanet.radius + 20; // 鼠标判定半径
                    if (dist < p.radius + mouseRadius) {
                        // 一定触发特效
                        this.createCollisionEffect((p.x + this.mousePlanet.x) / 2, (p.y + this.mousePlanet.y) / 2);
                        if (p.collisionCooldown <= 0) {
                            // 构造一个假的鼠标星体，参与碰撞
                            const fakeMouse = {
                                x: this.mousePlanet.x,
                                y: this.mousePlanet.y,
                                z: 0,
                                vx: 0,
                                vy: 0,
                                vz: 0,
                                mass: this.mousePlanet.mass,
                                radius: mouseRadius,
                                collisionCooldown: 0,
                                isMouse: true
                            };
                            this.handleElasticCollision(p, fakeMouse, (p.x + this.mousePlanet.x) / 2, (p.y + this.mousePlanet.y) / 2);
                            // 鼠标特效反馈，光标闪烁
                            const cursor = document.getElementById('custom-cursor');
                            if (cursor) {
                                cursor.classList.add('cursor-collision-feedback');
                                setTimeout(() => {
                                    cursor.classList.remove('cursor-collision-feedback');
                                }, 300);
                            }
                            // 鼠标推力，将鼠标的速度分量传递给星体，像用手推了一把
                            const pushStrength = 100; // 推力强度
                            p.vx += this.mouseVX * pushStrength;
                            p.vy += this.mouseVY * pushStrength;
                        }
                    }
                }
                // === 更新星体位置和渲染 ===
                for (const p of this.planets) {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.z += p.vz * dt;
                    // 边界反弹，防止星体飞出宇宙边界
                    if (p.x - p.radius < 0) { p.x = p.radius; p.vx = -p.vx * 0.9; }
                    if (p.x + p.radius > window.innerWidth) { p.x = window.innerWidth - p.radius; p.vx = -p.vx * 0.9; }
                    if (p.y - p.radius < 0) { p.y = p.radius; p.vy = -p.vy * 0.9; }
                    if (p.y + p.radius > window.innerHeight) { p.y = window.innerHeight - p.radius; p.vy = -p.vy * 0.9; }
                    // z轴边界，模拟三维空间的厚度
                    if (p.z < -200) { p.z = -200; p.vz = -p.vz * 0.9; }
                    if (p.z > 200) { p.z = 200; p.vz = -p.vz * 0.9; }
                    // 速度衰减，模拟宇宙微妙的阻力
                    p.vx *= 0.995;
                    p.vy *= 0.995;
                    p.vz *= 0.995;
                    // 轨迹记录与渲染，留下星体的历史轨迹，像宇宙的记忆
                    p.addTrailPoint();
                    p.renderTrail();
                    // 颜色和位置更新，视觉反馈
                    p.updateColor();
                    p.updatePosition();
                }
                // 下一帧，宇宙永不止步
                requestAnimationFrame((ts) => this.simulate(ts));
            }
        }


        const specialPlanetStyle = document.createElement('style');
        specialPlanetStyle.textContent = `
        @keyframes releaseFade {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }
        
        .release-effect {
            position: fixed;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9996;
            animation: releaseFade 0.8s ease-out forwards;
        }
        
        @keyframes capturePulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; }
            50% { opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        .capture-effect {
            position: fixed;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9996;
            animation: capturePulse 1s ease-out forwards;
        }
        
        @keyframes capturePulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; }
            50% { opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        .capture-effect {
            position: fixed;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9996;
            animation: capturePulse 1s ease-out forwards;
        }
        
        @keyframes collisionFade {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }
        
        .collision-effect {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.9) 0%, 
                rgba(255,200,100,0.7) 50%, 
                transparent 80%);
            pointer-events: none;
            z-index: 9997;
        }
        
        .special-planet {
            position: fixed;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.05s ease-out;
            will-change: transform;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
        }
        
        .planet-trail, .planet-subtrail {
            position: fixed;
            pointer-events: none;
            transform-origin: 0 50%;
            border-radius: 2px;
            mix-blend-mode: screen;
            transition: opacity 0.3s ease-out;
        }
        
        .planet-trail {
            z-index: 9995;
            filter: blur(0.5px);
        }
        
        .planet-subtrail {
            z-index: 9994;
            filter: blur(1px);
        }
    `;
        document.head.appendChild(specialPlanetStyle);




        let threeStarSystem;
        document.addEventListener('DOMContentLoaded', function () {
            threeStarSystem = new ThreeStarSystem();
        });



        // 球状闪电——仿佛宇宙深处的等离子体幽灵，带着EMP脉冲和混沌能量在屏幕上游走
        function createBallLightning() {
            // 设备性能检测，像宇宙飞船起航前的自检，确保不会烧毁引擎
            const isLowPerfDevice = (() => {
                // 检查内存，低于1GB就算低配，谨慎点别炸机
                const memory = performance.memory ? performance.memory.jsHeapSizeLimit : 0;
                // 检查GPU能力，Intel集显就当低配，毕竟不是银河级显卡
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                const gpuInfo = gl ? gl.getExtension('WEBGL_debug_renderer_info') : null;
                const isLowEnd = memory < 1073741824 || // <1GB
                    (gpuInfo && gl.getParameter(gpuInfo.UNMASKED_RENDERER_WEBGL).includes('Intel'));
                // CPU核心数也要看，少于4核就算低配
                return isLowEnd || navigator.hardwareConcurrency < 4;
            })();

            // 创建球状闪电的主容器，像在宇宙中生成一个能量球
            const ballLightning = document.createElement('div');
            ballLightning.className = 'ball-lightning';

            // 根据设备性能调整参数，低配设备就少点特效，保护地球资源
            const settings = {
                layerCount: isLowPerfDevice ? 5 : 7, // 等离子层数
                arcCount: isLowPerfDevice ? 18 : 36, // 闪电弧数量
                duration: isLowPerfDevice ? 2000 + Math.random() * 2000 : 3000 + Math.random() * 3000, // 持续时间
                quality: isLowPerfDevice ? 0.7 : 1.0 // 画质
            };

            // 创建球状闪电的核心，像恒星的等离子体内核
            const innerCore = document.createElement('div');
            innerCore.className = 'ball-lightning-core';

            // 多层等离子体，层层叠加，制造出深邃的能量感
            const plasmaLayers = [];
            // 5层不同色调的等离子体，蓝绿为主，像外星能量场
            for (let i = 1; i <= 5; i++) {
                const layer = document.createElement('div');
                layer.className = `plasma-layer layer${i}`;
                // 每层不同的渐变色，营造出神秘的能量晕圈
                switch (i) {
                    case 1: // 核心层 - 柔和的蓝绿色
                        layer.style.background = `radial-gradient(circle at 40% 40%, 
                                    rgba(100, 220, 220, 0.7) 0%,  
                                    rgba(70, 200, 200, 0.5) 50%,  
                                    transparent 90%)`;
                        break;
                    case 2: // 中间层 - 淡蓝色
                        layer.style.background = `radial-gradient(circle at 60% 60%, 
                                    rgba(120, 230, 240, 0.5) 0%, 
                                    rgba(90, 210, 230, 0.4) 50%, 
                                    transparent 85%)`;
                        break;
                    case 3: // 外层 - 深蓝绿色
                        layer.style.background = `radial-gradient(circle at 50% 50%, 
                                    rgba(60, 180, 190, 0.4) 0%, 
                                    rgba(40, 160, 170, 0.3) 60%, 
                                    transparent 90%)`;
                        break;
                    case 4: // 最外层 - 微弱的蓝光
                        layer.style.background = `radial-gradient(circle at 30% 30%, 
                                    rgba(30, 120, 150, 0.3) 0%, 
                                    rgba(20, 100, 130, 0.2) 40%, 
                                    transparent 80%)`;
                        break;
                    case 5: // 边缘光晕
                        layer.style.background = `radial-gradient(circle at 50% 50%, 
                                    rgba(100, 200, 220, 0.3) 0%, 
                                    rgba(80, 180, 200, 0.2) 50%, 
                                    transparent 80%)`;
                        break;
                }
                plasmaLayers.push(layer);
                ballLightning.appendChild(layer);
            }

            // 闪电弧的容器，像磁场线一样环绕核心
            const lightningArcs = document.createElement('div');
            lightningArcs.className = 'lightning-arcs';

            // EMP脉冲特效，模拟电磁爆发
            const empPulse = document.createElement('div');
            empPulse.className = 'emp-pulse';

            // 随机起始位置，宇宙中的能量球总是神出鬼没
            const startX = Math.random() * window.innerWidth;
            const startY = Math.random() * window.innerHeight;
            ballLightning.style.left = `${startX}px`;
            ballLightning.style.top = `${startY}px`;

            // 随机大小，60-150像素，大小不一的能量球
            const size = 60 + Math.random() * 90;
            ballLightning.style.width = `${size}px`;
            ballLightning.style.height = `${size}px`;

            // 组装闪电结构，把核心和弧线都塞进主容器
            ballLightning.appendChild(innerCore);
            ballLightning.appendChild(lightningArcs);

            // 生成24条闪电弧，每条都像是能量场的触须
            for (let i = 0; i < 24; i++) {
                const arc = document.createElement('div');
                arc.className = 'lightning-arc';
                arc.style.transform = `rotate(${i * 15}deg)`; // 每15度一条，均匀分布

                // 主闪电和分支闪电，主闪电更粗更亮，分支更细更虚幻
                if (Math.random() > 0.3) {
                    // 主闪电 - 柔和的蓝绿色
                    arc.style.width = '2px';
                    arc.style.background = `linear-gradient(to top, 
                        rgba(100, 220, 220, 0.7) 0%,    
                        rgba(70, 200, 200, 0.5) 50%, 
                        rgba(40, 180, 190, 0.3) 80%, 
                        transparent 100%)`;
                    arc.style.boxShadow = '0 0 10px 2px rgba(70, 200, 200, 0.4)';
                } else {
                    // 分支闪电 - 更细更柔和
                    arc.style.width = '0.8px';
                    arc.style.background = `linear-gradient(to top, 
                        rgba(120, 230, 240, 0.5) 0%, 
                        rgba(90, 210, 230, 0.3) 50%, 
                        transparent 100%)`;
                    arc.style.boxShadow = '0 0 8px 1px rgba(90, 210, 230, 0.2)';
                }

                // 随机长度，制造不规则的能量感
                const arcLength = size * (0.3 + Math.random() * 0.4);
                arc.style.height = `${arcLength}px`;

                // 随机生成分支闪电，像等离子体的分叉
                if (Math.random() > 0.5) {
                    const branchCount = Math.floor(Math.random() * 3) + 1;
                    for (let j = 0; j < branchCount; j++) {
                        const branch = document.createElement('div');
                        branch.className = 'lightning-branch';
                        branch.style.transform = `rotate(${Math.random() * 60 - 30}deg)`;
                        branch.style.width = `${Math.random() * 0.5 + 0.5}px`;
                        branch.style.height = `${arcLength * (0.3 + Math.random() * 0.3)}px`;
                        branch.style.background = `linear-gradient(to top, 
                    rgba(255, 255, 255, 0.7) 0%, 
                    rgba(180, 240, 255, 0.5) 30%, 
                    rgba(100, 200, 255, 0.3) 60%, 
                    transparent 100%)`;
                        arc.appendChild(branch);
                    }
                }

                lightningArcs.appendChild(arc);
            }

            // 把球状闪电和EMP脉冲加到页面上，正式登场！
            document.body.appendChild(ballLightning);
            document.body.appendChild(empPulse);

            // EMP脉冲初始位置和样式
            empPulse.style.left = `${startX}px`;
            empPulse.style.top = `${startY}px`;

            // EMP脉冲动画，像超新星爆发的冲击波
            setTimeout(() => {
                empPulse.style.opacity = '0.8';
                empPulse.style.transform = 'translate(-50%, -50%) scale(1)';
                empPulse.style.background = 'radial-gradient(circle, rgba(192, 255, 255, 0.8) 0%, rgba(64, 224, 208, 0.6) 50%, transparent 80%)';

                // 第二层脉冲，叠加更强的爆发感
                const empPulse2 = document.createElement('div');
                empPulse2.className = 'emp-pulse';
                empPulse2.style.left = `${startX}px`;
                empPulse2.style.top = `${startY}px`;
                document.body.appendChild(empPulse2);

                setTimeout(() => {
                    empPulse.style.transform = 'translate(-50%, -50%) scale(50)';
                    empPulse.style.opacity = '0';

                    setTimeout(() => {
                        empPulse2.style.transform = 'translate(-50%, -50%) scale(30)';
                        empPulse2.style.opacity = '0';

                        setTimeout(() => {
                            empPulse2.remove();
                        }, 1000);
                    }, 50);

                    // EMP脉冲后的电磁干扰效果，像宇宙风暴余波
                    createEMPAftermath(startX, startY);
                }, 100);
            }, 10);

            // 球状闪电的运动轨迹参数，像宇宙中漂流的能量团
            let currentX = startX;
            let currentY = startY;
            let velocityX = (Math.random() - 0.5) * 10;
            let velocityY = (Math.random() - 0.5) * 10;
            const moveDuration = 3000 + Math.random() * 3000; // 3-6秒持续时间
            const startTime = Date.now();

            // 初始化电弧为收缩状态，开场时全部集中在核心，等待爆发
            const arcs = lightningArcs.querySelectorAll('.lightning-arc');
            arcs.forEach(arc => {
                arc.style.height = '0';
                arc.style.opacity = '0';
                arc.style.transformOrigin = 'bottom center';
                arc.style.transform = 'rotate(var(--rotation)) translateY(-50%)';
            });

            // 闪电内部动画，负责等离子体和电弧的动态变化
            const animatePlasma = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / moveDuration;
                const pulseFactor = 0.8 + Math.sin(elapsed * 0.003) * 0.2;

                // 开场电弧爆炸式扩散动画，像能量球刚刚形成时的爆发
                if (elapsed < 800) { // 前0.8秒进行爆炸式扩散
                    const expansionProgress = Math.min(elapsed / 800, 1);
                    const easeProgress = 1 - Math.pow(1 - expansionProgress, 4); // 四次缓动，爆发更自然

                    arcs.forEach((arc, index) => {
                        const delay = index * 5; // 每条弧线有微小延迟，像烟花一样依次绽放
                        if (elapsed > delay) {
                            const arcProgress = Math.min((elapsed - delay) / 300, 1);
                            // 随机长度增加一些变化
                            const baseLength = size * (0.5 + Math.random() * 0.2);
                            const arcLength = baseLength * easeProgress;

                            // 添加一些随机摆动效果，像能量在跳动
                            const wobble = Math.sin(elapsed * 0.01 + index) * 5;

                            arc.style.height = `${arcLength}px`;
                            arc.style.opacity = arcProgress;
                            arc.style.transform = `
                                rotate(var(--rotation)) 
                                translateY(${-50 + wobble}%)
                                scaleY(${1 + Math.sin(elapsed * 0.02 + index) * 0.2})
                            `;

                            // 随机闪电增强效果，偶尔亮一下
                            if (Math.random() > 0.9) {
                                arc.style.filter = 'brightness(3)';
                                setTimeout(() => {
                                    arc.style.filter = 'brightness(1)';
                                }, 50);
                            }
                        }
                    });

                    // 核心爆发效果，像恒星核心膨胀
                    if (elapsed < 400) {
                        const coreScale = 0.5 + expansionProgress * 1.5;
                        innerCore.style.transform = `translate(-50%, -50%) scale(${coreScale})`;
                        innerCore.style.opacity = `${expansionProgress * 2}`;
                    }
                }

                // 核心脉动动画，开场爆发后进入常规脉动
                if (elapsed < 1000) {
                    const expansionProgress = Math.min(elapsed / 1000, 1);
                    const pulseScale = 0.5 + expansionProgress * 0.5 + Math.sin(elapsed * 0.02) * 0.3;
                    const pulseOpacity = Math.min(1, 2 - expansionProgress);

                    innerCore.style.transform = `translate(-50%, -50%) scale(${pulseScale})`;
                    innerCore.style.opacity = `${pulseOpacity}`;
                    innerCore.style.boxShadow = `0 0 ${50 * expansionProgress}px ${20 * expansionProgress}px rgba(100, 200, 255, ${0.8 - expansionProgress * 0.3})`;
                } else {
                    // 常规脉动，像恒星的能量波动
                    innerCore.style.transform = `translate(-50%, -50%) scale(${0.8 + Math.sin(elapsed * 0.007) * 0.2})`;
                    innerCore.style.opacity = `${0.7 + Math.sin(elapsed * 0.005) * 0.3}`;
                }

                // 等离子层动画，每层不同的旋转速度和脉动，制造出深邃的能量感
                plasmaLayers.forEach((layer, index) => {
                    const layerPulse = pulseFactor * (0.9 + index * 0.05);
                    const rotationSpeed = 0.0005 + index * 0.0003;
                    const rotationDirection = index % 2 === 0 ? 1 : -1;

                    layer.style.transform = `
                        translate(-50%, -50%) 
                        rotate(${rotationDirection * elapsed * rotationSpeed}rad) 
                        scale(${layerPulse})
                    `;
                    layer.style.opacity = `${0.6 - index * 0.1 + Math.sin(elapsed * 0.004 + index) * 0.2}`;
                });

                // 闪电弧动画，动态长度和亮度，像能量在流动
                const arcs = lightningArcs.querySelectorAll('.lightning-arc, .lightning-branch');
                arcs.forEach((arc, index) => {
                    const arcPulse = 0.7 + Math.sin(elapsed * 0.003 + index * 0.2) * 0.3;
                    const arcLength = size * (0.4 + Math.sin(elapsed * 0.002 + index) * 0.1);

                    if (arc.className === 'lightning-arc') {
                        arc.style.height = `${arcLength}px`;
                    } else {
                        arc.style.height = `${arcLength * 0.6}px`;
                    }

                    arc.style.opacity = `${0.5 + Math.sin(elapsed * 0.005 + index * 0.1) * 0.4}`;

                    // 随机闪电闪烁效果，偶尔亮一下
                    if (Math.random() > 0.95) {
                        arc.style.filter = 'brightness(3)';
                        setTimeout(() => {
                            arc.style.filter = 'brightness(1)';
                        }, 50);
                    }
                });

                if (elapsed < moveDuration) {
                    requestAnimationFrame(animatePlasma);
                }
            };

            // 球状闪电的运动轨迹，带有弹性碰撞和不确定性加速，像宇宙中漂流的能量团
            function moveBallLightning() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / moveDuration;

                if (progress >= 1) {
                    // 消失动画，像能量球耗尽后渐渐消散
                    const fadeProgress = (elapsed - moveDuration) / 1000;
                    if (fadeProgress < 1) {
                        ballLightning.style.opacity = `${1 - fadeProgress}`;
                        ballLightning.style.transform = `translate(-50%, -50%) scale(${0.5 + fadeProgress * 0.5})`;
                        requestAnimationFrame(moveBallLightning);
                        return;
                    }

                    // 清理DOM，能量球彻底消失
                    ballLightning.remove();
                    if (empPulse) empPulse.remove();
                    return;
                }

                // 不确定性加速，偶尔突然加速，像宇宙中的量子涨落
                if (Math.random() > 0.9) {
                    const accelFactor = 2 + Math.random() * 3;
                    velocityX *= accelFactor;
                    velocityY *= accelFactor;
                }

                // 更新位置
                currentX += velocityX;
                currentY += velocityY;

                // 边界弹性碰撞，撞到边缘会反弹回来，像能量球被宇宙边界弹回
                const radius = size / 2;
                if (currentX < radius) {
                    currentX = radius;
                    velocityX = -velocityX * 0.9; // 弹性系数
                } else if (currentX > window.innerWidth - radius) {
                    currentX = window.innerWidth - radius;
                    velocityX = -velocityX * 0.9;
                }

                if (currentY < radius) {
                    currentY = radius;
                    velocityY = -velocityY * 0.9;
                } else if (currentY > window.innerHeight - radius) {
                    currentY = window.innerHeight - radius;
                    velocityY = -velocityY * 0.9;
                }

                // 随机速度扰动，制造出混沌的运动轨迹
                velocityX += (Math.random() - 0.5) * 0.5;
                velocityY += (Math.random() - 0.5) * 0.5;

                // 限制最大速度，防止能量球飞出银河系
                const maxSpeed = 20;
                const speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                if (speed > maxSpeed) {
                    velocityX = (velocityX / speed) * maxSpeed;
                    velocityY = (velocityY / speed) * maxSpeed;
                }

                // 更新DOM位置
                ballLightning.style.left = `${currentX}px`;
                ballLightning.style.top = `${currentY}px`;
                if (empPulse) {
                    empPulse.style.left = `${currentX}px`;
                    empPulse.style.top = `${currentY}px`;
                }

                // 脉动效果，能量球随速度变化而明暗起伏
                const pulseIntensity = 0.7 + Math.sin(elapsed * 0.004) * 0.3;
                const pulseSize = 0.7 + pulseIntensity * 0.3;
                ballLightning.style.transform = `translate(-50%, -50%) scale(${pulseSize})`;

                // 速度相关亮度变化，越快越亮
                ballLightning.style.filter = `brightness(${0.01 + speed * 0.05})`;

                requestAnimationFrame(moveBallLightning);
            }

            // EMP后续效果，模拟电磁干扰波纹和粒子，像宇宙风暴的余波
            function createEMPAftermath(x, y) {
                // 主干扰波纹
                const empAftermath = document.createElement('div');
                empAftermath.className = 'emp-aftermath';
                empAftermath.style.left = `${x}px`;
                empAftermath.style.top = `${y}px`;
                empAftermath.style.background = 'radial-gradient(circle, rgba(64, 224, 208, 0.4) 0%, transparent 70%)';
                document.body.appendChild(empAftermath);

                // 次级干扰波纹
                const empAftermath2 = document.createElement('div');
                empAftermath2.className = 'emp-aftermath';
                empAftermath2.style.left = `${x}px`;
                empAftermath2.style.top = `${y}px`;
                empAftermath2.style.background = 'radial-gradient(circle, rgba(192, 255, 255, 0.3) 0%, transparent 60%)';
                document.body.appendChild(empAftermath2);

                // 随机粒子，像等离子体碎片四散飞舞
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'emp-particle';
                        particle.style.left = `${x + (Math.random() - 0.5) * 100}px`;
                        particle.style.top = `${y + (Math.random() - 0.5) * 100}px`;
                        particle.style.width = `${Math.random() * 3 + 1}px`;
                        particle.style.height = particle.style.width;
                        particle.style.background = `rgba(192, 255, 255, ${Math.random() * 0.7 + 0.3})`;
                        document.body.appendChild(particle);

                        setTimeout(() => {
                            particle.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${(Math.random() - 0.5) * 200}px)`;
                            particle.style.opacity = '0';
                            setTimeout(() => particle.remove(), 1000);
                        }, 10);
                    }, Math.random() * 300);
                }

                // 波纹动画，主波纹和次波纹依次扩散消失
                setTimeout(() => {
                    empAftermath.style.transform = 'translate(-50%, -50%) scale(40)';
                    empAftermath.style.opacity = '0';

                    setTimeout(() => {
                        empAftermath2.style.transform = 'translate(-50%, -50%) scale(60)';
                        empAftermath2.style.opacity = '0';

                        setTimeout(() => {
                            empAftermath.remove();
                            empAftermath2.remove();
                        }, 1000);
                    }, 200);
                }, 10);
            }

            // 启动动画并优化性能，像宇宙飞船起航前的最后准备
            function startAnimations() {
                // will-change提示浏览器优化动画
                ballLightning.style.willChange = 'transform, opacity';
                if (empPulse) empPulse.style.willChange = 'transform, opacity';

                // 分离动画循环，减少主线程压力
                const plasmaAnimationId = requestAnimationFrame(animatePlasma);
                const moveAnimationId = requestAnimationFrame(moveBallLightning);

                // 清理函数，动画结束后释放资源
                ballLightning.cleanup = function () {
                    cancelAnimationFrame(plasmaAnimationId);
                    cancelAnimationFrame(moveAnimationId);
                    if (this.parentNode) {
                        this.parentNode.removeChild(this);
                    }
                    if (empPulse && empPulse.parentNode) {
                        empPulse.parentNode.removeChild(empPulse);
                    }
                };
            }

            // 响应式处理，适配不同设备，像宇宙飞船自动调整姿态
            function handleResponsiveChanges() {
                const isMobile = window.innerWidth < 768;
                const ballLightning = document.querySelector('.ball-lightning');

                if (ballLightning) {
                    // 调整大小和位置，适配屏幕
                    const baseSize = Math.min(window.innerWidth, window.innerHeight) * 0.1;
                    ballLightning.style.width = `${baseSize}px`;
                    ballLightning.style.height = `${baseSize}px`;

                    // 移动端优化，增强可见性
                    if (isMobile) {
                        ballLightning.style.filter = 'brightness(1.2)';
                    }
                }
            }

            // 初始化响应式处理
            handleResponsiveChanges();

            // 监听窗口大小变化，自动适配
            const resizeObserver = new ResizeObserver(() => {
                handleResponsiveChanges();
            });
            resizeObserver.observe(document.body);

            // 启动动画，能量球开始在宇宙中游走
            const animation = startAnimations();

            // 扩展清理函数，包含响应式处理的清理
            ballLightning.cleanup = function () {
                // 原有清理逻辑...
                resizeObserver.disconnect();
                if (typeof animation.cleanup === 'function') {
                    animation.cleanup();
                }
            };

            // 移动端触摸支持，手指一碰就能召唤球状闪电
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 0 && !document.querySelector('.ball-lightning')) {
                    createBallLightning(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: true });
        }
        // 添加球状闪电样式到head
        const style = document.createElement('style');
        style.textContent = `
/* 球状闪电核心样式 */
.ball-lightning {
    position: fixed;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 10000;
    transform: translate(-50%, -50%);
    mix-blend-mode: screen;
    filter: brightness(1.5);
}

.ball-lightning-core {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 40%;
    height: 40%;
    border-radius: 50%;
    background: radial-gradient(circle at center, 
        rgba(255, 255, 255, 0.9) 0%, 
        rgba(200, 240, 255, 0.7) 30%, 
        rgba(100, 200, 255, 0.5) 70%, 
        transparent 100%);
    transform: translate(-50%, -50%);
    box-shadow: 0 0 30px 15px rgba(100, 200, 255, 0.3);
}

.plasma-layer {
    position: absolute;
    top: 50%;
    left: 50%;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    mix-blend-mode: screen;
}

.plasma-layer.layer1 {
    width: 80%;
    height: 80%;
    background: radial-gradient(circle at 40% 40%, 
        rgba(180, 240, 255, 0.6) 0%, 
        rgba(120, 220, 255, 0.4) 50%, 
        transparent 90%);
    box-shadow: 0 0 40px 20px rgba(100, 220, 255, 0.2);
}

.plasma-layer.layer2 {
    width: 90%;
    height: 90%;
    background: radial-gradient(circle at 60% 60%, 
        rgba(200, 255, 240, 0.5) 0%, 
        rgba(150, 255, 220, 0.3) 40%, 
        transparent 80%);
    box-shadow: 0 0 50px 25px rgba(150, 255, 220, 0.15);
}

.plasma-layer.layer3 {
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, 
        rgba(255, 220, 180, 0.4) 0%, 
        rgba(255, 200, 150, 0.2) 30%, 
        transparent 70%);
    box-shadow: 0 0 60px 30px rgba(255, 200, 150, 0.1);
}

.lightning-arcs {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 100%;
    transform: translate(-50%, -50%);
}

.lightning-arc {
    position: absolute;
    bottom: 50%;
    left: 50%;
    width: 2px;
    height: 50%;
    background: linear-gradient(to top, 
        rgba(255, 255, 255, 0.9) 0%, 
        rgba(180, 240, 255, 0.7) 30%, 
        rgba(100, 200, 255, 0.5) 70%, 
        transparent 100%);
    transform-origin: bottom center;
    box-shadow: 0 0 10px 2px rgba(100, 200, 255, 0.5);
}

.emp-pulse {
    position: fixed;
    width: 100px;
    height: 100px;
    border-radius: 50%;
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
    pointer-events: none;
    z-index: 9999;
    transition: transform 0.5s ease-out, opacity 0.5s ease-out;
}

.emp-particle {
    position: fixed;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 9998;
    transition: transform 0.8s ease-out, opacity 0.8s ease-out;
    box-shadow: 0 0 5px 1px rgba(64, 224, 208, 0.5);
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: hsla(200, 100%, 80%, 0.7);
    box-shadow: 0 0 30px 15px hsla(200, 100%, 80%, 0.5);
    transform: translate(-50%, -50%) scale(0);
    transition: transform 0.5s ease-out, opacity 0.5s;
    opacity: 0;
    z-index: 9999;
    filter: brightness(1.5);
}
`;

        document.head.appendChild(style);

        // 触发机制
        document.addEventListener('DOMContentLoaded', function () {
            // 全屏右键点击触发
            document.addEventListener('contextmenu', function (e) {
                if (isFullscreen) {
                    e.preventDefault();
                    createBallLightning();
                }
            });

            // 计算按钮点击触发
            const calculateBtn = document.getElementById('calculate-btn');
            if (calculateBtn) {
                calculateBtn.addEventListener('click', function () {
                    createBallLightning();
                });
            }
        });
    </script>

    <!-- 全屏功能脚本 -->
    <script>
        // 进入全屏
        function enterFullscreen() {
            const element = document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen().catch(err => {
                    console.error(`全屏错误: ${err.message}`);
                });
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }

        // 退出全屏
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }

        // 检测全屏状态变化
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);

        function handleFullscreenChange() {
            if (!document.fullscreenElement && !document.webkitIsFullScreen && !document.msFullscreenElement) {
                // 用户退出全屏，可以在这里添加额外处理
            }
        }

        // 确保页面内容足够长以支持滚动
        document.addEventListener('DOMContentLoaded', function () {
            const container = document.querySelector('.container');
            if (container) {
                container.style.minHeight = (window.innerHeight + 500) + 'px';
            }
        });
    </script>

    <script>
        // 为水滴添加点击事件
        document.getElementById('waterdrop-container').addEventListener('click', function (e) {
            e.stopPropagation();
            window.location.href = 'transition-animation.html';
        });

        // 添加鼠标悬停效果
        document.getElementById('waterdrop-container').addEventListener('mouseover', function () {
            document.body.style.cursor = 'pointer';
            const waterdrop = document.getElementById('waterdrop');
            waterdrop.style.animation = 'float 1.2s ease-in-out infinite';
            waterdrop.style.transition = 'all 0.2s ease';
            waterdrop.style.transform = 'scale(1.08)';
            waterdrop.style.filter = 'brightness(1.3) drop-shadow(0 0 15px #00aaff) hue-rotate(10deg)';
            document.getElementById('hint-text').style.textShadow = '0 0 12px #00aaff';
            document.getElementById('hint-text').style.transition = 'all 0.2s ease';

            // 创建主激光效果
            const laser = document.createElement('div');
            laser.className = 'laser';

            // 获取水滴尖端位置（在容器顶部10%处）
            const dropRect = this.getBoundingClientRect();
            const dropCenterX = dropRect.left + dropRect.width / 2;
            const dropTipY = dropRect.top + (dropRect.height * 0.1); // 水滴尖端在容器顶部10%处

            // 设置激光从水滴尖端向上发射
            laser.style.left = `${dropCenterX - 4}px`; // 居中，减去激光宽度的一半
            laser.style.bottom = `${window.innerHeight - dropTipY}px`; // 从水滴尖端开始向上发射
            laser.style.transformOrigin = 'bottom'; // 从底部开始变换

            // 随机调整激光参数
            const randomWidth = 6 + Math.random() * 4;
            laser.style.width = `${randomWidth}px`;

            // 随机颜色变化
            const hueRotate = Math.floor(Math.random() * 30) - 15; // -15到15度的色相旋转
            const saturationBoost = 10 + Math.random() * 20; // 10-30%饱和度增强
            laser.style.filter = `
                blur(0.3px) 
                hue-rotate(${hueRotate}deg)
                saturate(${100 + saturationBoost}%)
            `;

            // 随机光束强度
            const intensity = 0.8 + Math.random() * 0.4; // 0.8-1.2
            laser.style.opacity = intensity;

            document.body.appendChild(laser);

            // 添加光束能量波动效果
            setTimeout(() => {
                const energyWave = document.createElement('div');
                energyWave.className = 'laser-energy-wave';
                energyWave.style.position = 'absolute';
                energyWave.style.left = `${dropCenterX - 4}px`;
                energyWave.style.bottom = `${window.innerHeight - dropTipY}px`;
                energyWave.style.width = `${randomWidth}px`;
                energyWave.style.height = '0';
                energyWave.style.background = 'linear-gradient(to bottom, rgba(255,255,255,0.2), transparent)';
                energyWave.style.animation = 'laser-energy-wave 1.5s ease-out forwards';
                energyWave.style.zIndex = '9999';
                document.body.appendChild(energyWave);

                setTimeout(() => energyWave.remove(), 1500);
            }, 200);

            // 创建激光发射时的闪光效果
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.width = '30px';
            flash.style.height = '30px';
            flash.style.borderRadius = '50%';
            flash.style.backgroundColor = 'rgba(0, 200, 255, 0.7)';
            flash.style.boxShadow = '0 0 20px #00ffff, 0 0 40px rgba(0, 170, 255, 0.5)';
            flash.style.left = `${dropCenterX - 15}px`;
            flash.style.top = `${dropTipY - 15}px`;
            flash.style.opacity = '1';
            flash.style.transition = 'all 0.3s ease-out';
            flash.style.zIndex = '9998';
            document.body.appendChild(flash);

            // 闪光效果消失
            setTimeout(() => {
                flash.style.transform = 'scale(2)';
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), 300);
            }, 50);

            // 生成粒子效果
            const createParticles = () => {
                const particleCount = 10 + Math.floor(Math.random() * 15); // 10-25个粒子

                for (let i = 0; i < particleCount; i++) {
                    setTimeout(() => {
                        if (!document.body.contains(laser)) return; // 如果激光已被移除，不创建粒子

                        const particle = document.createElement('div');
                        particle.className = 'laser-particle';

                        // 粒子从激光随机位置发出
                        const laserHeight = parseInt(getComputedStyle(laser).height);
                        const randomHeight = Math.random() * Math.min(laserHeight, window.innerHeight * 0.7);
                        const randomSide = Math.random() > 0.5 ? 1 : -1;
                        const randomDistance = (5 + Math.random() * 15) * randomSide;

                        particle.style.left = `${dropCenterX + randomDistance}px`;
                        particle.style.bottom = `${window.innerHeight - dropTipY - randomHeight}px`;

                        // 随机大小和颜色
                        const size = 2 + Math.random() * 4;
                        particle.style.width = `${size}px`;
                        particle.style.height = `${size}px`;

                        // 随机颜色
                        const hue = 180 + Math.floor(Math.random() * 40) - 20; // 160-200的色相
                        particle.style.backgroundColor = `hsla(${hue}, 100%, 70%, 0.8)`;

                        // 随机动画持续时间
                        const duration = 0.5 + Math.random() * 0.8;
                        particle.style.animation = `particle-fade ${duration}s ease-out forwards`;

                        document.body.appendChild(particle);

                        // 动画结束后移除粒子
                        particle.addEventListener('animationend', function () {
                            this.remove();
                        });
                    }, i * 30 + Math.random() * 100); // 随机延迟创建粒子
                }
            };

            // 开始创建粒子
            createParticles();

            // 动画结束后移除激光元素
            laser.addEventListener('animationend', function () {
                this.remove();
            });

            // 添加轻微随机偏移使激光更自然
            const randomOffset = (Math.random() - 0.5) * 10;
            laser.style.transform = `translateX(${randomOffset}px)`;
        });

        document.getElementById('waterdrop-container').addEventListener('mouseout', function () {
            document.body.style.cursor = 'default';
            const waterdrop = document.getElementById('waterdrop');
            waterdrop.style.animation = 'float 3s ease-in-out infinite';
            waterdrop.style.transform = 'scale(1)';
            waterdrop.style.filter = 'brightness(1)';
            document.getElementById('hint-text').style.textShadow = 'none';
        });
    </script>


</body>


<script>
    // 中键长按跳转
    let middleMouseDownTimer = null;
    window.addEventListener('mousedown', function (event) {
        if (event.button === 1) { // 1 表示鼠标中键
            middleMouseDownTimer = setTimeout(function () {
                window.location.href = './wandering-earth.html';
            }, 1000); // 1秒
        }
    });

    window.addEventListener('mouseup', function (event) {
        if (event.button === 1) { // 1 表示鼠标中键
            if (middleMouseDownTimer) {
                clearTimeout(middleMouseDownTimer);
                middleMouseDownTimer = null;
            }
        }
    });

    // 防止中键点击时出现上下文菜单
    window.addEventListener('contextmenu', function (event) {
        if (event.button === 1) {
            event.preventDefault();
        }
    });

</script>

</html>