<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>star-dream</title>
    <style>
        html,
        body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            background: black;
            overflow: hidden;
        }

        video {
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            object-position: center;
            aspect-ratio: 16/9;
            min-width: 100vw;
            min-height: 100vh;
            max-width: none;
            max-height: none;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 9999;
            display: block;
            background: black;
            outline: none;
            /* 彻底隐藏控件 */
            -webkit-appearance: none;
            appearance: none;
        }

        /* 彻底隐藏所有原生控件（多重保险） */
        video::-webkit-media-controls,
        video::-webkit-media-controls-enclosure,
        video::-webkit-media-controls-panel,
        video::-webkit-media-controls-play-button,
        video::-webkit-media-controls-start-playback-button,
        video::-webkit-media-controls-timeline,
        video::-webkit-media-controls-current-time-display,
        video::-webkit-media-controls-time-remaining-display,
        video::-webkit-media-controls-volume-slider,
        video::-webkit-media-controls-mute-button,
        video::-webkit-media-controls-fullscreen-button,
        video::-webkit-media-controls-toggle-closed-captions-button,
        video::-webkit-media-controls-overlay-play-button,
        video::-webkit-media-controls-playback-rate-button,
        video::-webkit-media-controls-rewind-button,
        video::-webkit-media-controls-forward-button,
        video::-webkit-media-controls-pip-button,
        video::-webkit-media-controls-cast-button,
        video::-webkit-media-controls-download-button,
        video::-webkit-media-controls-settings-button,
        video::-webkit-media-controls-seek-back-button,
        video::-webkit-media-controls-seek-forward-button,
        video::-webkit-media-controls-picture-in-picture-button,
        video::-webkit-media-controls-airplay-button,
        video::-webkit-media-controls-panel,
        video::-webkit-media-controls,
        video::-ms-media-controls,
        video::-moz-media-controls,
        video::-o-media-controls,
        video::-khtml-media-controls,
        video::-media-controls {
            display: none !important;
            opacity: 0 !important;
            pointer-events: none !important;
            height: 0 !important;
            width: 0 !important;
            visibility: hidden !important;
        }
    </style>
</head>

<body>
    <video id="mainVideo" autoplay loop muted playsinline tabindex="-1"></video>
    <!-- 流星雨特效画布 -->
    <canvas id="meteorCanvas"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:10000;"></canvas>
    <script>
        // 七个视频路径
        const videoList = [
            'sunset-warm-sea-1.mp4',
            'star-warm-light-2.mp4',
            'star-bule-light-3.mp4',
            'meteor-sky-line-4.mp4',
            'flowing-light-deer-5.mp4',
            'meteor-comet-deer-6.mp4',
            'galaxy-star-sea-7.mp4',
        ];
        let currentIndex = 0;
        const video = document.getElementById('mainVideo');
        // 彻底移除控件属性
        video.removeAttribute('controls');
        video.setAttribute('controls', false);
        video.controls = false;
        // 禁止右键菜单、拖动、选中、双击、键盘
        video.addEventListener('contextmenu', e => e.preventDefault());
        video.addEventListener('dragstart', e => e.preventDefault());
        video.addEventListener('selectstart', e => e.preventDefault());
        video.addEventListener('dblclick', e => e.preventDefault());
        window.addEventListener('keydown', e => e.preventDefault());
        // ====== 超级无敌强力火狐file协议下强制循环播放措施 ======
        function superForceVideoLoop(video) {
            if (!video) return;
            // 彻底移除loop属性后再加上
            video.removeAttribute('loop');
            video.setAttribute('loop', 'loop');
            // 多重保险：事件+定时器+属性
            function realLoop() {
                if (video.ended || video.paused || (video.duration - video.currentTime < 0.2)) {
                    video.currentTime = 0.01;
                    let p = video.play();
                    if (p && p.catch) p.catch(() => { setTimeout(() => { video.play(); }, 100); });
                }
            }
            video.addEventListener('ended', realLoop);
            video.addEventListener('timeupdate', function () {
                if (video.duration - video.currentTime < 0.05) {
                    video.currentTime = 0.01;
                    video.play();
                }
            });
            // 火狐file协议下再加一层保险
            var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            var isFileProtocol = window.location.protocol === 'file:';
            if (isFirefox && isFileProtocol) {
                if (!window._ffLoopInterval) {
                    window._ffLoopInterval = setInterval(realLoop, 200);
                }
            }
            // 其他浏览器也加保险
            if (!window._videoLoopInterval) {
                window._videoLoopInterval = setInterval(realLoop, 500);
            }
            // 属性保险
            video.setAttribute('autoplay', 'autoplay');
            video.autoplay = true;
            video.setAttribute('muted', 'muted');
            video.muted = true;
            video.setAttribute('playsinline', '');
            video.playsInline = true;
            video.controls = false;
            video.removeAttribute('controls');
            video.style.pointerEvents = 'auto';
            video.style.cursor = 'pointer';
            // 禁止右键菜单和拖拽
            video.addEventListener('contextmenu', function (e) { e.preventDefault(); });
            video.addEventListener('dragstart', function (e) { e.preventDefault(); });
            video.addEventListener('selectstart', function (e) { e.preventDefault(); });
        }
        // ====== END ======
        // 初始化视频
        function setVideo(idx) {
            video.src = videoList[idx];
            video.load();
            video.play();
            // 彻底移除控件属性
            video.removeAttribute('controls');
            video.setAttribute('controls', false);
            video.controls = false;
            // 优先cover，自动检测黑边，若有黑边则切fill
            video.style.objectFit = 'cover';
            setTimeout(() => {
                // 检查是否有黑边（画面未充满）
                const vw = video.offsetWidth, vh = video.offsetHeight;
                const rw = video.videoWidth, rh = video.videoHeight;
                if (rw && rh) {
                    const scale = Math.max(vw / rw, vh / rh);
                    const realW = rw * scale, realH = rh * scale;
                    // 如果实际渲染宽高比容器小，说明有黑边
                    if (realW < vw - 2 || realH < vh - 2) {
                        video.style.objectFit = 'fill';
                    }
                }
            }, 300);
            // 每次切换都重新加最强力循环措施
            superForceVideoLoop(video);
        }
        setVideo(currentIndex);
        // 保证视频无缝循环
        // superForceVideoLoop(video); // 已在setVideo中调用
        // 进入全屏的函数
        function enterFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }
        let hasEnteredFullscreen = false;
        // 用mousedown监听左键，防止右键/中键误触
        document.addEventListener('mousedown', function (e) {
            if (e.button !== 0) return; // 只响应左键
            // 第一次点击进入全屏
            if (!hasEnteredFullscreen) {
                enterFullscreen();
                hasEnteredFullscreen = true;
                return;
            }
            // 之后每次左键切换下一个视频
            currentIndex = (currentIndex + 1) % videoList.length;
            setVideo(currentIndex);
        });
        // ====== 流星雨特效实现 ======
        const meteorCanvas = document.getElementById('meteorCanvas');
        const ctx = meteorCanvas.getContext('2d');
        function resizeCanvas() {
            meteorCanvas.width = window.innerWidth;
            meteorCanvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 星尘粒子类
        class Stardust {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                // 增加粒子向两侧散开的随机速度
                const scatterFactor = 0.6 + Math.random() * 0.6; // 散开因子更大
                this.vx = vx * (0.1 + Math.random() * 0.15) + (Math.random() - 0.5) * scatterFactor; // 尾迹基本速度 + 散开速度
                this.vy = vy * (0.1 + Math.random() * 0.15) + (Math.random() - 0.5) * scatterFactor; // 尾迹基本速度 + 散开速度
                this.alpha = 0.92 + Math.random() * 0.08; // 提高初始透明度
                this.radius = 0.25 + Math.random() * 0.18; // 粒子更小更锐利
                this.color = color; // 继承流星主体的渐变
                this.life = 0;
                this.maxLife = 22 + Math.random() * 10; // 生命周期更短
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha *= 0.975; // 衰减更慢，尾迹更清晰
                this.life++;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha; // 使用粒子自身的透明度
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 3; // 更锐利的发光
                ctx.fill();
                ctx.restore();
            }
            isAlive() {
                return this.alpha > 0.03 && this.life < this.maxLife; // 调整存活判断
            }
        }

        // 超级无敌丰富的渐变色组
        const nebulaColors = [
            ['#fffbe6', '#b5e3ff', '#a7a6ff', '#ffb6e6', '#ffe6fb', '#ffe6b6', '#b6ffe6'],
            ['#fff', '#aee9f7', '#b7aaff', '#ffb6b9', '#ffe6e6', '#e6ffe6', '#b6e6ff'],
            ['#fff', '#b5e3ff', '#a7a6ff', '#b9fffa', '#e6ffe6', '#ffe6e6', '#e6b6ff'],
            ['#fff', '#e0e7ff', '#b5e3ff', '#c2ffd3', '#ffe6fb', '#ffe6b6', '#e6fff7'],
            ['#fff', '#ffe6e6', '#ffd6e0', '#e6e6ff', '#b6e6ff', '#e6b6ff', '#ffe6b6'],
            ['#fff', '#ffe6b6', '#ffe6fb', '#b6ffe6', '#e6b6ff', '#e6f7ff', '#b6e6ff'],
            ['#fff', '#e6fff7', '#b6e6ff', '#e6b6ff', '#ffe6b6', '#e6e6ff', '#b6ffe6'],
            ['#fff', '#e6f7ff', '#b6ffe6', '#ffe6b6', '#e6b6ff', '#ffe6fb', '#b6e6ff'],
            ['#fff', '#e6e6ff', '#b6e6ff', '#e6ffe6', '#ffe6e6', '#b6ffe6', '#ffd6e0'],
            ['#fff', '#f6e6ff', '#e6e6ff', '#b6e6ff', '#e6ffe6', '#ffe6e6', '#e6fff7'],
            ['#fff', '#e6f7ff', '#b6e6ff', '#e6b6ff', '#ffe6b6', '#e6e6ff', '#b6ffe6'],
            ['#fff', '#e6e6ff', '#b6e6ff', '#e6ffe6', '#ffe6e6', '#b6ffe6', '#ffd6e0'],
            ['#fff', '#e6e6ff', '#b6e6ff', '#e6ffe6', '#ffe6e6', '#b6ffe6', '#ffd6e0'],
            ['#fff', '#e6e6ff', '#b6e6ff', '#e6ffe6', '#ffe6e6', '#b6ffe6', '#ffd6e0'],
            ['#fff', '#e6e6ff', '#b6e6ff', '#e6ffe6', '#ffe6e6', '#b6ffe6', '#ffd6e0'],
            ['#fff', '#e6e6ff', '#b6e6ff', '#e6ffe6', '#ffe6e6', '#b6ffe6', '#ffd6e0'],
            // 冰蓝色渐变
            ['#e6f7ff', '#b6e6ff', '#7fd8ff', '#4fc3f7', '#00bcd4', '#0097a7', '#005f6b'],
            // 金黄色渐变
            ['#fffbe6', '#ffe066', '#ffd700', '#ffc300', '#ffb300', '#ff9800', '#ff6f00'],
            // 更多色组可继续扩展
        ];

        // 流星类
        class Meteor {
            constructor() {
                // 轨迹角度更有宇宙感，随机但有主方向
                const baseAngle = Math.PI / 2.5;
                // 增加角度随机范围，使其更像从广阔宇宙而来
                this.angle = baseAngle + (Math.random() - 0.5) * 0.2; // 调整角度随机范围
                // 起点分布更自然，从屏幕上方及左右边缘外侧生成
                const margin = 100; // 增加边缘生成范围
                const startX = Math.random() * (meteorCanvas.width + margin * 2) - margin;
                const startY = Math.random() * meteorCanvas.height * 0.3 - meteorCanvas.height * 0.1; // 向上方偏移生成
                this.x = startX;
                this.y = startY;
                // 流星长度和速度变化更大，增加真实感
                this.length = Math.random() * 50 + 50; // 增加长度范围
                this.speed = Math.random() * 3 + 6; // 增加速度范围
                this.alpha = 1;
                // 超级无敌丰富渐变色
                const colorSet = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                // 根据新的起点和角度重新计算渐变方向
                this.gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.length * Math.cos(this.angle), this.y + this.length * Math.sin(this.angle));
                // 渐变点超级无敌多，确保清晰流畅的颜色过渡
                this.gradient.addColorStop(0, colorSet[0]);
                this.gradient.addColorStop(0.03, colorSet[1]); // 更多密集停靠点
                this.gradient.addColorStop(0.07, colorSet[2]);
                this.gradient.addColorStop(0.12, colorSet[3]);
                this.gradient.addColorStop(0.18, colorSet[4]);
                this.gradient.addColorStop(0.25, colorSet[5]);
                this.gradient.addColorStop(0.33, colorSet[6]);
                this.gradient.addColorStop(0.42, colorSet[0]);
                this.gradient.addColorStop(0.52, colorSet[1]);
                this.gradient.addColorStop(0.63, colorSet[2]);
                this.gradient.addColorStop(0.75, colorSet[3]);
                this.gradient.addColorStop(0.88, colorSet[4]);
                this.gradient.addColorStop(1, colorSet[5]); // 确保最后一个颜色也在渐变中
                // 头部高亮
                this.headColor = 'rgba(255,255,255,1)'; // 头部更亮
                // 尾迹星尘
                this.stardusts = [];
                // 速度向量
                this.vx = this.speed * Math.cos(this.angle);
                this.vy = this.speed * Math.sin(this.angle);
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha *= 0.98; // 主体消散速度
                // 拖尾星尘
                // 增加每次生成的星尘数量，让尾迹更浓密
                const particlesToGenerate = 7 + Math.floor(Math.random() * 4); // 每次生成7-10个粒子
                for (let i = 0; i < particlesToGenerate; i++) {
                    if (Math.random() < 0.98) { // 基本每次都生成
                        const spawnPos = 0.7 + Math.random() * 0.2;
                        this.stardusts.push(new Stardust(
                            this.x + this.length * Math.cos(this.angle) * spawnPos,
                            this.y + this.length * Math.sin(this.angle) * spawnPos,
                            -this.vx * (0.1 + Math.random() * 0.1) * (0.5 + Math.random() * 0.5),
                            -this.vy * (0.1 + Math.random() * 0.1) * (0.5 + Math.random() * 0.5),
                            this.gradient
                        ));
                    }
                }
                this.stardusts.forEach(s => s.update());
                this.stardusts = this.stardusts.filter(s => s.isAlive());
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(this.alpha, 0); // 主体透明度
                // 主体亮尾
                ctx.strokeStyle = this.gradient;
                ctx.shadowColor = this.gradient; // 投影颜色也使用渐变
                ctx.shadowBlur = 10; // 增加发光感
                ctx.lineWidth = 1; // 稍粗的线条
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.length * Math.cos(this.angle), this.y + this.length * Math.sin(this.angle));
                ctx.stroke();
                // 头部高亮
                ctx.beginPath();
                ctx.arc(this.x, this.y, 1.5, 0, 2 * Math.PI); // 头部稍大
                ctx.fillStyle = this.headColor;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10; // 头部发光
                ctx.globalAlpha = Math.max(this.alpha, 1); // 确保头部始终较亮
                ctx.fill();
                ctx.restore();
                // 拖尾星尘
                this.stardusts.forEach(s => s.draw(ctx));
            }
            isAlive() {
                // 调整存活判断，使其在屏幕外也能存在一段时间，尾迹更自然
                return this.alpha > 0.02 && (this.x > -50 && this.x < meteorCanvas.width + 50 && this.y < meteorCanvas.height + 50);
            }
        }
        let meteors = [];
        let meteorRainActive = false;
        let meteorRainFading = false;
        let meteorRainAlpha = 1;
        let meteorRainFadeDuration = 2000; // 淡出总时长（毫秒）
        let meteorRainFadeStart = 0;

        function spawnMeteorRain() {
            meteors = [];
            meteorRainActive = true;
            meteorRainFading = false;
            meteorRainAlpha = 1;
            // 数量极多，突出群体感
            const numberOfMeteors = 120 + Math.floor(Math.random() * 50); // 增加流星数量
            for (let i = 0; i < numberOfMeteors; i++) {
                setTimeout(() => {
                    meteors.push(new Meteor());
                }, i * 12 + Math.random() * 8); // 调整生成间隔，让流星出现更紧密
            }
            // 持续时间稍微延长
            setTimeout(() => {
                meteorRainActive = false;
                meteorRainFading = true;
            }, 4000); // 延长流星雨持续时间
        }

        function drawMeteorRain() {
            ctx.clearRect(0, 0, meteorCanvas.width, meteorCanvas.height);
            if (meteorRainActive || meteorRainFading) {
                ctx.save();
                ctx.globalAlpha = meteorRainAlpha;
                meteors.forEach((m, idx) => {
                    m.update();
                    m.draw(ctx);
                });
                ctx.restore();
                meteors = meteors.filter(m => m.isAlive());
                // 如果处于淡出阶段，逐步降低透明度
                if (meteorRainFading) {
                    meteorRainAlpha *= 0.99; // 指数递减，越到后面越慢，更丝滑
                    if (meteorRainAlpha <= 0.01) { // 透明度阈值调低
                        meteorRainAlpha = 0;
                        meteorRainFading = false;
                        meteors = [];
                    }
                }
            }
            requestAnimationFrame(drawMeteorRain);
        }
        drawMeteorRain();
        // 右键生成流星雨
        video.addEventListener('contextmenu', function (e) {
            e.preventDefault();
            spawnMeteorRain();
            // 延迟5s后生成44束烟花，避免与流星雨动画冲突
            setTimeout(() => {
                for (let i = 0; i < 80; i++) {
                    fireworkDirectExplode();
                }
            }, 12000);
        });

        // ====== 烟花粒子特效（直接爆炸版） ======
        function fireworkDirectExplode() {
            // 创建或复用canvas
            let fwCanvas = document.getElementById('firework-canvas');
            if (!fwCanvas) {
                fwCanvas = document.createElement('canvas');
                fwCanvas.id = 'firework-canvas';
                fwCanvas.style.position = 'fixed';
                fwCanvas.style.left = '0';
                fwCanvas.style.top = '0';
                fwCanvas.style.width = '100vw';
                fwCanvas.style.height = '100vh';
                fwCanvas.style.pointerEvents = 'none';
                fwCanvas.style.zIndex = '10001'; // 高于视频和流星雨
                document.body.appendChild(fwCanvas);
            }
            const dpr = window.devicePixelRatio || 1;
            fwCanvas.width = window.innerWidth * dpr;
            fwCanvas.height = window.innerHeight * dpr;
            const ctx = fwCanvas.getContext('2d', { alpha: true });
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = true;

            // 随机爆炸点
            const cx = Math.random() * window.innerWidth;
            const cy = Math.random() * window.innerHeight * 0.85 + window.innerHeight * 0.05;

            // 色彩配置
            const colorPalettes = [
                ['#ff5e62', '#ff9966', '#ffcc33', '#ff3366', '#ff99cc'],
                ['#4facfe', '#00f2fe', '#38f9d7', '#43e97b', '#a6c1ee'],
                ['#a18cd1', '#fbc2eb', '#fad0c4', '#ff9a9e', '#f6d365'],
                ['#667eea', '#764ba2', '#89f7fe', '#66a6ff', '#b06ab3'],
                ['#ff8a00', '#e100ff', '#3a7bd5', '#00d2ff', '#f46b45']
            ];
            const selectedPalette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];
            const baseColor = selectedPalette[Math.floor(Math.random() * selectedPalette.length)];

            // 粒子生成
            function getGradientColor(baseColor, variation) {
                const hsl = hexToHSL(baseColor);
                const newH = (hsl.h + (Math.random() - 0.5) * variation) % 360;
                const newS = Math.min(100, Math.max(80, hsl.s + (Math.random() - 0.5) * 20));
                const newL = Math.min(95, Math.max(50, hsl.l + (Math.random() - 0.5) * 15));
                return HSLToHex(newH, newS, newL);
            }
            function hexToHSL(hex) {
                let r = parseInt(hex.substring(1, 3), 16);
                let g = parseInt(hex.substring(3, 5), 16);
                let b = parseInt(hex.substring(5, 7), 16);
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) { h = s = 0; } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
            }
            function HSLToHex(h, s, l) {
                h /= 360; s /= 100; l /= 100;
                let r, g, b;
                if (s === 0) { r = g = b = l; }
                else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                const toHex = x => { const hex = Math.round(x * 255).toString(16); return hex.length === 1 ? '0' + hex : hex; };
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }
            // 创建爆炸粒子
            function createParticles(cx, cy, baseColor) {
                const particles = [];
                const count = 300 + Math.floor(Math.random() * 200);
                const hueVariation = 30 + Math.random() * 50;
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1.5 + Math.random() * 5;
                    const color = getGradientColor(baseColor, hueVariation);
                    particles.push({
                        x: cx, y: cy,
                        vx: Math.cos(angle) * speed * (0.7 + Math.random() * 0.6),
                        vy: Math.sin(angle) * speed * (0.7 + Math.random() * 0.6),
                        alpha: 1, color,
                        size: 0.5 + Math.random() * 1.5,
                        life: 0, maxLife: 50 + Math.random() * 50,
                        type: 'spark', decay: 0.92 + Math.random() * 0.05,
                        gravity: 0.02 + Math.random() * 0.03
                    });
                }
                // 闪光粒子
                const flashCount = 10 + Math.floor(Math.random() * 15);
                for (let i = 0; i < flashCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.8 + Math.random() * 2;
                    particles.push({
                        x: cx, y: cy,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        alpha: 1, color: '#fff',
                        size: 3 + Math.random() * 8,
                        life: 0, maxLife: 20 + Math.random() * 15,
                        type: 'flash', decay: 0.85 + Math.random() * 0.1
                    });
                }
                // 星形粒子
                const starCount = 20 + Math.floor(Math.random() * 30);
                for (let i = 0; i < starCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.3 + Math.random() * 1.2;
                    const color = getGradientColor(baseColor, hueVariation);
                    particles.push({
                        x: cx, y: cy,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        alpha: 1, color,
                        size: 2 + Math.random() * 3,
                        life: 0, maxLife: 100 + Math.random() * 60,
                        type: 'star',
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.15,
                        points: 5 + Math.floor(Math.random() * 4),
                        gravity: 0.01 + Math.random() * 0.02
                    });
                }
                return particles;
            }
            // 直接爆炸，无升空
            const firework = {
                x: cx, y: cy, exploded: true, particles: createParticles(cx, cy, baseColor)
            };
            let fireworks = fwCanvas._fireworks || [];
            fireworks.push(firework);
            fwCanvas._fireworks = fireworks;
            if (!fwCanvas._animating) {
                fwCanvas._animating = true;
                requestAnimationFrame(animate);
            }
            function animate() {
                ctx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
                let stillAnimating = false;
                for (let fw of fwCanvas._fireworks) {
                    // 绽放阶段
                    let alive = false;
                    for (let i = 0; i < fw.particles.length; i++) {
                        const p = fw.particles[i];
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += (p.gravity || 0.03);
                        p.vx *= (p.decay || 0.96);
                        p.vy *= (p.decay || 0.96);
                        p.life++;
                        p.x = Math.max(0, Math.min(p.x, fwCanvas.width));
                        p.y = Math.max(0, Math.min(p.y, fwCanvas.height));
                        switch (p.type) {
                            case 'spark':
                                p.alpha = 1 - Math.pow(p.life / p.maxLife, 1.8);
                                p.size *= 0.98;
                                break;
                            case 'flash':
                                p.alpha = 1 - Math.pow(p.life / p.maxLife, 3);
                                p.size *= 0.92;
                                break;
                            case 'star':
                                p.alpha = 1 - Math.pow(p.life / p.maxLife, 1.2);
                                p.rotation += p.rotationSpeed;
                                p.size *= 0.99;
                                break;
                        }
                        if (p.alpha > 0.01) {
                            ctx.save();
                            ctx.globalAlpha = p.alpha;
                            ctx.globalCompositeOperation = 'lighter';
                            if (p.type === 'star') {
                                ctx.translate(p.x, p.y);
                                ctx.rotate(p.rotation);
                                const starGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size);
                                starGrad.addColorStop(0, '#fff');
                                starGrad.addColorStop(0.5, p.color);
                                starGrad.addColorStop(1, 'rgba(255,255,255,0)');
                                ctx.fillStyle = starGrad;
                                const spikes = p.points || 5;
                                const outerRadius = p.size;
                                const innerRadius = p.size * (0.3 + Math.random() * 0.2);
                                ctx.beginPath();
                                for (let i = 0; i < spikes; i++) {
                                    const outerAngle = (i * 2 * Math.PI / spikes) - Math.PI / 2;
                                    const innerAngle = ((i + 0.5) * 2 * Math.PI / spikes) - Math.PI / 2;
                                    ctx.lineTo(Math.cos(outerAngle) * outerRadius, Math.sin(outerAngle) * outerRadius);
                                    ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
                                }
                                ctx.closePath();
                                ctx.fill();
                            } else {
                                const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                                if (p.type === 'flash') {
                                    grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                                    grad.addColorStop(0.5, 'rgba(255,255,255,0.5)');
                                    grad.addColorStop(1, 'rgba(255,255,255,0)');
                                } else {
                                    grad.addColorStop(0, 'rgba(255,255,255,0.8)');
                                    grad.addColorStop(0.3, `${p.color.replace(')', ', 0.7)')}`);
                                    grad.addColorStop(1, 'rgba(255,255,255,0)');
                                }
                                ctx.fillStyle = grad;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                            ctx.restore();
                            if (p.life < p.maxLife && p.alpha > 0.02) {
                                alive = true;
                            }
                        }
                    }
                    if (alive) stillAnimating = true;
                }
                fwCanvas._fireworks = fwCanvas._fireworks.filter(fw => fw.particles.some(p => p.life < p.maxLife && p.alpha > 0.02));
                if (stillAnimating) {
                    requestAnimationFrame(animate);
                } else {
                    fwCanvas._animating = false;
                    ctx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
                }
            }
            // 响应窗口缩放
            window.addEventListener('resize', () => {
                fwCanvas.width = window.innerWidth * dpr;
                fwCanvas.height = window.innerHeight * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            });
        }
    </script>
    <script>
        // ====== 全面优化的如梦似幻彩虹特效 ======
        let rainbowCanvas = document.getElementById('rainbow-canvas');
        if (!rainbowCanvas) {
            rainbowCanvas = document.createElement('canvas');
            rainbowCanvas.id = 'rainbow-canvas';
            rainbowCanvas.style.position = 'fixed';
            rainbowCanvas.style.left = '0';
            rainbowCanvas.style.top = '0';
            rainbowCanvas.style.width = '100vw';
            rainbowCanvas.style.height = '100vh';
            rainbowCanvas.style.pointerEvents = 'none';
            rainbowCanvas.style.zIndex = '10002';
            document.body.appendChild(rainbowCanvas);
        }
        function resizeRainbowCanvas() {
            const dpr = window.devicePixelRatio || 1;
            rainbowCanvas.width = window.innerWidth * dpr;
            rainbowCanvas.height = window.innerHeight * dpr;
        }
        resizeRainbowCanvas();
        window.addEventListener('resize', resizeRainbowCanvas);

        // 彩虹参数
        let rainbowActive = false;
        let rainbowAlpha = 0;
        let rainbowFadeIn = true;
        let rainbowFadeOut = false;
        let rainbowShowTime = 0;
        let rainbowMaxAlpha = 0.9; // 提高最大透明度
        let rainbowDuration = 1000; // 延长到2秒
        let rainbowFadeSpeed = 0.05; // 淡入淡出更快
        let rainbowAnimating = false;
        let rainbowParticles = [];
        const rainbowLayers = 18; // 增加层数，减小每层宽度
        const rainbowColors = [
            'rgba(255,0,0,0.22)',    // 红
            'rgba(255,127,0,0.20)',  // 橙
            'rgba(255,255,0,0.18)',  // 黄
            'rgba(0,255,0,0.20)',    // 绿
            'rgba(0,191,255,0.22)',  // 青
            'rgba(0,0,255,0.20)',    // 蓝
            'rgba(139,0,255,0.22)'   // 紫
        ];

        // 生成漂浮粒子
        function createRainbowParticles(cx, cy, outerR, innerR, count) {
            const particles = [];
            for (let i = 0; i < count; i++) {
                const angle = Math.PI * (i / (count - 1));
                const r = outerR - Math.random() * (outerR - innerR) * 0.8;
                const x = cx + Math.cos(angle) * r + (Math.random() - 0.5) * 10;
                const y = cy + Math.sin(angle) * r + (Math.random() - 0.5) * 10;
                const color = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
                particles.push({
                    x, y,
                    baseX: x, baseY: y,
                    color,
                    alpha: 0.28 + Math.random() * 0.22, // 提高粒子可见度
                    size: 8 + Math.random() * 12,
                    floatSpeed: 0.18 + Math.random() * 0.22,
                    floatPhase: Math.random() * Math.PI * 2,
                    twinkle: 0.7 + Math.random() * 0.6
                });
            }
            return particles;
        }

        // 绘制主彩虹桥（多层渐变弧，方向修正为下半圆，增强朦胧美）
        function drawRainbowArc(ctx, cx, cy, outerR, innerR, alpha) {
            // 渐变点更密集，色彩更细腻
            const colorStops = [0, 0.16, 0.32, 0.48, 0.64, 0.80, 1];
            const layerWidth = (outerR - innerR) / rainbowLayers;
            for (let layer = 0; layer < rainbowLayers; layer++) {
                const r1 = outerR - layer * layerWidth;
                const r2 = r1 - layerWidth; // 保证每层紧贴
                ctx.save();
                ctx.globalAlpha = alpha * (0.28 + 0.18 * (rainbowLayers - layer) / rainbowLayers); // 提高主弧可见度
                ctx.lineWidth = r1 - r2 + 0.5; // +0.5防止像素缝隙
                // 更通透的五彩渐变
                const grad = ctx.createLinearGradient(cx - r1, cy, cx + r1, cy);
                for (let i = 0; i < rainbowColors.length; i++) {
                    grad.addColorStop(colorStops[i], rainbowColors[i]);
                }
                ctx.strokeStyle = grad;
                ctx.shadowColor = 'rgba(255,255,255,0.13)';
                ctx.shadowBlur = 18 + 6 * layer;
                ctx.beginPath();
                ctx.arc(cx, cy, (r1 + r2) / 2, Math.PI, 2 * Math.PI, false);
                ctx.stroke();
                ctx.restore();
            }
            // 柔光高光
            ctx.save();
            ctx.globalAlpha = alpha * 0.18; // 柔光更明显
            const grad = ctx.createRadialGradient(cx, cy, outerR * 0.7, cx, cy, outerR * 1.1);
            grad.addColorStop(0, 'rgba(255,255,255,0.10)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.beginPath();
            ctx.arc(cx, cy, outerR * 1.1, Math.PI, 2 * Math.PI, false);
            ctx.fillStyle = grad;
            ctx.filter = 'blur(12px)';
            ctx.fill();
            ctx.filter = 'none';
            ctx.restore();
            // 朦胧淡雾层
            ctx.save();
            ctx.globalAlpha = alpha * 0.13; // 雾气更明显
            const mistGrad = ctx.createRadialGradient(cx, cy + outerR * 0.45, outerR * 0.2, cx, cy + outerR * 0.7, outerR * 0.8);
            mistGrad.addColorStop(0, 'rgba(220,230,255,0.10)');
            mistGrad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.beginPath();
            ctx.arc(cx, cy + outerR * 0.6, outerR * 0.8, Math.PI, 2 * Math.PI, false);
            ctx.fillStyle = mistGrad;
            ctx.filter = 'blur(22px)';
            ctx.fill();
            ctx.filter = 'none';
            ctx.restore();
        }

        // 缓动函数（更丝滑）
        function easeInOutSine(t) {
            return -(Math.cos(Math.PI * t) - 1) / 2;
        }

        // 绘制如梦似幻的彩虹
        function drawRainbow() {
            if (!rainbowActive && rainbowAlpha <= 0.01) {
                if (!rainbowBurstTriggered) {
                    // 触发五彩星光粒子爆发
                    const dpr = window.devicePixelRatio || 1;
                    const margin = 8 * dpr;
                    const maxOuterR = Math.min(rainbowCanvas.width / 2 - margin, rainbowCanvas.height - margin);
                    const outerR = maxOuterR * 0.98;
                    const cx = rainbowCanvas.width / 2;
                    const cy = outerR + margin;
                    setTimeout(() => triggerRainbowBurst(cx, cy, outerR), 80); // 延迟触发，确保视觉衔接
                    rainbowBurstTriggered = true;
                }
                rainbowAnimating = false;
                const ctx = rainbowCanvas.getContext('2d');
                ctx.clearRect(0, 0, rainbowCanvas.width, rainbowCanvas.height);
                return;
            }
            rainbowBurstTriggered = false;
            rainbowAnimating = true;
            const ctx = rainbowCanvas.getContext('2d');
            ctx.clearRect(0, 0, rainbowCanvas.width, rainbowCanvas.height);
            const dpr = window.devicePixelRatio || 1;
            const margin = 8 * dpr;
            const maxOuterR = Math.min(rainbowCanvas.width / 2 - margin, rainbowCanvas.height - margin);
            const outerR = maxOuterR * 0.98;
            const innerR = outerR * 0.5;
            const cx = rainbowCanvas.width / 2;
            const cy = outerR + margin;
            // ====== 丝滑淡入淡出 ======
            let displayAlpha = rainbowAlpha;
            if (rainbowFadeIn) {
                displayAlpha = easeInOutSine(Math.min(rainbowAlpha / rainbowMaxAlpha, 1)) * rainbowMaxAlpha;
            } else if (rainbowFadeOut) {
                displayAlpha = easeInOutSine(Math.max(rainbowAlpha / rainbowMaxAlpha, 0)) * rainbowMaxAlpha;
            }
            // 主彩虹桥
            drawRainbowArc(ctx, cx, cy, outerR, innerR, displayAlpha);
            // 彩虹漂浮粒子
            for (let i = 0; i < rainbowParticles.length; i++) {
                const p = rainbowParticles[i];
                const t = Date.now() / 900 + p.floatPhase;
                // 朦胧漂浮+色彩漂移
                const fx = p.baseX + Math.sin(t * p.floatSpeed) * 14;
                const fy = p.baseY + Math.cos(t * p.floatSpeed) * 9;
                ctx.save();
                ctx.globalAlpha = p.alpha * (0.3 + 0.7 * Math.sin(t * p.twinkle)) * displayAlpha;
                // 粒子径向渐变，中心白色更淡，外圈彩色更淡，色彩轻微漂移
                let color = p.color.replace(/rgba\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, (m, r, g, b, a) => `rgba(${r},${g},${b},${parseFloat(a) * 0.7})`);
                const grad = ctx.createRadialGradient(fx, fy, 0, fx, fy, p.size);
                grad.addColorStop(0, 'rgba(255,255,255,0.22)');
                grad.addColorStop(0.4, color);
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.beginPath();
                ctx.arc(fx, fy, p.size, 0, 2 * Math.PI);
                ctx.fillStyle = grad;
                ctx.shadowColor = color;
                ctx.shadowBlur = 14 + Math.random() * 10;
                ctx.filter = 'blur(3.2px)';
                ctx.fill();
                ctx.filter = 'none';
                ctx.restore();
            }
            // 柔光外晕
            ctx.save();
            ctx.globalAlpha = displayAlpha * 0.22;
            const grad2 = ctx.createRadialGradient(cx, cy + outerR * 0.5, outerR * 0.7, cx, cy + outerR * 0.7, outerR * 1.3);
            grad2.addColorStop(0, 'rgba(255,255,255,0.09)');
            grad2.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.beginPath();
            ctx.arc(cx, cy + outerR * 0.7, outerR * 1.3, Math.PI, 2 * Math.PI, false);
            ctx.fillStyle = grad2;
            ctx.filter = 'blur(28px)';
            ctx.fill();
            ctx.filter = 'none';
            ctx.restore();
            // 额外流动雾气层
            ctx.save();
            ctx.globalAlpha = displayAlpha * 0.10;
            const mistGrad2 = ctx.createRadialGradient(cx, cy + outerR * 0.9, outerR * 0.3, cx, cy + outerR * 1.1, outerR * 1.2);
            mistGrad2.addColorStop(0, 'rgba(200,220,255,0.08)');
            mistGrad2.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.beginPath();
            ctx.arc(cx, cy + outerR * 1.1, outerR * 1.2, Math.PI, 2 * Math.PI, false);
            ctx.fillStyle = mistGrad2;
            ctx.filter = 'blur(32px)';
            ctx.fill();
            ctx.filter = 'none';
            ctx.restore();
            // 彩虹淡入淡出动画
            if (rainbowFadeIn) {
                rainbowAlpha += rainbowFadeSpeed;
                if (rainbowAlpha >= rainbowMaxAlpha) {
                    rainbowAlpha = rainbowMaxAlpha;
                    rainbowFadeIn = false;
                    rainbowShowTime = Date.now();
                }
            } else if (rainbowFadeOut) {
                rainbowAlpha -= rainbowFadeSpeed * 0.7;
                if (rainbowAlpha <= 0.01) {
                    rainbowAlpha = 0;
                    rainbowFadeOut = false;
                    rainbowActive = false;
                }
            } else if (rainbowActive && Date.now() - rainbowShowTime > rainbowDuration) {
                rainbowFadeOut = true;
            }
            requestAnimationFrame(drawRainbow);
        }

        // 触发彩虹特效
        function showDreamyRainbow() {
            const dpr = window.devicePixelRatio || 1;
            const margin = 8 * dpr;
            const maxOuterR = Math.min(rainbowCanvas.width / 2 - margin, rainbowCanvas.height - margin);
            const outerR = maxOuterR * 0.98;
            const innerR = outerR * 0.5;
            const cx = rainbowCanvas.width / 2;
            const cy = outerR + margin;
            rainbowParticles = createRainbowParticles(cx, cy, outerR, innerR, 140);
            rainbowActive = true;
            rainbowAlpha = 0.01;
            rainbowFadeIn = true;
            rainbowFadeOut = false;
            rainbowShowTime = 0;
            if (!rainbowAnimating) {
                drawRainbow();
            }
        }

        // 鼠标中键单击触发彩虹
        document.addEventListener('mousedown', function (e) {
            if (e.button === 1) {
                showDreamyRainbow();
            }
        });

        // ====== 彩虹消失后自动喷射五彩星光粒子爆发 ======
        let rainbowBurstTriggered = false;
        function triggerRainbowBurst(cx, cy, outerR) {
            // 创建或复用canvas
            let burstCanvas = document.getElementById('rainbow-burst-canvas');
            if (!burstCanvas) {
                burstCanvas = document.createElement('canvas');
                burstCanvas.id = 'rainbow-burst-canvas';
                burstCanvas.style.position = 'fixed';
                burstCanvas.style.left = '0';
                burstCanvas.style.top = '0';
                burstCanvas.style.width = '100vw';
                burstCanvas.style.height = '100vh';
                burstCanvas.style.pointerEvents = 'none';
                burstCanvas.style.zIndex = '10003';
                document.body.appendChild(burstCanvas);
            }
            const dpr = window.devicePixelRatio || 1;
            burstCanvas.width = window.innerWidth * dpr;
            burstCanvas.height = window.innerHeight * dpr;
            const ctx = burstCanvas.getContext('2d');
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            // 爆发中心点始终为屏幕正中央
            const bx = window.innerWidth / 2;
            const by = window.innerHeight / 2;
            // 彩虹渐变色
            const burstColors = [
                '#ff0000', '#ff9900', '#ffee00', '#33ff00', '#00eaff', '#0055ff', '#cc00ff', '#fff'
            ];
            // 粒子生成
            let particles = [];
            for (let i = 0; i < 3000; i++) { // 数量大幅增加
                const angle = Math.random() * Math.PI * 2;
                const speed = 9 + Math.random() * 19.0;
                particles.push({
                    x: bx,
                    y: by,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    r: 0.2 + Math.random() * 0.7, // 尺寸更小
                    color: burstColors[Math.floor(Math.random() * burstColors.length)],
                    alpha: 1,
                    life: 0,
                    maxLife: 44 + Math.random() * 44
                });
            }
            burstCanvas.style.opacity = 1;
            let animating = true;
            function animate() {
                ctx.clearRect(0, 0, burstCanvas.width, burstCanvas.height);
                let alive = false;
                for (let p of particles) {
                    if (p.alpha > 0.05 && p.life < p.maxLife) {
                        alive = true;
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.055;
                        p.life++;
                        p.alpha *= 0.978;
                        ctx.save();
                        ctx.globalAlpha = p.alpha;
                        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * (1.2 + Math.random() * 0.5));
                        grad.addColorStop(0, '#fff');
                        grad.addColorStop(0.3, p.color);
                        grad.addColorStop(1, 'rgba(255,255,255,0)');
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                        ctx.fillStyle = grad;
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 8 + Math.random() * 8;
                        ctx.filter = 'blur(1.2px)';
                        ctx.fill();
                        ctx.filter = 'none';
                        ctx.restore();
                    }
                }
                if (alive) {
                    requestAnimationFrame(animate);
                } else {
                    burstCanvas.style.opacity = 0;
                    animating = false;
                }
            }
            animate();
        }
    </script>
    <script>
        // 中键长按跳转
        let middleMouseDownTimer = null;
        window.addEventListener('mousedown', function (event) {
            if (event.button === 1) { // 1 表示鼠标中键
                middleMouseDownTimer = setTimeout(function () {
                    window.location.href = './wandering-earth.html';
                }, 1000); // 1秒
            }
        });

        window.addEventListener('mouseup', function (event) {
            if (event.button === 1) { // 1 表示鼠标中键
                if (middleMouseDownTimer) {
                    clearTimeout(middleMouseDownTimer);
                    middleMouseDownTimer = null;
                }
            }
        });

        // 防止中键点击时出现上下文菜单
        window.addEventListener('contextmenu', function (event) {
            if (event.button === 1) {
                event.preventDefault();
            }
        });




        function forceVideoLoop(video) {
            if (!video) return;
            // 彻底移除loop属性后再加上
            video.removeAttribute('loop');
            video.setAttribute('loop', 'loop');
            // 多重保险：事件+定时器+属性
            function realLoop() {
                if (video.ended || video.paused || (video.duration - video.currentTime < 0.2)) {
                    video.currentTime = 0.01;
                    let p = video.play();
                    if (p && p.catch) p.catch(() => { setTimeout(() => { video.play(); }, 100); });
                }
            }
            video.addEventListener('ended', realLoop);
            video.addEventListener('timeupdate', function () {
                if (video.duration - video.currentTime < 0.05) {
                    video.currentTime = 0.01;
                    video.play();
                }
            });
            // 火狐file协议下再加一层保险
            var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            var isFileProtocol = window.location.protocol === 'file:';
            if (isFirefox && isFileProtocol) {
                if (!window._ffLoopInterval) {
                    window._ffLoopInterval = setInterval(realLoop, 200);
                }
            }
            // 其他浏览器也加保险
            if (!window._videoLoopInterval) {
                window._videoLoopInterval = setInterval(realLoop, 500);
            }
            // 属性保险
            video.setAttribute('autoplay', 'autoplay');
            video.autoplay = true;
            video.setAttribute('muted', 'muted');
            video.muted = true;
            video.setAttribute('playsinline', '');
            video.playsInline = true;
            video.controls = false;
            video.removeAttribute('controls');
            video.style.pointerEvents = 'auto';
            video.style.cursor = 'pointer';
            // 禁止右键菜单和拖拽
            video.addEventListener('contextmenu', function (e) { e.preventDefault(); });
            video.addEventListener('dragstart', function (e) { e.preventDefault(); });
            video.addEventListener('selectstart', function (e) { e.preventDefault(); });
        }




    </script>
</body>

</html>