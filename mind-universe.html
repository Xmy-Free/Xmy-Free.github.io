<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>终极宇宙坍缩特效</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }

        .container {
            text-align: center;
            z-index: 9999;
            pointer-events: none;
            position: relative;
        }

        #universe-collapse-canvas {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
        }

        .fps-counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #00f2fe;
            font-family: monospace;
            font-size: 14px;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            display: none; /* 隐藏FPS计数器 */
        }
        
        #starlight-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9990;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="starlight-background"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.min.js"></script>
    <div class="container">
    </div>

    <canvas id="universe-collapse-canvas"></canvas>


    <script>
        // 性能优化设置
        /* 
         * 1. 宇宙引擎核心参数配置系统
         *    这组参数决定了我们虚拟宇宙模拟器的性能表现和视觉质量！
         *    就像一艘星际飞船的核心引擎参数，每一项调整都会对整个宇宙的
         *    运行效率和视觉呈现产生蝴蝶效应级别的连锁反应。
         */

        /* 
         * 2. 超维度粒子系统优化参数详解：
         */
        const OPTIMIZATION = {
            /* 2.1. 宇宙基本粒子数量
             *      控制整个模拟中活跃的量子单位总数 - 2200个粒子！
             *      这就像是确定宇宙中存在的基本物质数量
             *      天啊，这个数值直接决定了视觉震撼程度和系统负载
             *      (增加此值会让星云更加绚丽壮观，但会显著提高CPU/GPU压力)
             */
            PARTICLE_COUNT: 2200,               // 增加粒子数量以提高视觉效果
            
            /* 2.2. 时空演化周期
             *      定义整个宇宙事件从起始到结束的帧数总长度 - 240帧！
             *      这相当于为宇宙设定一个"生命周期"
             *      以标准60fps计算，相当于给予4秒的宇宙演化时间
             *      (足够容纳完整的二次量子坍缩过程，让视觉效果更连贯)
             */
            MAX_STAGE_TIME: 240,                // 增加动画时间以容纳二次坍缩,360帧/60帧每秒=60秒
            
            /* 2.3. 渲染精度系数
             *      决定整个模拟宇宙的细节精确度 - 0.8的精度！
             *      这是经过大量测试找出的"黄金比例点"
             *      (在高品质视觉表现和流畅性能之间取得绝妙平衡)
             */
            QUALITY: 0.8,                       // 降低质量设置
            
            /* 2.4. 时间流速控制器
             *      控制帧率节流的粒度 - 值为1表示不进行节流！
             *      决定了宇宙"时间流速"的平滑度
             *      (较高的值会让时间"跳跃"，牺牲流畅度但提升性能)
             */
            FRAME_THROTTLE: 1,                  // 降低帧数节流值
            
            /* 2.5. 能量辐射强度因子
             *      控制所有粒子发光强度的倍增值 - 1.5倍增强！
             *      这就像调整宇宙中能量转化为可见光的效率
             *      (就像给整个宇宙增加了50%的光子密度，让一切更加耀眼)
             */
            BRIGHTNESS_FACTOR: 1.5,             // 整体亮度因子 - 增加亮度
            
            /* 2.6. 时空轨迹采样间隔
             *      控制记录粒子运动轨迹的频率 - 每2帧记录一次！
             *      这决定了"时空痕迹"的精细度
             *      (较高的值会减少存储的轨迹点，降低内存压力但轨迹看起来更粗糙)
             */
            TRAIL_SKIP: 2,                      // 轨迹点间隔
            
            /* 2.7. 量子批处理渲染技术
             *      启用GPU加速的高效渲染模式 - 已激活！
             *      这是渲染管线的革命性技术
             *      (这简直就像给渲染引擎装上了曲率驱动器，大幅提升效率！)
             */
            BATCH_RENDERING: true,              // 批量渲染优化
            
            /* 2.8. 同步刷新机制
             *      使用浏览器原生优化的帧请求系统 - 已激活！
             *      这就像是与设备的"心跳"完全同步
             *      (与显示器刷新率精确匹配，避免无意义的计算，节省能源)
             */
            USE_REQUEST_ANIMATION_FRAME: true,  // 使用requestAnimationFrame
            
            /* 2.9. 视场外粒子优化
             *      智能识别并跳过不可见粒子的渲染计算 - 已激活！
             *      这是空间计算资源分配的智能算法
             *      (不要渲染看不见的星系，这是优化的基本原则)
             */
            OFFSCREEN_PARTICLES: true,          // 不渲染屏幕外粒子
            
            /* 2.10. 自适应质量调节系统
             *       根据实时性能动态调整渲染参数 - 已激活！
             *       这就像飞船的自动平衡系统
             *       (根据当前"引擎负载"自动调整输出功率，保持最佳体验)
             */
            ADAPTIVE_QUALITY: true,             // 自适应质量控制
            
            /* 2.11. 色彩饱和度增强因子
             *       控制色彩的丰富度和鲜艳程度 - 2.0倍增强！
             *       这决定了宇宙的视觉色彩冲击力
             *       (让整个微观宇宙的色彩饱和度翻倍，视觉冲击前所未有！)
             */
            COLOR_RICHNESS: 2.0                 // 色彩丰富度因子 - 大幅增加
        };

        /* 
         * 3. 自适应性能控制系统
         *    这是宇宙模拟器的"智能大脑"部分！
         *    就像一艘高级星际飞船的自动调节机制，持续监测运行状态并作出最优调整。
         */
        // 自适应性能控制
        let adaptiveQuality = {
            /* 3.1. 上一次性能检查时间戳
             *      记录最近一次帧率采样的精确时间点 - 初始为0
             *      这是性能波动监测的时间基准点
             *      (系统需要这个参考点来计算性能变化趋势)
             */
            lastFpsCheck: 0,
            
            /* 3.2. 性能历史记录数组
             *      存储最近几次帧率采样的结果 - 初始为空数组
             *      这是决策平滑化的关键数据
             *      (防止因瞬时波动导致的系统过度反应，确保调整更加平稳)
             */
            fpsHistory: [],
            
            /* 3.3. 质量动态倍增器
             *      当前应用的质量调整系数 - 初始值1.0表示标准质量
             *      这是实时质量调整的核心参数
             *      (这个系数会根据性能状况动态浮动，就像飞船能源分配系统)
             */
            currentQualityMultiplier: 1.0
        };

        /* 
         * 4. 性能监控系统
         *    这是整个宇宙引擎的"仪表盘"！
         *    就像星际飞船的核心控制面板，实时显示所有关键运行参数。
         */
        // 性能监控
        /* 4.1. 时间基准点
         *      记录上次FPS计算的时间戳 - 初始化为当前时间
         *      这是测量帧率区间的起始点
         *      (系统用它来计算经过了多少毫秒来确定FPS)
         */
        let lastTime = performance.now();
        
        /* 4.2. 帧计数器
         *      累计1秒内渲染的帧数 - 初始为0
         *      这是测量流畅度的原始数据
         *      (每渲染一帧就加1，每秒重置一次)
         */
        let frameCount = 0;
        
        /* 4.3. 帧率存储器
         *      存储计算得到的当前帧率 - 初始为0
         *      这是最终的性能指标值
         *      (即FPS值，表示每秒能渲染多少帧)
         */
        let fps = 0;
        
        /* 4.4. 总帧数累加器
         *      追踪整个宇宙演化的总帧数 - 初始为0
         *      这是宇宙"年龄"的度量
         *      (记录自启动以来总共渲染了多少帧)
         */
        let frameCounter = 0;
        
        /* 
         * 5. FPS更新函数 - 宇宙引擎的"心跳监测器"
         *    
         *    这个函数像一个不知疲倦的量子观测仪，持续监测整个系统的运行状态，
         *    并根据这些观测数据动态调整系统参数。
         *    如果宇宙运行太慢？它会降低质量让一切更流畅。
         *    如果一切太顺畅？它会提升质量，让体验更加震撼！
         */
        function updateFPS() {
            /* 5.1. 获取当前时间戳
             *      精确捕获此刻的时间点 - 毫秒级精度
             *      这是新一轮测量的起点
             *      (使用高精度的performance API获取时间)
             */
            const now = performance.now();
            
            /* 5.2. 帧计数递增
             *      本次渲染帧计入总数 - 每次调用加1
             *      这是流畅度计算的基础数据点
             *      (简单但关键的计数操作)
             */
            frameCount++;
            
            /* 5.3. 帧率计算逻辑块
             *      当经过足够时间(1秒)时计算FPS
             *      这是核心的性能指标计算环节
             */
            if (now >= lastTime + 1000) {
                /* 5.3.1. 帧率计算公式
                 *        用帧数除以经过的时间得到FPS - 精确计算并取整
                 *        这是将原始数据转换为有意义指标的过程
                 *        (计算公式: FPS = 帧数 × 1000 ÷ 经过的毫秒数)
                 */
                fps = Math.round((frameCount * 1000) / (now - lastTime));
                
                /* 5.3.2. 重置帧计数器
                 *        为下一秒的计数做准备 - 归零操作
                 *        这是新一轮测量的初始化
                 *        (每秒重置一次，开始新的累计)
                 */
                frameCount = 0;
                
                /* 5.3.3. 更新时间基准点
                 *        将当前时间设为新的基准点 - 更新lastTime
                 *        这是滑动时间窗口的移动
                 *        (移动测量区间，确保始终测量最近的1秒)
                 */
                lastTime = now;
                
                /* 5.3.4. 更新UI显示
                 *        将计算得到的FPS值显示在界面上
                 *        这是让用户直观了解性能状况的反馈
                 *        (将技术数据转化为可见的用户反馈)
                 */
                document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
                
                /* 5.3.5. 自适应质量控制逻辑块
                 *        只在启用自适应质量功能时执行
                 *        这是系统"自我调节"的核心机制
                 */
                if (OPTIMIZATION.ADAPTIVE_QUALITY) {
                    /* 5.3.5.1. 记录性能历史
                     *          将新计算的FPS加入历史记录 - 推入数组
                     *          这是构建性能趋势数据的过程
                     *          (新数据推入数组尾部)
                     */
                    adaptiveQuality.fpsHistory.push(fps);
                    
                    /* 5.3.5.2. 限制历史记录长度
                     *          保持历史记录在合理长度 - 最多5条
                     *          这是维持数据新鲜度的机制
                     *          (超出长度限制时，移除最旧的数据)
                     */
                    if (adaptiveQuality.fpsHistory.length > 5) {
                        adaptiveQuality.fpsHistory.shift();
                    }
                    
                    /* 5.3.5.3. 计算平均帧率
                     *          使用所有历史记录计算平均值 - 平滑波动
                     *          这是消除瞬时波动影响的关键步骤
                     *          (使用reduce函数优雅地计算数组平均值)
                     */
                    const avgFps = adaptiveQuality.fpsHistory.reduce((a, b) => a + b, 0) / adaptiveQuality.fpsHistory.length;
                    
                    /* 5.3.5.4. 动态质量调整决策块
                     *          根据平均帧率调整质量系数
                     *          这是系统自适应的决策核心
                     */
                    if (avgFps < 30 && adaptiveQuality.currentQualityMultiplier > 0.5) {
                        /* 5.3.5.4.1. 性能不足时降低质量
                         *            当FPS低于阈值时降低质量系数 - 每次降低0.1
                         *            这是"减轻负担"的应急措施
                         *            (但确保不会低于0.5的最低质量底线)
                         */
                        adaptiveQuality.currentQualityMultiplier = Math.max(0.5, adaptiveQuality.currentQualityMultiplier - 0.1);
                    } else if (avgFps > 50 && adaptiveQuality.currentQualityMultiplier < 1.0) {
                        /* 5.3.5.4.2. 性能富余时提升质量
                         *            当FPS高于阈值时提升质量系数 - 每次提升0.05
                         *            这是"物尽其用"的优化措施
                         *            (但确保不会超过1.0的最高质量上限)
                         */
                        adaptiveQuality.currentQualityMultiplier = Math.min(1.0, adaptiveQuality.currentQualityMultiplier + 0.05);
                    }
                }
            }
            
            /* 5.4. 递归调用确保持续监测
             *      使用requestAnimationFrame安排下一次调用
             *      这是建立监测循环的关键
             *      (确保函数会在下一帧继续执行，形成持续监测)
             */
            requestAnimationFrame(updateFPS);
        }
        
        /* 5.5. 启动性能监控
         *      首次调用updateFPS函数，启动整个监控循环
         *      这是点燃引擎的火花
         *      (一切始于这一行，性能监控系统正式运转！)
         */
        updateFPS();

        /* 
         * 6. RGB转HSL色彩空间转换函数 - 宇宙色彩解析器
         *    
         *    这个函数就像一个跨维度的色彩转换装置！
         *    能够在不同的色彩坐标系统之间自如穿梭，将RGB三维色彩映射转换为
         *    HSL(色相、饱和度、亮度)三维表示。
         *    这简直就像在不同的色彩宇宙之间建立了一条量子通道！
         */
        function rgbToHsl(r, g, b) {
            /* 6.1. RGB值归一化处理
             *      将0-255范围的RGB值转换到0-1范围 - 除以255
             *      这是准备计算的第一步标准化
             *      (使所有颜色分量都在同一个0-1的标准范围内)
             */
            r /= 255;
            g /= 255;
            b /= 255;

            /* 6.2. 计算极值和中间值
             *      找出RGB中的最大值和最小值 - 用于后续计算
             *      这是HSL转换的基础参数
             *      (这些值决定了颜色的明暗度和色彩饱和度)
             */
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            
            /* 6.3. 初始化HSL变量
             *      预先计算亮度L - 最大值和最小值的平均值
             *      这是HSL中的L(亮度)分量
             *      (亮度简单地由RGB极值的算术平均值决定)
             */
            let h, s, l = (max + min) / 2;

            /* 6.4. 灰度颜色特殊处理
             *      检测是否是灰度颜色(无彩色) - 通过比较极值
             *      这是色相和饱和度的边界情况处理
             */
            if (max === min) {
                /* 6.4.1. 无彩色情况
                 *        当最大值等于最小值时，颜色是灰度
                 *        这种情况下没有色相和饱和度
                 *        (灰度只有亮度，没有色相和饱和度)
                 */
                h = s = 0; // achromatic
            } else {
                /* 6.5. 彩色情况处理
                 *      计算饱和度和色相 - 这是有彩色的普通情况
                 */
                
                /* 6.5.1. 计算色彩范围
                 *        最大值与最小值的差异 - 色彩范围d
                 *        这是色彩饱和度的基础
                 *        (范围越大，颜色越鲜艳饱和)
                 */
                const d = max - min;
                
                /* 6.5.2. 计算饱和度S
                 *        基于亮度和色彩范围计算饱和度
                 *        使用不同公式处理亮/暗区域
                 *        (亮度不同区域的饱和度计算方式不同)
                 */
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                /* 6.5.3. 计算色相H
                 *        根据哪个原色是最大值确定色相计算方式
                 *        这是确定基色的过程
                 *        (通过switch语句优雅地处理三种情况)
                 */
                switch (max) {
                    /* 6.5.3.1. 红色为主色调
                     *          当R是最大分量时的色相公式
                     *          这决定了以红色为基础的色相角度
                     *          (包含绿蓝偏移和循环处理)
                     */
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    
                    /* 6.5.3.2. 绿色为主色调
                     *          当G是最大分量时的色相公式
                     *          这决定了以绿色为基础的色相角度
                     *          (蓝红偏移，加上固定偏移2)
                     */
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    
                    /* 6.5.3.3. 蓝色为主色调
                     *          当B是最大分量时的色相公式
                     *          这决定了以蓝色为基础的色相角度
                     *          (红绿偏移，加上固定偏移4)
                     */
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                
                /* 6.5.4. 归一化色相值
                 *        将色相值除以6，归一到0-1范围
                 *        这是标准化输出的一步
                 *        (因为前面的色相计算结果范围是0-6)
                 */
                h /= 6;
            }
            
            /* 6.6. 返回HSL结果
             *      将H值转换为角度制(0-360度)，S和L保持0-1
             *      这是最终输出格式化
             *      (h的范围转为更常用的0-360度表示，s、l保持0-1小数)
             */
            return [h * 360, s, l]; // h in [0, 360], s, l in [0, 1]
        }

// 1. 宇宙能量漩涡视觉效果 - 终极彩色宇宙特效
// 1.1 此函数创建一个模拟超大质量天体周围时空扭曲的宇宙级视觉效果
// 1.1.1 灵感来源于爱因斯坦的广义相对论中对引力场的描述
// 1.1.2 融合了黑洞周围的事件视界、吸积盘、引力透镜等宇宙现象的视觉表现
// 1.1.3 通过多层次的渐变、能量波动和时空扭曲创造出震撼的视觉体验
function createCosmicVortexEffect(ctx, x, y, size, progress) {
    // 2. 状态保存
    // 2.1 创建绘图状态沙箱
    // 2.1.1 保存当前的绘图上下文状态，确保函数结束时能恢复原状
    // 2.1.2 这是处理复杂宇宙特效时的必要操作，避免污染外部渲染环境
    // 2.1.3 就像宇宙中的不同"泡沫宇宙"相互隔离一样，这里隔离了渲染状态
    ctx.save();
    
    // 3. 事件视界渲染 - 黑洞核心边界
    // 3.1 事件视界渐变创建
    // 3.1.1 创建模拟黑洞事件视界的径向渐变
    // 3.1.2 从内径(size*0.5)到外径(size*1.2)分布渐变色
    // 3.1.3 径向渐变完美模拟了向心引力场的强度分布
    // 3.1.4 这种视觉效果展现了光线无法逃脱的神秘边界，宛如宇宙中最深邃的禁区
    const eventHorizonGradient = ctx.createRadialGradient(
        x, y, size * 0.5,
        x, y, size * 1.2
    );
    
    // 3.2 事件视界渐变色阶定义
    // 3.2.1 内部核心区域 - 深蓝色半透明
    // 3.2.1.1 RGB(20,20,60)创造出深邃的宇宙色调
    // 3.2.1.2 0.3的透明度使其能够与背景融合，产生神秘感
    // 3.2.1.3 这种颜色模拟了高能粒子在强磁场下的切伦科夫辐射现象(呈蓝色辉光)
    eventHorizonGradient.addColorStop(0, 'rgba(20, 20, 60, 0.3)');
    
    // 3.2.2 中间过渡区域(40%) - 微亮深蓝
    // 3.2.2.1 RGB(30,30,80)略微提亮但保持深蓝调性
    // 3.2.2.2 透明度降至0.25，形成渐变过渡
    // 3.2.2.3 这一层次模拟了事件视界附近时空的不稳定状态
    eventHorizonGradient.addColorStop(0.4, 'rgba(30, 30, 80, 0.25)');
    
    // 3.2.3 外部过渡区域(70%) - 更明亮的蓝紫色
    // 3.2.3.1 RGB(40,40,100)色调提亮，增加蓝紫色饱和度
    // 3.2.3.2 透明度进一步降至0.2，增强虚幻感
    // 3.2.3.3 模拟了事件视界外围的引力场扭曲效应，如同星光经过黑洞附近被弯曲
    eventHorizonGradient.addColorStop(0.7, 'rgba(40, 40, 100, 0.2)');
    
    // 3.2.4 边缘区域 - 完全透明过渡
    // 3.2.4.1 保持深蓝基调(15,15,45)但完全透明
    // 3.2.4.2 创造出平滑融入背景的自然边缘
    // 3.2.4.3 这种处理使事件视界看起来如同悬浮在时空中的神秘存在
    eventHorizonGradient.addColorStop(1, 'rgba(15, 15, 45, 0)');
    
    // 3.3 绘制事件视界主体
    // 3.3.1 开始新的路径绘制
    // 3.3.1.1 清除之前的路径信息，准备绘制圆形事件视界
    // 3.3.1.2 这是Canvas标准操作，确保图形边界清晰
    // 3.3.1.3 就像宇宙间的界限一样，需要精确定义
    ctx.beginPath();
    
    // 3.3.2 应用渐变填充样式
    // 3.3.2.1 将前面定义的复杂渐变应用为填充样式
    // 3.3.2.2 这个渐变包含了多个精心设计的色阶
    // 3.3.2.3 呈现出事件视界的深邃而神秘的视觉效果
    ctx.fillStyle = eventHorizonGradient;
    
    // 3.3.3 绘制圆形事件视界
    // 3.3.3.1 以(x,y)为中心，size*1.2为半径绘制完整圆形
    // 3.3.3.2 圆形从0到2π弧度(360度)覆盖
    // 3.3.3.3 这个完美的圆形象征了引力场的均匀性和广义相对论中的时空弯曲
    ctx.arc(x, y, size * 1.2, 0, Math.PI * 2);
    
    // 3.3.4 执行填充操作
    // 3.3.4.1 用渐变色填充路径定义的圆形区域
    // 3.3.4.2 实际渲染出事件视界的视觉表现
    // 3.3.4.3 这一步让理论中的事件视界概念变为可见的艺术表达
    ctx.fill();
    
    // 4. 能量边缘渲染 - 强化视觉震撼
    // 4.1 能量边缘渐变创建
    // 4.1.1 创建第二层径向渐变，增强视觉层次感
    // 4.1.2 复用相同的内外半径设置(0.5-1.2)，但使用更鲜艳的色彩
    // 4.1.3 这一层渲染模拟了黑洞周围高能粒子的激烈活动
    // 4.1.4 天文学上，这类似于超大质量黑洞周围的高能离子团云
    const energyEdgeGradient = ctx.createRadialGradient(
        x, y, size * 0.5,
        x, y, size * 1.2
    );
    
    // 4.2 能量边缘渐变色阶定义
    // 4.2.1 内部核心 - 明亮蓝紫色
    // 4.2.1.1 RGB(90,100,200)创造出明亮的电离气体色调
    // 4.2.1.2 0.3透明度使其叠加在事件视界之上形成复合效果
    // 4.2.1.3 这种蓝紫色模拟了超高温等离子体辐射的视觉效果
    energyEdgeGradient.addColorStop(0, 'rgba(90, 100, 200, 0.3)');
    
    // 4.2.2 中间区域(30%) - 紫色过渡
    // 4.2.2.1 RGB(120,80,220)偏向紫色，增加视觉梦幻感
    // 4.2.2.2 透明度降至0.25，与之前层次形成和谐融合
    // 4.2.2.3 这种颜色变化暗示了不同能量态的粒子分布
    energyEdgeGradient.addColorStop(0.3, 'rgba(120, 80, 220, 0.25)');
    
    // 4.2.3 外部区域(60%) - 紫红色调
    // 4.2.3.1 RGB(150,60,180)转向紫红色调，形成鲜明对比
    // 4.2.3.2 透明度为0.2，保持一致的渐变过渡
    // 4.2.3.3 这种色彩转变模拟了电磁波谱在强引力场中的红移现象
    energyEdgeGradient.addColorStop(0.6, 'rgba(150, 60, 180, 0.2)');
    
    // 4.2.4 边缘区域 - 蓝色淡出
    // 4.2.4.1 RGB(80,140,220)返回蓝色调，形成循环感
    // 4.2.4.2 完全透明，确保边缘自然融合
    // 4.2.4.3 这种循环往复的色彩变化暗示了宇宙中能量的守恒与转换
    energyEdgeGradient.addColorStop(1, 'rgba(80, 140, 220, 0)');
    
    // 4.3 绘制能量边缘主体
    // 4.3.1 开始新路径
    // 4.3.1.1 清除之前的路径数据，准备绘制能量边缘
    // 4.3.1.2 每个视觉层次需要独立的路径对象
    // 4.3.1.3 就像在多维宇宙理论中，每个维度需要独立处理
    ctx.beginPath();
    
    // 4.3.2 应用能量边缘渐变
    // 4.3.2.1 将前面定义的能量边缘渐变应用为填充样式
    // 4.3.2.2 这个鲜艳的渐变将叠加在事件视界之上
    // 4.3.2.3 强化了视觉的层次感和能量流动的表现力
    ctx.fillStyle = energyEdgeGradient;
    
    // 4.3.3 绘制与事件视界相同大小的圆形
    // 4.3.3.1 使用相同的中心点和半径(size*1.2)
    // 4.3.3.2 完整的圆周覆盖(0-2π)
    // 4.3.3.3 叠加效果会产生更加复杂和迷人的视觉层次
    ctx.arc(x, y, size * 1.2, 0, Math.PI * 2);
    
    // 4.3.4 执行填充操作
    // 4.3.4.1 用能量边缘渐变填充定义的圆形
    // 4.3.4.2 由于画布的组合模式，这将与之前的事件视界渲染叠加
    // 4.3.4.3 最终效果是一个多层次、丰富多彩的能量漩涡核心
    ctx.fill();
    
    // 时空扭曲效应 - 背景星空扭曲
    if (progress > 0.4) {
        // 1. 扭曲进度计算
        // 1.1 将总体进度映射到时空扭曲特效专用进度上
        // 1.1.1 只有当总体进度超过0.4时才开始显示时空扭曲效果
        // 1.1.2 通过Math.min确保映射后的进度值不超过1.0，形成0-1的标准化进度值
        // 1.1.3 除以0.6是为了将0.4-1.0的范围重新映射为0-1的范围，实现平滑过渡
        const spaceWarpProgress = Math.min(1, (progress - 0.4) / 0.6);
        
        // 2. 准备渲染环境
        // 2.1 保存当前绘图状态
        // 2.1.1 使用save()和后面的restore()形成沙盒环境，防止后续操作影响其他渲染部分
        // 2.1.2 这是渲染复杂宇宙效果时的必备操作，确保不同空间层级之间不会相互干扰
        ctx.save();
        
        // 3. 扭曲参数设置
        // 3.1 扭曲射线数量定义
        // 3.1.1 定义8条空间扭曲射线，形成八方辐射的扭曲场
        // 3.1.2 这个数值是经过反复测试确定的，既能呈现复杂的扭曲效果，又不会造成性能问题
        // 3.1.3 在真实的广义相对论中，引力场的扭曲也是全方位的，这里用8条射线进行模拟
        const warpCount = 8;
        
        // 4. 空间扭曲射线循环渲染
        // 4.1 循环创建多个扭曲射线
        // 4.1.1 通过循环创建warpCount个扭曲效果，形成环绕中心点的空间扭曲场
        // 4.1.2 每个扭曲射线代表空间织物在强引力作用下的一个方向上的拉伸变形
        // 4.1.3 整体形成类似黑洞周围时空弯曲的视觉效果，模拟爱因斯坦广义相对论描述的引力作用
        for (let i = 0; i < warpCount; i++) {
            // 4.2 当前射线角度计算
            // 4.2.1 均匀分布各个射线的角度，确保360度全覆盖
            // 4.2.2 角度单位为弧度制，2π代表一个完整圆周
            // 4.2.3 i/warpCount 确保角度均匀分布在[0, 2π)区间内
            const angle = (i / warpCount) * Math.PI * 2;
            
            // 4.3 扭曲距离计算
            // 4.3.1 基于基础尺寸和扭曲进度计算最终扭曲射线长度
            // 4.3.2 随着扭曲进度增加，扭曲效果向外扩展，最大可达到基础尺寸的6倍
            // 4.3.3 这种渐进式扩展模拟了引力场向外传播的物理过程
            const warpDistance = size * (1 + spaceWarpProgress * 5);
            
            // 4.4 扭曲宽度计算
            // 4.4.1 设定扭曲射线的宽度，随着进度增加而增加
            // 4.4.2 基础宽度为size的0.2倍，最大可增加到size的0.8倍
            // 4.4.3 宽度增加模拟了时空扭曲强度的增大
            const warpWidth = size * 0.2 + spaceWarpProgress * size * 0.6;
            
            // 4.5 透明度计算
            // 4.5.1 随着扭曲进度增加，透明度适当降低，防止视觉过于混乱
            // 4.5.2 初始透明度为0.10，随进度最低可降至0.05
            // 4.5.3 这种微妙的透明度变化使得扭曲效果更加空灵、神秘
            const warpAlpha = 0.10 * (1 - spaceWarpProgress * 0.5);
            
            // 5. 扭曲渐变色创建
            // 5.1 创建线性渐变
            // 5.1.1 从中心点(x,y)向外辐射到目标点形成渐变
            // 5.1.2 目标点是基于当前角度和扭曲距离计算的端点
            // 5.1.3 这种从中心到边缘的渐变模拟了引力场强度随距离衰减的物理规律
            const warpGradient = ctx.createLinearGradient(
                x, y,
                x + Math.cos(angle) * warpDistance,
                y + Math.sin(angle) * warpDistance
            );
            
            // 5.2 基于角度的颜色计算
            // 5.2.1 将角度与总进度结合，创造动态变化的颜色角度
            // 5.2.2 progress*3使颜色随时间快速变化，增强视觉动感
            // 5.2.3 这种动态变化模拟了时空扭曲中能量流动和相变现象
            const colorAngle = angle + progress * 3;
            
            // 5.3 颜色丰富度设置
            // 5.3.1 使用优化参数中的色彩丰富度并增强50%
            // 5.3.2 这个参数控制色彩的饱和度和变化幅度
            // 5.3.3 高丰富度设置使扭曲效果呈现出更加梦幻、超现实的视觉体验
            const richness = OPTIMIZATION.COLOR_RICHNESS * 1.5; // 进一步增强丰富度
            
            // 5.4 复杂RGB颜色计算
            // 5.4.1 红色分量计算 - 基于多重正弦叠加的复杂频率
            // 5.4.1.1 基础值60保证最低亮度
            // 5.4.1.2 第一个正弦函数提供主要颜色变化，波幅为70*richness
            // 5.4.1.3 第二个正弦使用2.1倍频率和0.5相位差，增加50*richness*0.5的次要波动
            // 5.4.1.4 这种多频率叠加模拟了量子场中的波函数叠加效应
            const r = Math.floor(60 + Math.sin(colorAngle) * 70 * richness + Math.sin(colorAngle * 2.1 + 0.5) * 50 * richness * 0.5);
            
            // 5.4.2 绿色分量计算 - 与红色频率错开，形成色彩对比
            // 5.4.2.1 基础值40较低，使蓝紫色调更加突出
            // 5.4.2.2 主正弦添加2π/3相位差，使RGB颜色均匀分布
            // 5.4.2.3 次级正弦使用1.7倍频率和1.2相位差，叠加更多细节变化
            // 5.4.2.4 中等波幅80*richness使绿色在整体色调中处于平衡位置
            const g = Math.floor(40 + Math.sin(colorAngle + Math.PI/3) * 80 * richness + Math.sin(colorAngle * 1.7 + 1.2) * 60 * richness * 0.5);
            
            // 5.4.3 蓝色分量计算 - 最高基础亮度，强化宇宙感
            // 5.4.3.1 基础值100确保整体色调偏向太空蓝
            // 5.4.3.2 主正弦相位差为4π/3，与红绿形成120°间隔
            // 5.4.3.3 次级正弦使用2.5倍频率和2.1相位差，波幅为70*richness*0.5
            // 5.4.3.4 较高的蓝色值创造出深邃宇宙的神秘感，像星云中的离子化气体发出的蓝光
            const b = Math.floor(100 + Math.sin(colorAngle + Math.PI*2/3) * 120 * richness);
            
            // 5.5 渐变色停止点设置
            // 5.5.1 起点设置为深空色并完全透明
            // 5.5.1.1 使用暗蓝色(15,15,45)作为宇宙背景色
            // 5.5.1.2 透明度为0，确保与背景完美融合
            // 5.5.1.3 这种设计使扭曲效果看起来自然地从虚空中浮现
            warpGradient.addColorStop(0, `rgba(15, 15, 45, 0)`);
            
            // 5.5.2 30%位置设置为强化红色的中间色
            // 5.5.2.1 保留完整的红色值，但将绿色减半
            // 5.5.2.2 使用计算得到的透明度值
            // 5.5.2.3 这一停止点创造出类似红移效应的视觉，暗示时空扭曲产生的光谱位移
            warpGradient.addColorStop(0.3, `rgba(${r}, ${g/2}, ${b}, ${warpAlpha})`);
            
            // 5.5.3 60%位置设置为强化绿色的中间色
            // 5.5.3.1 红色减半，保留完整的绿色值
            // 5.5.3.2 使用相同的透明度保持视觉连贯性
            // 5.5.3.3 红绿色彩交替变化模拟了引力场中的能量转换过程
            warpGradient.addColorStop(0.6, `rgba(${r/2}, ${g}, ${b}, ${warpAlpha})`);
            
            // 5.5.4 终点设置为完全透明的深空色
            // 5.5.4.1 再次使用深空色调，但透明度为0
            // 5.5.4.2 确保扭曲效果边缘完美融入背景
            // 5.5.4.3 这种设计使射线看起来如同逐渐消散在宇宙虚空中
            warpGradient.addColorStop(1, `rgba(15, 15, 45, 0)`);
            
            // 6. 绘制射线路径
            // 6.1 开始新路径
            // 6.1.1 清除之前的路径数据，准备绘制新的扭曲射线
            // 6.1.2 每条射线需要独立的路径对象
            // 6.1.3 这是Canvas API的标准绘图流程，确保不同射线之间互不干扰
            ctx.beginPath();
            
            // 6.2 设置路径起点
            // 6.2.1 从时空扭曲的中心点开始绘制
            // 6.2.2 所有射线共享相同的起始点，形成辐射状结构
            // 6.2.3 这种中心辐射设计模拟了引力源对周围时空的影响
            ctx.moveTo(x, y);
            
            // 7. 螺旋曲线绘制
            // 7.1 螺旋精度设置
            // 7.1.1 定义螺旋曲线的分段数量为30
            // 7.1.2 这个值决定了曲线的平滑度
            // 7.1.3 经测试，30段能在性能和视觉效果间取得良好平衡
            const spiralSteps = 30;
            
            // 7.2 分段绘制螺旋
            // 7.2.1 逐段计算并连接螺旋上的点
            // 7.2.2 循环覆盖从0到spiralSteps的所有分段
            // 7.2.3 这种逐段绘制法允许创建复杂的非线性扭曲曲线
            for (let j = 0; j <= spiralSteps; j++) {
                // 7.2.4 计算当前分段的归一化进度值
                // 7.2.4.1 将j除以总步数得到0-1范围的进度值
                // 7.2.4.2 这个值将用于计算当前点在螺旋上的具体位置
                // 7.2.4.3 线性的进度值将被用于创建非线性的螺旋曲线
                const spiralProgress = j / spiralSteps;
                
                // 7.2.5 螺旋角度计算
                // 7.2.5.1 基础角度加上随进度增加的额外旋转角
                // 7.2.5.2 螺旋旋转幅度与时空扭曲进度成正比
                // 7.2.5.3 最多可旋转3π弧度(540°)，创造出引人入胜的漩涡状扭曲
                // 7.2.5.4 这种渐进式旋转模拟了接近黑洞时空间被卷曲的视觉效果
                const spiralAngle = angle + spiralProgress * Math.PI * spaceWarpProgress * 3;
                
                // 7.2.6 当前点距离计算
                // 7.2.6.1 距离从0线性增加到最大扭曲距离
                // 7.2.6.2 结合角度变化，形成向外扩展的螺旋结构
                // 7.2.6.3 这种设计模拟了时空在强引力场下的连续变形
                const spiralDistance = warpDistance * spiralProgress;
                
                // 7.2.7 计算当前点的具体坐标
                // 7.2.7.1 基于中心点、当前角度和距离计算x坐标
                // 7.2.7.2 使用余弦函数计算x轴偏移量
                // 7.2.7.3 这是极坐标到直角坐标转换的标准三角函数应用
                const sx = x + Math.cos(spiralAngle) * spiralDistance;
                
                // 7.2.8 计算当前点的y坐标
                // 7.2.8.1 基于中心点、当前角度和距离计算y坐标
                // 7.2.8.2 使用正弦函数计算y轴偏移量
                // 7.2.8.3 结合x坐标，完成从极坐标到画布直角坐标系的完整映射
                const sy = y + Math.sin(spiralAngle) * spiralDistance;
                
                // 7.2.9 路径绘制逻辑分支
                // 7.2.9.1 对于第一个点(j=0)，设置为路径起点
                // 7.2.9.2 其余点则连接到路径上，形成连续的曲线
                // 7.2.9.3 这种条件判断确保路径的正确构建，避免断裂或多余的线段
                if (j === 0) {
                    ctx.moveTo(sx, sy);
                } else {
                    ctx.lineTo(sx, sy);
                }
            }
            
            // 8. 应用渐变和绘制
            // 8.1 设置描边样式为之前创建的渐变
            // 8.1.1 将复杂计算得到的渐变对象应用为描边样式
            // 8.1.2 这使得扭曲射线呈现出梦幻的彩虹色效果
            // 8.1.3 渐变的应用使射线看起来如同能量流动的视觉表现
            ctx.strokeStyle = warpGradient;
            
            // 8.2 设置线条宽度
            // 8.2.1 应用之前计算的扭曲宽度
            // 8.2.2 较宽的线条创造出强烈的视觉冲击力
            // 8.2.3 线宽随进度变化，使扭曲效果更加动态和引人注目
            ctx.lineWidth = warpWidth;
            
            // 8.3 执行描边操作
            // 8.3.1 实际渲染路径，在画布上呈现出扭曲射线
            // 8.3.2 Canvas API的描边操作将路径转化为可见的图形元素
            // 8.3.3 至此，单个扭曲射线绘制完成，循环继续绘制下一条
            ctx.stroke();
        }
        
        // 9. 恢复绘图状态
        // 9.1 恢复之前保存的绘图上下文
        // 9.1.1 撤销之前设置的所有临时绘图属性
        // 9.1.2 确保后续的渲染操作不受当前效果的影响
        // 9.1.3 这是Canvas绘图操作的最佳实践，维护干净的绘图环境
        ctx.restore();
    }
    






    // 5. 吸积盘系统渲染 - 黑洞周围物质旋转盘
    // 5.1 吸积盘进度与阶段控制
    // 5.1.1 只有当总进度超过0.3时才显示吸积盘效果
    // 5.1.2 吸积盘是黑洞周围最明显的可观测天文现象，比时空扭曲更容易察觉
    // 5.1.3 这种分阶段渲染创造了逐步形成的动态视觉效果，模拟了吸积盘的形成过程
    if (progress > 0.3) {
        // 5.2 吸积盘专用进度计算
        // 5.2.1 将总进度0.3-1.0映射为吸积盘专用进度0-1
        // 5.2.2 使用Math.min确保进度值不会超出范围
        // 5.2.3 这种平滑过渡确保黑洞吸积盘的形成看起来自然渐进
        const diskProgress = Math.min(1, (progress - 0.3) / 0.7);
        
        // 5.3 吸积盘尺寸计算
        // 5.3.1 基于基础尺寸和吸积盘进度计算盘面大小
        // 5.3.2 随着进度增加，吸积盘可扩展至基础尺寸的5倍
        // 5.3.3 这种动态扩展模拟了黑洞吸积过程中物质场的形成和扩张
        const diskSize = size * (1 + diskProgress * 4);
        
        // 5.4 主吸积盘渐变创建
        // 5.4.1 创建模拟吸积盘整体形态的径向渐变
        // 5.4.1.1 从内径(size*0.7)到外径(diskSize)渐变分布
        // 5.4.1.2 内径大于事件视界，符合天文物理学中吸积盘形成的位置理论
        // 5.4.1.3 这种设计创造了逼真的环状结构，类似哈勃望远镜捕捉的活动星系核心
        const diskGradient = ctx.createRadialGradient(
            x, y, size * 0.7,
            x, y, diskSize
        );
        
        // 5.4.2 吸积盘渐变色阶定义
        // 5.4.2.1 内部边缘 - 深空融合过渡
        // 5.4.2.1.1 使用暗蓝色调(15,15,45)并完全透明
        // 5.4.2.1.2 内部接近黑洞处的物质被强引力撕裂，形成相对稀薄区域
        // 5.4.2.1.3 这种设计确保吸积盘与内部事件视界自然过渡，不产生硬边界
        diskGradient.addColorStop(0, 'rgba(15, 15, 45, 0)');
        
        // 5.4.2.2 内环区域(30%) - 深蓝色调
        // 5.4.2.2.1 RGB(50,90,150)创造出更亮的深蓝色调
        // 5.4.2.2.2 0.22的透明度使其保持一定的通透感
        // 5.4.2.2.3 这一区域模拟了较内侧的高温物质，主要为电离气体
        diskGradient.addColorStop(0.3, 'rgba(50, 90, 150, 0.22)');
        
        // 5.4.2.3 中环区域(50%) - 转向紫色调
        // 5.4.2.3.1 RGB(90,50,150)偏向紫色，增加色彩层次
        // 5.4.2.3.2 透明度微增至0.24，提高视觉显著性
        // 5.4.2.3.3 色调变化模拟了物质在不同温度和密度下的光谱特性变化
        diskGradient.addColorStop(0.5, 'rgba(90, 50, 150, 0.24)');
        
        // 5.4.2.4 外环区域(70%) - 转向红紫色
        // 5.4.2.4.1 RGB(150,60,100)向红紫色过渡，形成绚丽对比
        // 5.4.2.4.2 透明度降至0.20，使外环看起来更加朦胧
        // 5.4.2.4.3 这种色彩转变暗示了外侧物质的温度逐渐降低，符合天体物理学规律
        diskGradient.addColorStop(0.7, 'rgba(150, 60, 100, 0.20)');
        
        // 5.4.2.5 外围边缘(90%) - 转向深紫色
        // 5.4.2.5.1 RGB(80,40,130)回归深紫色调，形成循环感
        // 5.4.2.5.2 透明度进一步降低至0.15，边缘更柔和
        // 5.4.2.5.3 这种设计模拟了吸积盘物质在外围稀疏分布的状态
        diskGradient.addColorStop(0.9, 'rgba(80, 40, 130, 0.15)');
        
        // 5.4.2.6 最外缘 - 完全透明过渡
        // 5.4.2.6.1 使用与内部相同的暗蓝色调，形成首尾呼应
        // 5.4.2.6.2 透明度为0，确保边缘完美融入太空背景
        // 5.4.2.6.3 这种处理使吸积盘边界看起来自然消散，而非生硬截断
        diskGradient.addColorStop(1, 'rgba(15, 15, 45, 0)');
        
        // 5.5 吸积盘混合模式设置
        // 5.5.1 保存当前绘图状态
        // 5.5.1.1 创建独立的渲染环境，避免影响其他元素
        // 5.5.1.2 吸积盘是一个复杂的多层结构，需要独立的渲染环境
        // 5.5.1.3 就像宇宙中不同星系互不干扰一样，渲染层次也需要隔离
        ctx.save();
        
        // 5.5.2 设置光照混合模式
        // 5.5.2.1 使用'lighter'混合模式使颜色相加，增强光亮感
        // 5.5.2.2 这种模式完美模拟了发光体的叠加效应
        // 5.5.2.3 实际天文照片中，吸积盘的确呈现出这种光亮叠加的特性
        ctx.globalCompositeOperation = 'lighter';
        
        // 5.5.3 开始绘制吸积盘路径
        // 5.5.3.1 清除之前的路径数据，准备绘制整体吸积盘
        // 5.5.3.2 吸积盘需要在事件视界之上形成独立的图形层
        // 5.5.3.3 在宇宙中，吸积盘确实是独立于黑洞事件视界的物理结构
        ctx.beginPath();
        
        // 5.5.4 应用吸积盘渐变
        // 5.5.4.1 将前面定义的复杂渐变应用为填充样式
        // 5.5.4.2 这个渐变包含了多达6个精心设计的色阶
        // 5.5.4.3 丰富的色彩层次再现了实际天文照片中黑洞吸积盘的绚丽多彩
        ctx.fillStyle = diskGradient;
        
        // 5.5.5 绘制吸积盘主圆形
        // 5.5.5.1 以(x,y)为中心，diskSize为半径绘制完整圆形
        // 5.5.5.2 完整的圆周(0-2π)形成基础盘面结构
        // 5.5.5.3 实际上，这个圆形只是基础，后续的细节会丰富其结构
        ctx.arc(x, y, diskSize, 0, Math.PI * 2);
        
        // 5.5.6 执行填充操作
        // 5.5.6.1 用渐变色填充定义的圆形区域
        // 5.5.6.2 由于设置了lighter混合模式，会与下层渲染产生光照叠加
        // 5.5.6.3 这一步完成了吸积盘的基础渲染，后续添加更多细节
        ctx.fill();
        
        // 吸积盘细节 - 丰富的粒子流
        // 5.6 吸积盘粒子细节渲染
        // 5.6.1 粒子数量计算 - 自适应性能优化
        // 5.6.1.1 基础数量25，随进度增加最多再增加25个
        // 5.6.1.2 结合全局优化参数和自适应质量乘数动态调整
        // 5.6.1.3 这种设计确保在不同性能设备上都能获得最佳视觉效果
        // 5.6.1.4 模拟了吸积盘中的高密度物质团块分布，类似实际观测中的亮点结构
        const detailCount = 25 + Math.floor(diskProgress * 25) * OPTIMIZATION.QUALITY * adaptiveQuality.currentQualityMultiplier;
        
        // 5.6.2 循环创建多个粒子
        // 5.6.2.1 每个粒子代表吸积盘中的一个高密度物质团块
        // 5.6.2.2 粒子的随机分布创造出自然的不均匀结构
        // 5.6.2.3 这种设计模拟了真实吸积盘的非均质性，增强了视觉真实感
        for (let i = 0; i < detailCount; i++) {
            // 5.6.3 粒子角度计算
            // 5.6.3.1 均匀分布粒子的角度，加上旋转偏移
            // 5.6.3.2 progress*8提供快速旋转效果，模拟吸积盘的动态旋转
            // 5.6.3.3 这种旋转暗示了物质在黑洞周围的轨道运动，符合开普勒定律
            const angle = (i / detailCount) * Math.PI * 2 + progress * 8;
            
            // 5.6.4 粒子距离计算
            // 5.6.4.1 粒子分布在吸积盘的中间区域，而非边缘或中心
            // 5.6.4.2 随进度增加，粒子分布范围向外扩展
            // 5.6.4.3 这种分布模拟了物质在吸积盘中的主要聚集区域
            const distance = size * 0.8 + diskProgress * size * 3;
            
            // 5.6.5 计算粒子的具体位置
            // 5.6.5.1 基于中心点、当前角度和距离计算x坐标
            // 5.6.5.2 使用标准三角函数进行极坐标到直角坐标的转换
            // 5.6.5.3 这确保粒子均匀分布在吸积盘的圆环区域内
            const detailX = x + Math.cos(angle) * distance;
            
            // 5.6.6 计算粒子的y坐标
            // 5.6.6.1 与x坐标计算类似，使用正弦函数确定y方向偏移
            // 5.6.6.2 x和y坐标组合确定了粒子在二维平面上的精确位置
            // 5.6.6.3 这种均匀分布创造出视觉上的平衡感，但后续会增加随机变化
            const detailY = y + Math.sin(angle) * distance;
            
            // 5.6.7 粒子尺寸随机化
            // 5.6.7.1 基础尺寸为size的0.08倍，随机增加最多0.16倍
            // 5.6.7.2 随机变化使每个粒子大小不同，增加自然感
            // 5.6.7.3 这种变化模拟了吸积盘中物质团块大小的不均匀性
            const detailSize = size * (0.08 + Math.random() * 0.16);
            
            // 5.6.8 粒子透明度计算
            // 5.6.8.1 基础透明度在0.3-0.5之间随机变化
            // 5.6.8.2 随着进度增加，整体透明度略有降低
            // 5.6.8.3 这种变化使粒子看起来更加自然，不会过于突兀
            const detailAlpha = (0.3 + Math.random() * 0.2) * (1 - diskProgress * 0.3);
            
            // 5.6.9 粒子颜色计算 - 创造丰富变化
            // 5.6.9.1 颜色角度基于当前进度和粒子索引，确保多样性
            // 5.6.9.2 取模运算确保角度在0-2π范围内循环
            // 5.6.9.3 这种设计使每个粒子都有略微不同的颜色，增强视觉丰富度
            const colorAngle = (progress * 5 + i / detailCount * Math.PI * 2) % (Math.PI * 2);
            
            // 5.6.10 颜色丰富度获取
            // 5.6.10.1 使用全局优化参数中的色彩丰富度
            // 5.6.10.2 这个值控制颜色的饱和度和生动程度
            // 5.6.10.3 高丰富度设置使吸积盘粒子呈现更加绚丽的色彩
            const richness = OPTIMIZATION.COLOR_RICHNESS;
            
            // 5.6.11 RGB颜色分量计算
            // 5.6.11.1 红色分量基于正弦函数，波动范围70-170
            // 5.6.11.2 较高的基础亮度确保粒子明显可见
            // 5.6.11.3 使用正弦函数使颜色随角度平滑变化，类似光谱分布
            const r = Math.floor(70 + Math.sin(colorAngle) * 100 * richness);
            
            // 5.6.12 绿色分量，波动范围60-150
            // 5.6.12.1 与红色添加120°相位差，创造互补色
            // 5.6.12.2 波幅略小，使整体偏向紫红色调
            // 5.6.12.3 这种色彩设计接近真实的吸积盘高能辐射色彩
            const g = Math.floor(60 + Math.sin(colorAngle + Math.PI/3) * 90 * richness);
            
            // 5.6.13 蓝色分量，波动范围100-220
            // 5.6.13.1 与红色添加240°相位差，完成三原色循环
            // 5.6.13.2 蓝色基础值和波幅最大，强化深邃的宇宙感
            // 5.6.13.3 高蓝色值模拟了宇宙中高能粒子的切伦科夫辐射蓝光效应
            const b = Math.floor(100 + Math.sin(colorAngle + Math.PI*2/3) * 100 * richness + Math.sin(colorAngle * 2.5 + 2.1) * 70 * richness * 0.5);
            
            // 5.6.14 创建粒子径向渐变
            // 5.6.14.1 从粒子中心到边缘创建平滑渐变
            // 5.6.14.2 渐变半径与粒子大小相同，确保完整覆盖
            // 5.6.14.3 这种设计使粒子看起来是发光的能量团，而非硬边界的圆点
            const detailGradient = ctx.createRadialGradient(
                detailX, detailY, 0,
                detailX, detailY, detailSize
            );
            
            // 5.6.15 粒子渐变色阶定义
            // 5.6.15.1 中心点 - 最亮区域
            // 5.6.15.1.1 使用完整RGB值，但透明度降低至80%
            // 5.6.15.1.2 颜色亮度集中于中心，模拟能量核心
            // 5.6.15.1.3 这种设计创造了类似恒星的光亮中心效果
            detailGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${detailAlpha * 0.8})`);
            
            // 5.6.15.2 中间区域(70%) - 逐渐变暗
            // 5.6.15.2.1 将RGB值降至原来的60%，蓝色保留至80%
            // 5.6.15.2.2 透明度降低至50%，形成柔和过渡
            // 5.6.15.2.3 偏蓝的设计遵循了光能衰减的物理规律
            detailGradient.addColorStop(0.7, `rgba(${r*0.6}, ${g*0.6}, ${b*0.8}, ${detailAlpha * 0.5})`);
            
            // 5.6.15.3 边缘 - 完全透明
            // 5.6.15.3.1 将RGB值降至40%，保留某种程度的色相
            // 5.6.15.3.2 透明度为0，确保边缘完美融合
            // 5.6.15.3.3 这种处理避免了粒子边缘的锯齿效应
            detailGradient.addColorStop(1, `rgba(${r*0.4}, ${g*0.4}, ${b*0.6}, 0)`);
            
            // 5.6.16 绘制单个粒子
            // 5.6.16.1 开始新路径绘制
            // 5.6.16.1.1 清除之前的路径，准备绘制当前粒子
            // 5.6.16.1.2 每个粒子都是独立的图形元素
            // 5.6.16.1.3 这种隔离确保粒子之间互不干扰
            ctx.beginPath();
            
            // 5.6.16.2 应用粒子渐变填充
            // 5.6.16.2.1 将复杂计算的渐变设为填充样式
            // 5.6.16.2.2 这个渐变包含了三层精细的色阶过渡
            // 5.6.16.2.3 填充样式决定了粒子的最终外观
            ctx.fillStyle = detailGradient;
            
            // 5.6.16.3 绘制粒子圆形
            // 5.6.16.3.1 以计算的位置为中心，detailSize为半径绘制圆形
            // 5.6.16.3.2 完整的圆周(0-2π)形成粒子的视觉边界
            // 5.6.16.3.3 圆形是最自然的粒子形态，模拟了引力束缚下的物质形态
            ctx.arc(detailX, detailY, detailSize, 0, Math.PI * 2);
            
            // 5.6.16.4 执行填充操作
            // 5.6.16.4.1 用渐变色填充定义的圆形区域
            // 5.6.16.4.2 在lighter混合模式下，粒子会与背景和其他粒子叠加
            // 5.6.16.4.3 这完成了单个粒子的绘制，循环继续创建下一个
            ctx.fill();
        }
        
        // 吸积盘螺旋结构 - 模拟引力分层 - 更华丽的螺旋
        if (diskProgress > 0.3) {
            // 5.7 吸积盘螺旋结构渲染
            // 5.7.1 螺旋结构条件检查
            // 5.7.1.1 只有当吸积盘进度超过0.3时才显示螺旋结构
            // 5.7.1.2 这种分阶段显示创造了由简到繁的构建过程
            // 5.7.1.3 模拟了物质在引力场中逐渐形成稳定螺旋结构的过程
            const spiralCount = 5;
            
            // 5.7.2 螺旋臂数量定义
            // 5.7.2.1 定义5个主要螺旋臂，形成对称结构
            // 5.7.2.2 真实的活动星系核和吸积盘通常表现出多臂螺旋结构
            // 5.7.2.3 五臂设计在视觉上既丰富又不过度复杂
            const spiralWidth = size * 0.15;
            
            // 5.7.3 螺旋宽度设置
            // 5.7.3.1 设置螺旋臂宽度为基础尺寸的0.15倍
            // 5.7.3.2 这个宽度足以产生清晰可见的结构，又不会过度占据视觉空间
            // 5.7.3.3 在真实天文观测中，吸积盘螺旋臂确实有一定宽度而非细线
            for (let i = 0; i < spiralCount; i++) {
                // 5.7.4 循环创建多个螺旋臂
                // 5.7.4.1 通过循环生成spiralCount个均匀分布的螺旋臂
                // 5.7.4.2 每个螺旋臂在空间分布上相隔2π/spiralCount弧度
                // 5.7.4.3 这种均匀分布创造出稳定的几何结构，类似真实星系中的螺旋臂
                const baseAngle = (i / spiralCount) * Math.PI * 2;
                
                // 5.7.5 计算螺旋臂基础角度
                // 5.7.5.1 基础角度确保每个螺旋臂均匀分布在圆周上
                // 5.7.5.2 i/spiralCount确定当前螺旋臂的相对位置
                // 5.7.5.3 这种设计模拟了物质在旋转引力场中的对称分布
                const spiralTurns = 2 + diskProgress * 2;
                
                // 5.7.6 螺旋臂旋转圈数计算
                // 5.7.6.1 基础旋转2圈，随进度增加最多再增加2圈
                // 5.7.6.2 旋转圈数直接影响螺旋的密集程度和复杂度
                // 5.7.6.3 这种动态变化模拟了物质在黑洞周围轨道的逐渐成熟过程
                ctx.beginPath();
                
                // 5.7.7 开始绘制螺旋路径
                // 5.7.7.1 开始一个新的路径绘制，隔离不同螺旋臂的图形定义
                // 5.7.7.2 每个螺旋臂都是一个独立的连续路径
                // 5.7.7.3 这种隔离确保不同螺旋臂可以有各自的样式和特性
                for (let t = 0; t <= 1; t += 0.01) {
                    // 5.7.8 螺旋点阵构建
                    // 5.7.8.1 通过参数方程构建螺旋曲线上的点
                    // 5.7.8.2 步长0.01提供平滑的曲线效果，避免分段显著
                    // 5.7.8.3 t参数从0到1，覆盖从内到外的整个螺旋范围
                    const spiralAngle = baseAngle + t * Math.PI * 2 * spiralTurns;
                    
                    // 5.7.9 计算螺旋点的半径
                    // 5.7.9.1 半径从内部基础尺寸逐渐向外扩展
                    // 5.7.9.2 随t线性增加，最大可达基础半径的3倍
                    // 5.7.9.3 这种设计创造了视觉上扩张的螺旋，模拟了物质向外扩散的趋势
                    const spiralRadius = size * 0.8 + t * size * 3 * diskProgress;
                    
                    // 5.7.10 计算螺旋点的X坐标
                    // 5.7.10.1 基于极坐标系转换为直角坐标
                    // 5.7.10.2 余弦函数计算水平方向的投影
                    // 5.7.10.3 这种转换确保了螺旋在二维平面上的正确表达
                    const sx = x + Math.cos(spiralAngle) * spiralRadius;
                    
                    // 5.7.11 计算螺旋点的Y坐标
                    // 5.7.11.1 与X坐标类似，但使用正弦函数计算垂直方向投影
                    // 5.7.11.2 x和y坐标组合确定了螺旋线上的精确位置
                    // 5.7.11.3 这样计算出的点集形成了流畅的螺旋曲线
                    const sy = y + Math.sin(spiralAngle) * spiralRadius;
                    
                    // 5.7.13 绘制螺旋线段
                    // 5.7.13.1 第一个点需要移动画笔而非连线
                    // 5.7.13.2 后续点则通过连线形成连续螺旋
                    // 5.7.13.3 这种方法确保了螺旋线的连续性和平滑度
                    if (t === 0) {
                        ctx.moveTo(sx, sy);
                    } else {
                        ctx.lineTo(sx, sy);
                    }
                }
                
                // 为每个螺旋使用不同的颜色
                const spiralColorBase = i / spiralCount;
                const richness = OPTIMIZATION.COLOR_RICHNESS * 1.8; // 进一步增强丰富度
                // 增加更多频率和相位，使颜色变化更复杂
                const r = Math.floor(50 + 90 * Math.sin(spiralColorBase * Math.PI * 2) * richness + Math.sin(spiralColorBase * Math.PI * 4 + 0.8) * 60 * richness * 0.6);
                const g = Math.floor(50 + 90 * Math.sin(spiralColorBase * Math.PI * 2 + Math.PI/3) * richness + Math.sin(spiralColorBase * Math.PI * 3.5 + 1.5) * 70 * richness * 0.6);
                const b = Math.floor(100 + 100 * Math.sin(spiralColorBase * Math.PI * 2 + Math.PI*2/3) * richness + Math.sin(spiralColorBase * Math.PI * 4.2 + 2.3) * 80 * richness * 0.6);
                
                const spiralGradient = ctx.createLinearGradient(
                    x, y,
                    x + Math.cos(baseAngle) * diskSize,
                    y + Math.sin(baseAngle) * diskSize
                );
                
                spiralGradient.addColorStop(0, `rgba(40, 40, 80, 0)`);
                spiralGradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, 0.14)`);
                spiralGradient.addColorStop(0.6, `rgba(${r/2}, ${g*1.2}, ${b}, 0.11)`);
                spiralGradient.addColorStop(1, `rgba(30, 30, 70, 0)`);
                
                ctx.strokeStyle = spiralGradient;
                ctx.lineWidth = spiralWidth;
                ctx.stroke();
            }
        }
        ctx.restore();
        
        // 5.8 吸积盘内缘渲染 - 暗沉高温物质区
        // 5.8.1 内缘渐变创建
        // 5.8.1.1 创建从黑洞边缘(size*0.5)到内盘边缘(size*1.1)的径向渐变
        // 5.8.1.2 这是最接近事件视界的物质区域，温度极高但相对稀薄
        // 5.8.1.3 在实际天文观测中，这一区域常呈现与外部吸积盘不同的色彩特征
        const innerDiskGradient = ctx.createRadialGradient(
            x, y, size * 0.5,
            x, y, size * 1.1
        );
        
        // 5.8.2 内缘渐变色阶设置
        // 5.8.2.1 核心区域(0%) - 完全透明
        // 5.8.2.1.1 使用纯黑色但完全透明，确保中心区域干净
        // 5.8.2.1.2 这模拟了最内侧物质被吞噬后留下的相对空洞区
        // 5.8.2.1.3 完美过渡确保内缘与事件视界之间不产生明显的人工边界
        innerDiskGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        
        // 5.8.2.2 近内侧区域(30%) - 高温蓝色调
        // 5.8.2.2.1 使用蓝绿色调(30,100,150)代表极高温状态下的等离子体
        // 5.8.2.2.2 透明度为0.16，使内缘隐约可见但不喧宾夺主
        // 5.8.2.2.3 这种蓝色调暗示了接近1,000,000°K的高温粒子释放的强烈X射线辐射
        innerDiskGradient.addColorStop(0.3, 'rgba(30, 100, 150, 0.16)');
        
        // 5.8.2.3 中间过渡区域(60%) - 转向紫色调
        // 5.8.2.3.1 使用蓝紫色(80,30,150)表现温度相对降低但仍然极高的区域
        // 5.8.2.3.2 透明度略降至0.14，形成自然过渡
        // 5.8.2.3.3 这种颜色过渡模拟了物质由近万度逐渐降至数千度的温度变化
        innerDiskGradient.addColorStop(0.6, 'rgba(80, 30, 150, 0.14)');
        
        // 5.8.2.4 外缘过渡(100%) - 完全透明
        // 5.8.2.4.1 使用纯黑色并完全透明，确保与外部吸积盘平滑融合
        // 5.8.2.4.2 这种设计避免内缘与主吸积盘之间出现硬边界
        // 5.8.2.4.3 在天体物理学中，不同温度区之间确实存在连续过渡而非截然分界
        innerDiskGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        // 5.8.3 内缘渲染状态设置
        // 5.8.3.1 保存当前绘图状态
        // 5.8.3.1.1 创建隔离的绘图环境，避免影响其他元素渲染
        // 5.8.3.1.2 每个主要视觉组件都需要独立的渲染环境
        // 5.8.3.1.3 这种状态隔离是复杂视觉效果渲染的最佳实践
        ctx.save();
        
        // 5.8.3.2 设置光照叠加混合模式
        // 5.8.3.2.1 使用'lighter'混合模式，使内缘光芒与其他元素相加
        // 5.8.3.2.2 这种模式完美模拟高能粒子辐射的光学叠加效应
        // 5.8.3.2.3 实际的天体物理摄影中，多波段图像叠加也会产生类似效果
        ctx.globalCompositeOperation = 'lighter';
        
        // 5.8.3.3 开始绘制内缘路径
        // 5.8.3.3.1 清除之前的路径数据，准备绘制内缘圆形
        // 5.8.3.3.2 这确保了路径定义的纯净性，避免意外的图形残留
        // 5.8.3.3.3 干净的路径定义是准确渲染的前提条件
        ctx.beginPath();
        
        // 5.8.3.4 应用内缘渐变
        // 5.8.3.4.1 将前面定义的渐变设为当前填充样式
        // 5.8.3.4.2 这个渐变包含了从高温蓝色到紫色的精心设计的色阶过渡
        // 5.8.3.4.3 渐变填充使内缘呈现出逼真的连续能量密度变化
        ctx.fillStyle = innerDiskGradient;
        
        // 5.8.3.5 绘制内缘圆形
        // 5.8.3.5.1 以中心点为圆心，半径为size*1.1绘制完整圆形
        // 5.8.3.5.2 这个尺寸略大于事件视界，小于主吸积盘，形成过渡带
        // 5.8.3.5.3 圆形形状模拟了黑洞周围引力场的均匀性，符合物理规律
        ctx.arc(x, y, size * 1.1, 0, Math.PI * 2);
        
        // 5.8.3.6 执行填充操作
        // 5.8.3.6.1 使用设定的渐变填充绘制的圆形
        // 5.8.3.6.2 在lighter混合模式下，会产生光芒叠加的视觉效果
        // 5.8.3.6.3 这一步完成了内缘的实际渲染，展现出高温物质的微妙光芒
        ctx.fill();
        
        // 5.8.3.7 恢复绘图状态
        // 5.8.3.7.1 恢复保存的绘图状态，清除临时设置
        // 5.8.3.7.2 这确保了后续渲染不受当前组件设置的影响
        // 5.8.3.7.3 状态恢复是复杂渲染过程中保持整体一致性的关键步骤
        ctx.restore();
    }
    
    // 6. 引力透镜效应渲染 - 星光扭曲场景
    // 6.1 进度条件检查与计算
    // 6.1.1 只在总进度超过0.5时显示引力透镜效果
    // 6.1.2 这代表黑洞的引力场已经强大到能明显弯曲周围的光线
    // 6.1.3 爱因斯坦在他那革命性的广义相对论中精确预言了这种震撼的宇宙现象
    if (progress > 0.5) {
        // 6.2 引力透镜专用进度计算
        // 6.2.1 将总进度0.5-1.0映射为透镜专用进度0-1
        // 6.2.2 使用Math.min确保进度值不会超出有效范围
        // 6.2.3 这种专用进度映射确保了各个视觉效果之间的平滑过渡与协调
        const lensProgress = Math.min(1, (progress - 0.5) / 0.5);
        
        // 6.3 引力透镜尺寸计算
        // 6.3.1 基于基础尺寸和透镜进度计算最终视觉范围
        // 6.3.2 随着进度增加，透镜效果可扩展至基础尺寸的8倍
        // 6.3.3 这种远距离影响模拟了超大质量黑洞引力场的广泛作用范围
        const lensSize = size * (1 + lensProgress * 7);
        
        // 6.4 引力场渐变创建
        // 6.4.1 创建模拟引力场能量分布的径向渐变
        // 6.4.1.1 从内径(size*0.8)到外径(lensSize)渐变分布
        // 6.4.1.2 内径大于事件视界，小于最大吸积盘尺寸
        // 6.4.1.3 这种设计使引力场效果能与吸积盘和事件视界自然融合
        const lensGradient = ctx.createRadialGradient(
            x, y, size * 0.8,
            x, y, lensSize
        );
        
        // 6.4.2 引力场渐变色阶定义
        // 6.4.2.1 内部边缘 - 深空过渡
        // 6.4.2.1.1 使用暗蓝色调(15,15,45)并完全透明
        // 6.4.2.1.2 内部与黑洞核心区域自然融合，不形成硬边界
        // 6.4.2.1.3 符合引力理论预测的光线连续弯曲而非突变
        lensGradient.addColorStop(0, 'rgba(15, 15, 45, 0)');
        
        // 6.4.2.2 近内侧区域(20%) - 蓝色系
        // 6.4.2.2.1 使用明亮蓝色(60,100,160)代表强引力区
        // 6.4.2.2.2 透明度为0.06，创造微妙的视觉扭曲感
        // 6.4.2.2.3 这种蓝色调暗示了这一区域强烈的时空弯曲效应
        lensGradient.addColorStop(0.2, 'rgba(60, 100, 160, 0.06)');
        
        // 6.4.2.3 中间区域(40%) - 转向紫色系
        // 6.4.2.3.1 使用紫色调(90,70,160)表现减弱的引力场
        // 6.4.2.3.2 透明度降至0.05，使效果更加微妙
        // 6.4.2.3.3 色调变化符合引力场强度随距离减弱的物理规律
        lensGradient.addColorStop(0.4, 'rgba(90, 70, 160, 0.05)');
        
        // 6.4.2.4 外侧区域(60%) - 偏红紫色系
        // 6.4.2.4.1 使用红紫色调(130,70,110)创造视觉变化
        // 6.4.2.4.2 透明度进一步降至0.04，营造极其微妙的远场效果
        // 6.4.2.4.3 这种渐变模拟了远离黑洞的区域受到的微弱但仍然存在的引力扭曲
        lensGradient.addColorStop(0.6, 'rgba(130, 70, 110, 0.04)');
        
        // 6.4.2.5 外缘边界 - 完全透明过渡
        // 6.4.2.5.1 回到暗蓝色调(15,15,45)并完全透明
        // 6.4.2.5.2 确保引力场效果边缘与背景完美融合
        // 6.4.2.5.3 这种处理符合引力场无限延伸但强度逐渐衰减的物理特性
        lensGradient.addColorStop(1, 'rgba(15, 15, 45, 0)');
        
        // 6.5 引力场渲染状态设置
        // 6.5.1 保存当前绘图状态
        // 6.5.1.1 创建隔离的渲染环境，避免互相干扰
        // 6.5.1.2 引力场需要特殊的混合模式和阴影效果
        // 6.5.1.3 状态隔离确保复杂的时空扭曲效果不会污染其他渲染层
        ctx.save();
        
        // 6.5.2 设置光照混合模式
        // 6.5.2.1 使用'lighter'混合模式使颜色叠加增亮
        // 6.5.2.2 这种效果模拟了引力透镜对周围星光的放大和聚焦效应
        // 6.5.2.3 在实际天文观测中，引力透镜确实会增强背景星系的亮度
        ctx.globalCompositeOperation = 'lighter';
        
        // 6.5.3 开始绘制引力场路径
        // 6.5.3.1 清除之前的路径数据，准备绘制引力场圆形
        // 6.5.3.2 路径定义是所有Canvas绘图的基础环节
        // 6.5.3.3 干净的路径定义避免了不必要的渲染伪影
        ctx.beginPath();
        
        // 6.5.4 应用引力场渐变
        // 6.5.4.1 将前面定义的渐变设为填充样式
        // 6.5.4.2 这个渐变包含了从内到外的精细色阶和透明度变化
        // 6.5.4.3 渐变填充能够精确模拟光线在引力场中的连续弯曲效应
        ctx.fillStyle = lensGradient;
        
        // 6.5.5 绘制引力场主体圆形
        // 6.5.5.1 以中心点为圆心，lensSize为半径绘制完整圆形
        // 6.5.5.2 圆形从0到2π弧度覆盖整个周围空间
        // 6.5.5.3 圆形形状模拟了中心质量体产生的对称引力场
        ctx.arc(x, y, lensSize, 0, Math.PI * 2);
        
        // 6.5.6 执行填充操作
        // 6.5.6.1 用渐变色填充定义的引力场圆形
        // 6.5.6.2 在lighter混合模式下，填充区域会产生光线增强效果
        // 6.5.6.3 这一步完成了引力场基础层的渲染，为后续细节做准备
        ctx.fill();
        
        // 6.6 时空扭曲环渲染
        // 6.6.1 扭曲环数量设置
        // 6.6.1.1 设置6个同心环，代表不同距离的时空扭曲带
        // 6.6.1.2 这种分层结构精确模拟了引力透镜在不同距离产生的多重像现象
        // 6.6.1.3 实际天文观测中，强引力透镜确实会形成多重环状结构
        for (let i = 0; i < 6; i++) {
            // 6.6.2 单环尺寸计算
            // 6.6.2.1 基于基础尺寸、透镜进度和当前环索引计算环半径
            // 6.6.2.2 随着索引增加，环间距也随之增大，形成加速扩张的视觉效果
            // 6.6.2.3 这种非线性分布反映了引力场强度与距离的平方反比关系
            const ringSize = size * (1 + lensProgress * (3 + i * 0.8));
            
            // 6.6.3 环进度归一化
            // 6.6.3.1 将当前环索引转换为0-1范围的进度值
            // 6.6.3.2 这个值将用于颜色计算，使环的颜色沿径向平滑变化
            // 6.6.3.3 归一化处理是复杂视觉效果中的常用技巧，确保参数值在可控范围内
            const ringProgress = i / 6;
            
            // 6.6.4 环颜色丰富度设置
            // 6.6.4.1 使用全局色彩丰富度的1.5倍增强色彩表现力
            // 6.6.4.2 更高的丰富度使环的颜色更加生动多彩
            // 6.6.4.3 这种渲染设计暗示了光线经过引力场后产生的频谱变化
            const richness = OPTIMIZATION.COLOR_RICHNESS * 1.5; // 增强色彩丰富度
            
            // 6.6.5 RGB颜色复杂计算
            // 6.6.5.1 红色分量 - 多频率合成
            // 6.6.5.1.1 基础值50保证最小亮度
            // 6.6.5.1.2 主要波动80*sin()随环进度均匀变化
            // 6.6.5.1.3 次级高频波动增加微妙细节，模拟量子扰动
            // 6.6.5.1.4 这种复杂算法模拟了光谱在强引力场中的复杂变形
            const r = Math.floor(50 + 80 * Math.sin(ringProgress * Math.PI * 2) * richness + Math.sin(ringProgress * Math.PI * 5 + 0.3) * 60 * richness * 0.5);
            
            // 6.6.5.2 绿色分量 - 错相干涉
            // 6.6.5.2.1 基础值70略高于红色，增强中波长表现
            // 6.6.5.2.2 主波动添加120°相位差，与红色形成互补
            // 6.6.5.2.3 次级波动使用4.5倍频率，形成独特的干涉模式
            // 6.6.5.2.4 这种设计模拟了不同波长光在弯曲空间中的不同行为
            const g = Math.floor(70 + 80 * Math.sin(ringProgress * Math.PI * 2 + Math.PI/3) * richness + Math.sin(ringProgress * Math.PI * 4.5 + 1.0) * 70 * richness * 0.5);
            
            // 6.6.5.3 蓝色分量 - 高频振荡
            // 6.6.5.3.1 基础值100确保整体偏向蓝紫色，符合宇宙深空色调
            // 6.6.5.3.2 主波动添加240°相位差，完成RGB三原色循环
            // 6.6.5.3.3 次级波动使用5.2倍超高频率，模拟短波长光的精细变化
            // 6.6.5.3.4 这种蓝色偏向暗示了黑洞引力场对光的蓝移效应
            const b = Math.floor(100 + 80 * Math.sin(ringProgress * Math.PI * 2 + Math.PI*2/3) * richness + Math.sin(ringProgress * Math.PI * 5.2 + 2.0) * 80 * richness * 0.5);
            
            // 6.6.6 环透明度计算
            // 6.6.6.1 基础透明度0.12，随环索引递减
            // 6.6.6.2 每环递减0.015，使外环更加朦胧
            // 6.6.6.3 这种递减模拟了引力场强度随距离衰减的物理规律
            const ringAlpha = 0.12 - i * 0.015;
            
            // 6.6.7 绘制单个扭曲环
            // 6.6.7.1 开始新路径
            // 6.6.7.1.1 清除之前的路径数据，准备绘制当前环
            // 6.6.7.1.2 每个环需要独立的路径定义
            // 6.6.7.1.3 清晰的路径隔离确保环与环之间不会相互干扰
            ctx.beginPath();
            
            // 6.6.7.2 设置环描边样式
            // 6.6.7.2.1 使用前面计算的RGB值和透明度创建颜色
            // 6.6.7.2.2 rgba()格式允许精确控制环的外观
            // 6.6.7.2.3 每个环都有唯一的颜色标识，模拟光谱变化
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${ringAlpha})`;
            
            // 6.6.7.3 设置环线宽
            // 6.6.7.3.1 使用1.5单位的线宽，保持环的纤细感
            // 6.6.7.3.2 适当的线宽使环清晰可见但不喧宾夺主
            // 6.6.7.3.3 细线条设计暗示了引力场导致的精细空间扭曲
            ctx.lineWidth = 1.5;
            
            // 6.6.7.4 绘制环路径
            // 6.6.7.4.1 以中心点为圆心，ringSize为半径绘制圆环
            // 6.6.7.4.2 完整的圆周(0-2π)形成封闭的环形结构
            // 6.6.7.4.3 圆形环状准确模拟了对称引力场产生的引力透镜效应
            ctx.arc(x, y, ringSize, 0, Math.PI * 2);
            
            // 6.6.7.5 执行描边操作
            // 6.6.7.5.1 用设定的颜色和宽度描绘环路径
            // 6.6.7.5.2 在lighter混合模式下，环会与其他视觉元素产生光叠加
            // 6.6.7.5.3 这一步完成了单个引力扭曲环的渲染，循环继续下一个
            ctx.stroke();
        }
        
        // 6.7 爱因斯坦环特效 - 强引力透镜核心现象
        // 6.7.1 进度条件检查
        // 6.7.1.1 只在透镜进度超过0.6时显示爱因斯坦环
        // 6.7.1.2 这代表黑洞引力场已达到临界强度，形成完美环状像
        // 6.7.1.3 爱因斯坦环是广义相对论最震撼的预测之一，现已被天文观测证实
        if (lensProgress > 0.6) {
            // 6.7.2 环尺寸计算
            // 6.7.2.1 基于基础尺寸和透镜进度计算环半径
            // 6.7.2.2 随进度增加，环可扩展至基础尺寸的7倍
            // 6.7.2.3 这种计算模拟了不同质量黑洞产生的爱因斯坦环尺寸差异
            const einsteinRingSize = size * (2 + lensProgress * 5);
            
            // 6.7.3 环宽度计算
            // 6.7.3.1 基础宽度为size的0.05倍，随进度增加可达0.15倍
            // 6.7.3.2 宽度增加模拟了引力场强度提升导致的环变粗现象
            // 6.7.3.3 环宽度反映了背景星光被引力场弯曲的程度范围
            const einsteinRingWidth = size * 0.05 + lensProgress * size * 0.1;
            
            // 6.7.4 环透明度计算
            // 6.7.4.1 透明度从0到0.22线性增加
            // 6.7.4.2 使用(lensProgress-0.6)/0.4将进度0.6-1.0映射为0-1
            // 6.7.4.3 这种渐进出现方式使爱因斯坦环的形成看起来自然流畅
            const einsteinRingAlpha = 0.22 * (lensProgress - 0.6) / 0.4;
            
            // 6.7.5 多环渲染循环
            // 6.7.5.1 渲染3个同心但略有差异的爱因斯坦环
            // 6.7.5.2 多环设计丰富了视觉层次，模拟了复杂光学效应
            // 6.7.5.3 真实的爱因斯坦环也常因光源结构复杂而呈现多环结构
            for (let i = 0; i < 3; i++) {
                // 6.7.6 环尺寸比例计算
                // 6.7.6.1 基础比例0.9，每环递增0.1
                // 6.7.6.2 这种递增确保环与环之间有适当间距
                // 6.7.6.3 微妙的尺寸差异模拟了不同波长光的折射差异
                const ringScale = 0.9 + i * 0.1;
                
                // 6.7.7 当前环实际尺寸计算
                // 6.7.7.1 将基础环尺寸乘以比例因子得到当前环尺寸
                // 6.7.7.2 这确保每个环都有独特但相关的尺寸
                // 6.7.7.3 比例化设计增强了引力透镜效应的层次感
                const currentRingSize = einsteinRingSize * ringScale;
                
                // 6.7.8 环颜色相位计算
                // 6.7.8.1 将环索引转换为0-2π范围的相位角
                // 6.7.8.2 这个相位将用于生成环的独特颜色
                // 6.7.8.3 相位差设计确保每个环都有不同但和谐的颜色
                const phase = i / 3 * Math.PI * 2;
                
                // 6.7.9 颜色丰富度获取
                // 6.7.9.1 使用全局颜色丰富度参数控制色彩鲜艳程度
                // 6.7.9.2 这个参数影响正弦波的幅度，进而影响颜色变化程度
                // 6.7.9.3 适当的丰富度使爱因斯坦环看起来既绚丽又不过分夸张
                const richness = OPTIMIZATION.COLOR_RICHNESS;
                
                // 6.7.10 RGB颜色分量计算
                // 6.7.10.1 红色分量 - 基于相位的正弦波变化
                // 6.7.10.1.1 基础值60确保足够的亮度
                // 6.7.10.1.2 振幅80与丰富度相乘，控制色彩变化范围
                // 6.7.10.1.3 这种计算创造出平滑过渡的红色波动
                const r = Math.floor(60 + 80 * Math.sin(phase) * richness);
                
                // 6.7.10.2 绿色分量 - 添加120°相位差
                // 6.7.10.2.1 基础值与红色相同，确保色彩平衡
                // 6.7.10.2.2 相位差π/3(120°)创造出RGB三原色循环
                // 6.7.10.2.3 这种相位差设计是色彩理论的实际应用
                const g = Math.floor(60 + 80 * Math.sin(phase + Math.PI/3) * richness);
                
                // 6.7.10.3 蓝色分量 - 添加240°相位差
                // 6.7.10.3.1 基础值100高于红绿，使整体偏向蓝色调
                // 6.7.10.3.2 相位差2π/3(240°)完成三原色循环
                // 6.7.10.3.3 蓝色基础值增加，创造深邃宇宙感
                const b = Math.floor(100 + 80 * Math.sin(phase + Math.PI*2/3) * richness);
                
                // 6.7.11 环渐变创建
                // 6.7.11.1 创建环状渐变
                // 6.7.11.1.1 从内径(currentRingSize-einsteinRingWidth)到外径(currentRingSize+einsteinRingWidth)
                // 6.7.11.1.2 这种设计使环的中心最亮，向两侧渐变过渡
                // 6.7.11.1.3 径向渐变完美模拟了爱因斯坦环的光强分布
                const ringGradient = ctx.createRadialGradient(
                    x, y, currentRingSize - einsteinRingWidth,
                    x, y, currentRingSize + einsteinRingWidth
                );
                
                // 6.7.12 环渐变色阶设置
                // 6.7.12.1 内边缘(0%) - 深空色过渡
                // 6.7.12.1.1 使用暗蓝色调(15,15,45)并完全透明
                // 6.7.12.1.2 内边缘向中心平滑过渡，不形成硬边界
                // 6.7.12.1.3 这种处理使环看起来自然融入背景
                ringGradient.addColorStop(0, `rgba(15, 15, 45, 0)`);
                
                // 6.7.12.2 中心区域(50%) - 最亮部分
                // 6.7.12.2.1 使用前面计算的RGB颜色值
                // 6.7.12.2.2 透明度使用einsteinRingAlpha乘因子进行调整
                // 6.7.12.2.3 后续环索引越大透明度越低(1-i*0.2)，使效果更加立体
                ringGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${einsteinRingAlpha * (1 - i * 0.2)})`);
                
                // 6.7.12.3 外边缘(100%) - 深空色过渡
                // 6.7.12.3.1 再次使用深空色调，确保向外平滑融合
                // 6.7.12.3.2 完全透明的设置避免了硬边界出现
                // 6.7.12.3.3 首尾呼应的色彩设计使环形成完整封闭结构
                ringGradient.addColorStop(1, `rgba(15, 15, 45, 0)`);
                
                // 6.7.13 环渲染过程
                // 6.7.13.1 应用环渐变填充
                // 6.7.13.1.1 将创建的渐变设置为当前填充样式
                // 6.7.13.1.2 这个渐变包含了从内到外的完整过渡
                // 6.7.13.1.3 渐变填充使环看起来有自然的立体感和光晕
                ctx.fillStyle = ringGradient;
                
                // 6.7.13.2 开始绘制环路径
                // 6.7.13.2.1 清除之前的路径数据，准备绘制当前环
                // 6.7.13.2.2 干净的路径定义是精确渲染的基础
                // 6.7.13.2.3 每个环需要独立的路径对象
                ctx.beginPath();
                
                // 6.7.13.3 绘制环路径
                // 6.7.13.3.1 以中心点为圆心，currentRingSize为半径绘制圆形
                // 6.7.13.3.2 完整的圆周(0-2π)形成闭环结构
                // 6.7.13.3.3 精确的圆形几何与爱因斯坦环理论模型吻合
                ctx.arc(x, y, currentRingSize, 0, Math.PI * 2);
                
                // 6.7.13.4 执行填充操作
                // 6.7.13.4.1 用设定的渐变填充绘制的环形路径
                // 6.7.13.4.2 在lighter混合模式下产生光照叠加效果
                // 6.7.13.4.3 这一步完成了单个爱因斯坦环的渲染
                ctx.fill();
            }
        }
        
        // 6.8 引力场渲染状态恢复
        // 6.8.1 恢复之前保存的绘图状态
        // 6.8.1.1 撤销所有临时渲染设置，如混合模式和颜色
        // 6.8.1.2 确保引力场效果不会影响后续的渲染操作
        // 6.8.1.3 这种恢复操作是维护渲染环境整洁的最佳实践
        ctx.restore();
    }
    
    ctx.restore();
    
    // 7. 能量光环系统 - 高能粒子释放
    // 7.1 进度条件检查
    // 7.1.1 只在总进度超过0.7时显示能量光环效果
    // 7.1.2 这代表黑洞已经进入高能物质吞噬阶段
    // 7.1.3 现代天文物理学表明，黑洞吞噬物质时确实会释放巨大能量
    if (progress > 0.7) {
        // 7.2 能量系统专用进度计算
        // 7.2.1 将总进度0.7-1.0映射为能量系统专用进度0-1
        // 7.2.2 使用Math.min确保进度值不会超出有效范围
        // 7.2.3 这种专用进度映射确保了视觉效果的平滑过渡
        const energyProgress = Math.min(1, (progress - 0.7) / 0.3);
        
        // 7.3 光环数量计算
        // 7.3.1 基础数量为4，随进度增加最多可达10
        // 7.3.2 使用Math.floor确保数量为整数
        // 7.3.3 动态环数增长模拟了能量释放的逐步增强过程
        const ringCount = Math.floor(4 + energyProgress * 6);
        
        // 7.4 最大半径计算
        // 7.4.1 基础半径为size的1.2倍，随进度增加可达3.7倍
        // 7.4.2 这个范围确保能量光环覆盖黑洞周围足够大的区域
        // 7.4.3 随进度扩展的设计模拟了能量向外传播的物理过程
        const ringMaxRadius = size * (1.2 + energyProgress * 2.5);
        
        // 7.5 渲染状态设置
        // 7.5.1 保存当前绘图状态
        // 7.5.1.1 创建独立的渲染环境，避免互相干扰
        // 7.5.1.2 能量光环需要特殊的混合模式和颜色设置
        // 7.5.1.3 状态隔离是复杂渲染系统的最佳实践
        ctx.save();
        
        // 7.5.2 设置光照混合模式
        // 7.5.2.1 使用'lighter'混合模式使颜色叠加增亮
        // 7.5.2.2 这种模式完美模拟了高能粒子发光的叠加效应
        // 7.5.2.3 在实际的宇宙图像中，高能区域往往呈现出这种增亮效果
        ctx.globalCompositeOperation = 'lighter';
        
        // 7.6 多层光环渲染循环
        // 7.6.1 根据计算的环数循环创建多层能量光环
        // 7.6.2 每个环代表一个能量强度层级，共同构成复杂的能量场
        // 7.6.3 多层设计增强了视觉深度和能量场的立体感
        for (let i = 0; i < ringCount; i++) {
            // 7.6.2 环索引归一化
            // 7.6.2.1 将当前环索引转换为0-1范围的进度值
            // 7.6.2.2 这个值用于后续的颜色和位置计算
            // 7.6.2.3 归一化处理使参数变化更加可控和平滑
            const ringIndex = i / ringCount;
            
            // 7.6.3 环相位计算
            // 7.6.3.1 将环索引转换为0-2π范围的相位角
            // 7.6.3.2 这个相位用于生成环的独特颜色
            // 7.6.3.3 相位差设计确保环与环之间的颜色变化平滑而丰富
            const ringPhase = ringIndex * Math.PI * 2;
            
            // 7.6.4 环半径计算
            // 7.6.4.1 基础半径为size的0.6倍，向外线性扩展到最大半径
            // 7.6.4.2 这种设计确保环从黑洞附近开始，均匀分布到外部
            // 7.6.4.3 半径递增模拟了能量波在空间中的向外传播
            const ringRadius = size * 0.6 + (ringMaxRadius - size * 0.6) * ringIndex;
            
            // 7.6.5 环宽度计算
            // 7.6.5.1 基础宽度极小(0.0005倍size)，随进度增加
            // 7.6.5.2 外层环宽度逐渐减小(1-ringIndex*0.9)
            // 7.6.5.3 这种精细的宽度控制使光环看起来如同精确的能量波
            const ringWidth = size * (0.0005 + energyProgress * 0.005) * (1 - ringIndex * 0.9);
            
            // 7.6.6 旋转速度计算
            // 7.6.6.1 基于环索引奇偶性设置正负旋转方向
            // 7.6.6.2 旋转速度与能量进度成正比
            // 7.6.6.3 交替旋转方向模拟了复杂引力场中的多极结构
            const rotationSpeed = (i % 2 === 0 ? 1 : -1) * energyProgress * 5;
            
            // 7.6.7 旋转偏移计算
            // 7.6.7.1 基于总进度和环索引奇偶性计算旋转偏移
            // 7.6.7.2 奇数环和偶数环使用不同的旋转倍率
            // 7.6.7.3 这种设计使相邻光环旋转方向相反，增强视觉动感
            const rotationOffset = progress * 8 * (i % 2 === 0 ? 1 : -1.5);
            
            // 7.6.8 环颜色丰富度设置
            // 7.6.8.1 使用全局颜色丰富度参数控制色彩变化
            // 7.6.8.2 这个参数影响正弦波的振幅，进而改变颜色丰富度
            // 7.6.8.3 适当的丰富度参数使光环色彩既绚丽又保持科幻感
            const richness = OPTIMIZATION.COLOR_RICHNESS;
            
            // 7.6.9 RGB颜色分量计算
            // 7.6.9.1 红色分量 - 较高基础值和振幅
            // 7.6.9.1.1 基础值80确保亮度充足
            // 7.6.9.1.2 振幅100与丰富度相乘，产生明显的颜色波动
            // 7.6.9.1.3 这种设计使红色成为光环中的主要成分之一
            const r = Math.floor(80 + 100 * Math.sin(ringPhase) * richness);
            
            // 7.6.9.2 绿色分量 - 中等基础值
            // 7.6.9.2.1 基础值70略低于红色
            // 7.6.9.2.2 添加120°相位差，与红色形成互补
            // 7.6.9.2.3 适量的绿色成分平衡了整体色调，避免过于偏红
            const g = Math.floor(70 + 100 * Math.sin(ringPhase + Math.PI/3) * richness);
            
            // 7.6.9.3 蓝色分量 - 最高基础值和振幅
            // 7.6.9.3.1 基础值120高于红绿，确保整体偏向蓝色调
            // 7.6.9.3.2 振幅也是120，最大化蓝色的变化范围
            // 7.6.9.3.3 蓝色偏向暗示了高能粒子的切伦科夫辐射效应
            const b = Math.floor(120 + 120 * Math.sin(ringPhase + Math.PI*2/3) * richness);
            
            // 7.6.10 能量片段设置
            // 7.6.10.1 片段数量计算
            // 7.6.10.1.1 基础数量5，随进度增加到13
            // 7.6.10.1.2 使用Math.floor确保数量为整数
            // 7.6.10.1.3 片段化设计使光环呈现脉冲状，更加动态
            const segments = Math.floor(5 + energyProgress * 8);
            
            // 7.6.10.2 片段长度计算
            // 7.6.10.2.1 将完整圆周(2π)均分为segments个片段
            // 7.6.10.2.2 这确保了片段在圆周上均匀分布
            // 7.6.10.2.3 数学上精确的分割增强了视觉的规律感和秩序感
            const segmentLength = Math.PI * 2 / segments;
            
            // 7.6.10.3 片段间隙计算
            // 7.6.10.3.1 设置间隙为片段长度的30%
            // 7.6.10.3.2 这个比例在视觉上创造了恰当的断续效果
            // 7.6.10.3.3 间隙设计使能量看起来如同脉冲波，而非连续流
            const segmentGap = segmentLength * 0.3;
            
            // 7.6.11 片段循环渲染
            // 7.6.11.1 根据计算的片段数量循环创建片段
            // 7.6.11.2 每个片段代表能量场中的一个脉冲区域
            // 7.6.11.3 分段设计模拟了量子化的能量释放模式
            for (let j = 0; j < segments; j++) {
                // 7.6.11.4 片段起始角度计算
                // 7.6.11.4.1 基于片段索引和片段长度计算起始角度
                // 7.6.11.4.2 添加旋转偏移使环随时间旋转
                // 7.6.11.4.3 这种动态旋转模拟了能量场的自旋特性
                const segmentStart = j * segmentLength + rotationOffset;
                
                // 7.6.11.5 片段结束角度计算
                // 7.6.11.5.1 起始角度加上片段长度，再减去间隙
                // 7.6.11.5.2 这确保了片段之间有明确的视觉分隔
                // 7.6.11.5.3 间隙的存在增强了脉冲状能量的表现力
                const segmentEnd = segmentStart + segmentLength - segmentGap;
                
                // 7.6.11.6 片段相位计算
                // 7.6.11.6.1 将片段索引转换为0-2π范围的相位角
                // 7.6.11.6.2 这个相位用于为每个片段生成微妙的颜色变化
                // 7.6.11.6.3 细微的颜色差异增强了能量场的复杂性和真实感
                const segmentPhase = j / segments * Math.PI * 2;
                
                // 7.6.11.7 片段RGB颜色增强
                // 7.6.11.7.1 在环基础色上添加相位变化
                // 7.6.11.7.2 使用Math.min确保值不超过255
                // 7.6.11.7.3 这种处理使每个片段都有独特但协调的色调
                const sr = Math.min(255, r + Math.floor(Math.sin(segmentPhase) * 30));
                const sg = Math.min(255, g + Math.floor(Math.sin(segmentPhase + Math.PI/3) * 30));
                const sb = Math.min(255, b + Math.floor(Math.sin(segmentPhase + Math.PI*2/3) * 30));
                
                // 7.6.11.8 色相饱和度亮度转换
                // 7.6.11.8.1 将RGB值转换为HSL色彩空间
                // 7.6.11.8.2 这种转换便于后续基于色相的条件判断
                // 7.6.11.8.3 HSL比RGB更接近人类感知色彩的方式，便于筛选特定色调
                const [h, s, l] = rgbToHsl(sr, sg, sb);
                
                // 7.6.11.9 色调筛选条件
                // 7.6.11.9.1 定义"近白色"为高亮度(>0.8)低饱和度(<0.2)
                // 7.6.11.9.2 定义"近青色"为特定色相范围(160-200)且亮度适中(>0.5)
                // 7.6.11.9.3 这种筛选避免了特定不和谐色调，保持整体视觉协调
                const isWhiteOrCyanLike = (l > 0.8 && s < 0.2) || (h >= 160 && h <= 200 && l > 0.5);

                // 7.6.11.10 条件渲染判断
                // 7.6.11.10.1 如果颜色满足筛选条件，则跳过该片段
                // 7.6.11.10.2 这种智能筛选避免了视觉上不协调的色调出现
                // 7.6.11.10.3 在复杂的多色彩渲染中，色调控制对最终效果至关重要
                if (isWhiteOrCyanLike) {
                    continue; // 跳过绘制该片段
                }
                
                // 7.6.11.11 片段透明度计算
                // 7.6.11.11.1 基础透明度随环索引增加而增加(0.4+ringIndex*0.4)
                // 7.6.11.11.2 最终透明度与能量进度成正比
                // 7.6.11.11.3 这种设计使外层环更加明亮，形成自然的能量梯度
                const alpha = (0.4 + ringIndex * 0.4) * energyProgress;
                
                // 7.6.11.12 开始片段路径绘制
                // 7.6.11.12.1 清除之前的路径数据，准备绘制当前片段
                // 7.6.11.12.2 每个片段需要独立的路径定义
                // 7.6.11.12.3 干净的路径隔离确保片段之间不互相干扰
                ctx.beginPath();
                
                // 7.6.11.13 设置片段描边样式
                // 7.6.11.13.1 使用计算出的RGB颜色和透明度
                // 7.6.11.13.2 rgba()格式允许精确控制每个片段的外观
                // 7.6.11.13.3 这种颜色设置使每个片段都有微妙但可见的差异
                ctx.strokeStyle = `rgba(${sr}, ${sg}, ${sb}, ${alpha})`;
                
                // 7.6.11.14 设置片段线宽
                // 7.6.11.14.1 应用前面计算的环宽度
                // 7.6.11.14.2 精细的线宽使能量脉冲看起来清晰锐利
                // 7.6.11.14.3 适当的线宽对于表现高能粒子流的精细结构至关重要
                ctx.lineWidth = ringWidth;
                
                // 7.6.11.15 设置线端样式
                // 7.6.11.15.1 使用'round'样式使线条端点呈圆形
                // 7.6.11.15.2 圆形端点避免了锯齿感，增强了流畅性
                // 7.6.11.15.3 这种细节处理使能量片段看起来更加精致和自然
                ctx.lineCap = 'round';
                
                // 7.6.11.16 绘制圆弧片段
                // 7.6.11.16.1 以中心点为圆心，ringRadius为半径绘制部分圆弧
                // 7.6.11.16.2 从segmentStart到segmentEnd角度绘制，形成片段
                // 7.6.11.16.3 精确控制的圆弧确保能量片段分布均匀且视觉和谐
                ctx.arc(x, y, ringRadius, segmentStart, segmentEnd);
                
                // 7.6.11.17 执行描边操作
                // 7.6.11.17.1 用设定的颜色和宽度描绘片段路径
                // 7.6.11.17.2 在lighter混合模式下，片段会产生光照叠加效果
                // 7.6.11.17.3 这一步完成了单个能量片段的渲染
                ctx.stroke();
                
                // 7.6.11.18 粒子效果增强 - 高能量点光源
                // 7.6.11.18.1 随机条件判断，控制粒子生成概率
                // 7.6.11.18.2 概率与能量进度成正比，确保适量粒子数量
                // 7.6.11.18.3 随机性模拟了量子物理中的不确定性原理
                if (Math.random() < 0.3 * energyProgress) {
                    // 7.6.11.18.4 粒子角度计算
                    // 7.6.11.18.4.1 在当前片段角度范围内随机选择位置
                    // 7.6.11.18.4.2 这确保粒子出现在片段的任意位置
                    // 7.6.11.18.4.3 均匀分布的随机性创造了自然的粒子分布
                    const particleAngle = segmentStart + (segmentEnd - segmentStart) * Math.random();
                    
                    // 7.6.11.18.5 粒子距离计算
                    // 7.6.11.18.5.1 以环半径为基准，添加微小随机偏移
                    // 7.6.11.18.5.2 偏移范围为环宽度的正负0.7倍
                    // 7.6.11.18.5.3 这种设计使粒子围绕环路径形成自然分布
                    const particleDistance = ringRadius + (Math.random() - 0.7) * ringWidth * 1;
                    
                    // 7.6.11.18.6 粒子尺寸计算
                    // 7.6.11.18.6.1 基础尺寸在0.8-2.0之间随机变化
                    // 7.6.11.18.6.2 尺寸与能量进度成正比，进度越高粒子越大
                    // 7.6.11.18.6.3 尺寸变化模拟了能量密度的局部波动
                    const particleSize = (0.8 + Math.random() * 1.2) * energyProgress;
                    
                    // 7.6.11.18.7 粒子位置坐标计算
                    // 7.6.11.18.7.1 基于角度和距离计算粒子的x坐标
                    // 7.6.11.18.7.2 使用余弦函数进行极坐标到直角坐标转换
                    // 7.6.11.18.7.3 精确的位置计算确保粒子出现在环路径附近
                    const px = x + Math.cos(particleAngle) * particleDistance;
                    
                    // 7.6.11.18.8 粒子y坐标计算
                    // 7.6.11.18.8.1 基于角度和距离计算粒子的y坐标
                    // 7.6.11.18.8.2 使用正弦函数完成极坐标转换
                    // 7.6.11.18.8.3 x和y坐标组合确定了粒子在二维平面的精确位置
                    const py = y + Math.sin(particleAngle) * particleDistance;
                    
                    // 7.6.11.18.9 粒子渐变创建
                    // 7.6.11.18.9.1 创建从粒子中心向外辐射的渐变
                    // 7.6.11.18.9.2 渐变范围是粒子尺寸的3倍，形成发光晕轮
                    // 7.6.11.18.9.3 径向渐变完美模拟了能量点源的辐射特性
                    const particleGradient = ctx.createRadialGradient(
                        px, py, 0,
                        px, py, particleSize * 3
                    );
                    
                    // 7.6.11.18.10 粒子渐变色阶设置
                    // 7.6.11.18.10.1 中心区域(0%) - 高亮核心
                    // 7.6.11.18.10.1.1 在片段颜色基础上增加亮度(+30)
                    // 7.6.11.18.10.1.2 透明度略高于片段(alpha*1.2)
                    // 7.6.11.18.10.1.3 明亮中心模拟了能量粒子的高密度核心
                    particleGradient.addColorStop(0, `rgba(${sr + 30}, ${sg + 30}, ${sb + 30}, ${alpha * 1.2})`);
                    
                    // 7.6.11.18.10.2 中间区域(60%) - 过渡区
                    // 7.6.11.18.10.2.1 使用与片段相同的颜色，保持视觉一致性
                    // 7.6.11.18.10.2.2 透明度降低(alpha*0.8)，形成自然衰减
                    // 7.6.11.18.10.2.3 这种渐变模拟了能量场强度的空间衰减
                    particleGradient.addColorStop(0.6, `rgba(${sr}, ${sg}, ${sb}, ${alpha * 0.8})`);
                    
                    // 7.6.11.18.10.3 边缘区域(100%) - 完全透明
                    // 7.6.11.18.10.3.1 使用减半的颜色值，维持色调
                    // 7.6.11.18.10.3.2 透明度为0，确保边缘完美融合
                    // 7.6.11.18.10.3.3 平滑透明过渡避免了粒子边缘的硬边界
                    particleGradient.addColorStop(1, `rgba(${sr/2}, ${sg/2}, ${sb/2}, 0)`);
                    
                    // 7.6.11.18.11 应用粒子渐变
                    // 7.6.11.18.11.1 将创建的渐变设为当前填充样式
                    // 7.6.11.18.11.2 这个渐变包含了从核心到边缘的发光效果
                    // 7.6.11.18.11.3 渐变填充使粒子呈现出真实的能量点光源外观
                    ctx.fillStyle = particleGradient;
                    
                    // 7.6.11.18.12 开始粒子路径绘制
                    // 7.6.11.18.12.1 清除之前的路径数据，准备绘制粒子
                    // 7.6.11.18.12.2 粒子需要独立的路径定义
                    // 7.6.11.18.12.3 干净的路径隔离确保精确的粒子形状控制
                    ctx.beginPath();
                    
                    // 7.6.11.18.13 绘制粒子圆形
                    // 7.6.11.18.13.1 以计算的粒子坐标为中心，
                    // 7.6.11.18.13.2 半径为粒子尺寸的3倍，绘制完整圆形
                    // 7.6.11.18.13.3 圆形几何完美表现了能量点源的辐射对称性
                    ctx.arc(px, py, particleSize * 3, 0, Math.PI * 2);
                    
                    // 7.6.11.18.14 执行填充操作
                    // 7.6.11.18.14.1 用设定的渐变填充绘制的粒子圆形
                    // 7.6.11.18.14.2 在lighter混合模式下产生发光叠加效果
                    // 7.6.11.18.14.3 这一步完成了单个能量粒子的渲染
                    ctx.fill();
                }
            }
        }
        
        // 7.6.12 恢复绘图状态
        // 7.6.12.1 恢复保存的绘图状态，清除临时设置
        // 7.6.12.2 这确保了后续渲染不受当前组件设置的影响
        // 7.6.12.3 状态恢复是复杂渲染过程中保持整体一致性的关键步骤
        ctx.restore();
    }
    
    // 8. 宇宙坍缩特效系统 - 终极能量释放
    // 8.1 进度条件检查
    // 8.1.1 只在总进度超过0.7时显示坍缩特效
    // 8.1.2 这代表黑洞吸积达到临界点，触发壮观的坍缩级能量释放
    // 8.1.3 在理论天体物理学中，活动星系核中的超大质量黑洞确实会有类似的极端能量爆发
    if (progress > 0.7) {
        // 8.2 坍缩专用进度计算
        // 8.2.1 将总进度0.7-1.0映射为坍缩专用进度0-1
        // 8.2.2 这个专用进度值将控制坍缩相关特效的强度
        // 8.2.3 精确的进度映射确保特效的平滑过渡和递进感
        const collapseProgress = (progress - 0.7) / 0.3;
        
        // 8.3 坍缩波纹渲染 - 多彩时空涟漪
        // 8.3.1 波纹数量设置
        // 8.3.1.1 固定创建5个同心坍缩波纹
        // 8.3.1.2 每个波纹代表一个坍缩能量辐射层
        // 8.3.1.3 固定数量确保视觉效果的一致性和可控性
        for (let i = 0; i < 5; i++) {
            // 8.3.2 波纹尺寸计算
            // 8.3.2.1 基础尺寸为size，随进度和索引增加
            // 8.3.2.2 进度影响为12倍size，索引影响为2.5倍size
            // 8.3.2.3 这种计算使波纹从内向外扩展，外环移动速度更快
            const waveSize = size * (1 + collapseProgress * 12 + i * 2.5);
            
            // 8.3.3 波纹相位计算
            // 8.3.3.1 将波纹索引转换为0-2π范围的相位角
            // 8.3.3.2 这个相位用于生成波纹的独特颜色
            // 8.3.3.3 相位差设计确保不同波纹具有协调但不同的颜色
            const wavePhase = i / 5 * Math.PI * 2;
            
            // 8.3.4 颜色丰富度设置
            // 8.3.4.1 使用全局颜色丰富度参数控制色彩强度
            // 8.3.4.2 在大尺度特效中，适当的色彩丰富度至关重要
            // 8.3.4.3 丰富度参数影响色彩振幅，决定特效的视觉鲜艳程度
            const richness = OPTIMIZATION.COLOR_RICHNESS;
            
            // 8.3.5 RGB颜色分量计算
            // 8.3.5.1 红色分量 - 基础值和相位变化
            // 8.3.5.1.1 基础值60确保足够的可见度
            // 8.3.5.1.2 振幅80与丰富度相乘，控制变化范围
            // 8.3.5.1.3 正弦波变化创造平滑的颜色过渡
            const r = Math.floor(60 + 80 * Math.sin(wavePhase) * richness);
            
            // 8.3.5.2 绿色分量 - 添加相位差
            // 8.3.5.2.1 基础值70略高于红色，增强中波长表现
            // 8.3.5.2.2 添加120°相位差，创造RGB三原色循环
            // 8.3.5.2.3 这种相位差安排是色彩理论的经典应用
            const g = Math.floor(70 + 80 * Math.sin(wavePhase + Math.PI/3) * richness);
            
            // 8.3.5.3 蓝色分量 - 更高基础值
            // 8.3.5.3.1 基础值110明显高于红绿，使整体偏向蓝紫色调
            // 8.3.5.3.2 添加240°相位差，完成三原色循环
            // 8.3.5.3.3 蓝色偏向创造深邃宇宙感，符合坍缩事件的科幻印象
            const b = Math.floor(110 + 80 * Math.sin(wavePhase + Math.PI*2/3) * richness);
            
            // 8.3.6 波纹透明度计算
            // 8.3.6.1 基础透明度0.22，乘以三个衰减因子
            // 8.3.6.2 (1-collapseProgress)使波纹随进度增加而淡出
            // 8.3.6.3 (1-i*0.2)使外层波纹逐渐淡出，模拟能量衰减
            const waveAlpha = 0.22 * (1 - collapseProgress) * (1 - i * 0.2);
            
            // 8.3.7 波纹绘制流程
            // 8.3.7.1 开始波纹路径绘制
            // 8.3.7.1.1 清除之前的路径数据，准备绘制当前波纹
            // 8.3.7.1.2 每个波纹需要独立的路径定义
            // 8.3.7.1.3 干净的路径隔离确保波纹之间的独立性
            ctx.beginPath();
            
            // 8.3.7.2 设置波纹描边样式
            // 8.3.7.2.1 使用计算的RGB颜色和透明度
            // 8.3.7.2.2 rgba()格式允许精确控制波纹的外观
            // 8.3.7.2.3 颜色和透明度组合创造出震撼的视觉效果
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${waveAlpha})`;
            
            // 8.3.7.3 设置波纹线宽
            // 8.3.7.3.1 使用2个单位的线宽，确保波纹清晰可见
            // 8.3.7.3.2 适当的线宽对于大尺度特效的视觉表现至关重要
            // 8.3.7.3.3 线宽固定而非随机，确保波纹的一致性和整体感
            ctx.lineWidth = 2;
            
            // 8.3.7.4 绘制波纹圆形路径
            // 8.3.7.4.1 以中心点为圆心，waveSize为半径绘制圆形
            // 8.3.7.4.2 完整的圆周(0-2π)形成封闭的环形结构
            // 8.3.7.4.3 几何完美的圆形象征着时空涟漪的对称传播
            ctx.arc(x, y, waveSize, 0, Math.PI * 2);
            
            // 8.3.7.5 执行描边操作
            // 8.3.7.5.1 用设定的颜色和宽度描绘波纹路径
            // 8.3.7.5.2 描边而非填充，创造出纤细的波纹线条
            // 8.3.7.5.3 这一步完成了单个坍缩波纹的渲染
            ctx.stroke();
        }
        
        // 8.4 坍缩能量束系统 - 绚丽宇宙螺旋光束
        // 8.4.1 能量束数量设置
        // 8.4.1.1 创建36条均匀分布的能量束
        // 8.4.1.2 数量明显增加(从早期版本的12条增至36条)
        // 8.4.1.3 更多的能量束创造出更加密集和壮观的视觉效果
        const beamCount = 36; // 增加光束数量，从12增加到36
        
        // 8.4.2 能量束循环创建
        // 8.4.2.1 根据设定的数量循环创建多条能量束
        // 8.4.2.2 每条能量束代表一个高能量辐射方向
        // 8.4.2.3 均匀分布的能量束模拟了坍缩能量向全方位释放的场景
        for (let i = 0; i < beamCount; i++) {
            // 8.4.3 能量束角度计算
            // 8.4.3.1 基于索引均匀分布在圆周上，确保全方位覆盖
            // 8.4.3.2 添加旋转偏移(progress*7)使整体随时间旋转
            // 8.4.3.3 动态旋转增强了能量场的活力和流动感
            const angle = (i / beamCount) * Math.PI * 2 + progress * 7;
            
            // 8.4.4 能量束长度计算
            // 8.4.4.1 基础长度为size的3倍，随坍缩进度增加
            // 8.4.4.2 最大可达size的21倍，创造极具视觉冲击力的延伸效果
            // 8.4.4.3 这种动态延伸模拟了能量向外空间的快速传播
            const beamLength = size * (3 + collapseProgress * 18);
            
            // 8.4.5 螺旋参数设置
            // 8.4.5.1 螺旋转数计算
            // 8.4.5.1.1 基础转数为3圈，随进度增加到8圈
            // 8.4.5.1.2 转数增加使螺旋更加密集和复杂
            // 8.4.5.1.3 这种设计模拟了高能粒子在磁场中的螺旋运动轨迹
            const spiralTurns = 3 + collapseProgress * 5;
            
            // 8.4.5.2 螺旋宽度计算
            // 8.4.5.2.1 基础宽度为0.8，随进度增加到2.8
            // 8.4.5.2.2 宽度控制使螺旋在视觉上保持适当的粗细
            // 8.4.5.2.3 不过分宽大的螺旋线条使整体效果更加精致
            const spiralWidth = 0.8 + collapseProgress * 2; // 减小宽度，使光束更细
            
            // 8.4.6 能量束颜色设置
            // 8.4.6.1 颜色相位计算
            // 8.4.6.1.1 将束索引转换为0-2π范围的相位角
            // 8.4.6.1.2 这个相位用于生成每条束的独特颜色
            // 8.4.6.1.3 相位差确保不同能量束具有丰富多样的色彩变化
            const colorPhase = i / beamCount * Math.PI * 2;
            
            // 8.4.6.2 颜色丰富度增强
            // 8.4.6.2.1 使用全局丰富度的2倍，大幅增强色彩表现力
            // 8.4.6.2.2 更高的丰富度使能量束色彩更加绚丽夺目
            // 8.4.6.2.3 这种设计强化了终极能量释放的视觉震撼力
            const richness = OPTIMIZATION.COLOR_RICHNESS * 2.0; // 进一步增强色彩丰富度
            
            // 8.4.7 复杂RGB基础颜色计算
            // 8.4.7.1 红色基础 - 多频率合成
            // 8.4.7.1.1 基础值70确保足够的亮度
            // 8.4.7.1.2 主频率振幅90与丰富度相乘，控制主要变化
            // 8.4.7.1.3 次频率3.1倍，添加精细变化，创造复杂色彩
            const rBase = Math.floor(70 + 90 * Math.sin(colorPhase) * richness + Math.sin(colorPhase * 3.1 + 0.2) * 50 * richness * 0.5);
            
            // 8.4.7.2 绿色基础 - 错相多频率
            // 8.4.7.2.1 基础值60略低于红色，降低绿色比重
            // 8.4.7.2.2 主频率添加120°相位差，与红色形成互补
            // 8.4.7.2.3 次频率使用2.9倍频率，与红色形成微妙错位
            const gBase = Math.floor(60 + 90 * Math.sin(colorPhase + Math.PI/3) * richness + Math.sin(colorPhase * 2.9 + 1.1) * 60 * richness * 0.5);
            
            // 8.4.7.3 蓝色基础 - 高亮度设置
            // 8.4.7.3.1 基础值120明显高于红绿，确保整体偏向蓝紫色调
            // 8.4.7.3.2 主频率添加240°相位差，完成三原色循环
            // 8.4.7.3.3 次频率3.5倍，添加更高频细节，增强复杂性
            const bBase = Math.floor(120 + 100 * Math.sin(colorPhase + Math.PI*2/3) * richness + Math.sin(colorPhase * 3.5 + 2.0) * 70 * richness * 0.5);
            
            // 8.4.8 随机颜色变化添加
            // 8.4.8.1 生成RGB随机偏移量
            // 8.4.8.1.1 范围为±15，添加微妙的随机变化
            // 8.4.8.1.2 随机性使每条能量束都有唯一的色彩特征
            // 8.4.8.1.3 这种设计模拟了实际高能粒子束的不均匀性
            const rOffset = Math.floor(Math.random() * 30) - 15;
            const gOffset = Math.floor(Math.random() * 30) - 15;
            const bOffset = Math.floor(Math.random() * 30) - 15;
            
            // 8.4.8.2 最终RGB颜色计算
            // 8.4.8.2.1 将基础颜色与偏移量相加
            // 8.4.8.2.2 使用Math.max和Math.min确保值在0-255范围内
            // 8.4.8.2.3 这种设计确保了颜色在有效范围内的同时保留随机变化
            const r = Math.max(0, Math.min(255, rBase + rOffset));
            const g = Math.max(0, Math.min(255, gBase + gOffset));
            const b = Math.max(0, Math.min(255, bBase + bOffset));
            
            // 8.4.9 双螺旋设计 - 视觉丰富化
            // 8.4.9.1 创建平行双螺旋能量束
            // 8.4.9.1.1 每条主能量束由两条平行螺旋组成
            // 8.4.9.1.2 双螺旋结构增强视觉复杂性和能量感
            // 8.4.9.1.3 这种设计灵感来源于DNA双螺旋和磁力线结构
            for (let s = 0; s < 2; s++) {
                // 8.4.9.2 开始螺旋路径绘制
                // 8.4.9.2.1 清除之前的路径数据，准备绘制当前螺旋
                // 8.4.9.2.2 每条螺旋需要独立的路径定义
                // 8.4.9.2.3 干净的路径隔离确保螺旋之间不互相干扰
                ctx.beginPath();
                
                // 8.4.9.3 创建螺旋渐变
                // 8.4.9.3.1 创建从中心到外沿的线性渐变
                // 8.4.9.3.2 渐变方向与螺旋方向一致，确保自然过渡
                // 8.4.9.3.3 线性渐变完美模拟了能量沿螺旋传输的视觉效果
                const spiralGradient = ctx.createLinearGradient(
                    x, y,
                    x + Math.cos(angle) * beamLength,
                    y + Math.sin(angle) * beamLength
                );
                
                // 8.4.9.4 螺旋渐变色阶设置
                // 8.4.9.4.1 中心区域(0%) - 高亮核心
                // 8.4.9.4.2 使用与主能量束相同的颜色
                // 8.4.9.4.3 这种设计使螺旋看起来更加自然和连续
                spiralGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1)`);
                
                // 8.4.9.5 中间区域(60%) - 过渡区
                // 8.4.9.5.1 使用与主能量束相同的颜色，但透明度降低
                // 8.4.9.5.2 透明度为0.8，形成自然衰减效果
                spiralGradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.8)`);
                
                // 8.4.9.6 边缘区域(100%) - 完全透明
                // 8.4.9.6.1 使用与主能量束相同的颜色，但透明度进一步降低
                // 8.4.9.6.2 透明度为0.6，形成更加微妙的过渡效果
                spiralGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.6)`);
                
                // 8.4.9.7 应用螺旋渐变
                // 8.4.9.7.1 将创建的渐变设为当前填充样式
                // 8.4.9.7.2 这个渐变包含了从核心到边缘的发光效果
                // 8.4.9.7.3 渐变填充使能量束看起来更加绚丽和动态
                ctx.fillStyle = spiralGradient;
                
                // 8.4.9.8 设置混合模式为lighter
                // 8.4.9.8.1 lighter模式使重叠区域颜色相加，形成明亮光效
                // 8.4.9.8.2 这种模式完美模拟了高能光束的视觉特性
                // 8.4.9.8.3 重叠区域的亮度增强创造出震撼的视觉冲击力
                ctx.globalCompositeOperation = 'lighter';
                
                // 8.4.9.9 螺旋段数计算
                // 8.4.9.9.1 基于螺旋转数，计算所需的绘制点数
                // 8.4.9.9.2 每圈20点，确保螺旋平滑圆润
                // 8.4.9.9.3 点数充足是精确绘制复杂螺旋的关键
                const segments = Math.floor(20 * spiralTurns);
                
                // 8.4.9.10 移动到螺旋起点
                // 8.4.9.10.1 计算螺旋起点坐标
                // 8.4.9.10.2 偏移角度为当前螺旋索引*π，形成交错双螺旋
                // 8.4.9.10.3 精确定位确保双螺旋均匀分布在能量束路径上
                const startX = x + Math.cos(angle + s * Math.PI) * size * 0.9;
                const startY = y + Math.sin(angle + s * Math.PI) * size * 0.9;
                
                // 8.4.9.11 设置起点
                // 8.4.9.11.1 将绘图光标移动到计算的起点位置
                // 8.4.9.11.2 这是绘制任何路径的必要第一步
                // 8.4.9.11.3 起点设置确保螺旋从事件视界边缘开始
                ctx.moveTo(startX, startY);
                
                // 8.4.9.12 螺旋点绘制循环
                // 8.4.9.12.1 逐点构建螺旋曲线
                // 8.4.9.12.2 每个点代表螺旋上的一个位置
                // 8.4.9.12.3 点的连接形成流畅的螺旋能量束路径
                for (let j = 1; j <= segments; j++) {
                    // 8.4.9.12.4 计算螺旋进度
                    // 8.4.9.12.4.1 将当前点索引转换为0-1范围的进度值
                    // 8.4.9.12.4.2 这个进度值控制点在螺旋上的位置
                    // 8.4.9.12.4.3 均匀的进度值确保螺旋曲线平滑自然
                    const segmentProgress = j / segments;
                    
                    // 8.4.9.12.5 计算点角度
                    // 8.4.9.12.5.1 基础角度为主能量束方向
                    // 8.4.9.12.5.2 添加旋转偏移(segmentProgress * spiralTurns * Math.PI * 2)
                    // 8.4.9.12.5.3 s*Math.PI添加180°相位差，形成双螺旋结构
                    const segmentAngle = angle + s * Math.PI + segmentProgress * spiralTurns * Math.PI * 2;
                    
                    // 8.4.9.12.6 计算径向距离
                    // 8.4.9.12.6.1 距离从0.9*size增加到beamLength
                    // 8.4.9.12.6.2 使用segmentProgress控制平滑过渡
                    // 8.4.9.12.6.3 这种设计使螺旋从中心向外扩展
                    const segmentDist = size * 0.9 + segmentProgress * (beamLength - size * 0.9);
                    
                    // 8.4.9.12.7 计算螺旋宽度
                    // 8.4.9.12.7.1 根据进度计算当前点的螺旋宽度
                    // 8.4.9.12.7.2 spiralWidth为基础宽度，Math.sin()添加脉动效果
                    // 8.4.9.12.7.3 宽度变化使螺旋看起来更加动态和有活力
                    const width = Math.sin(segmentProgress * Math.PI) * spiralWidth * segmentDist / beamLength;
                    
                    // 8.4.9.12.8 计算侧向偏移
                    // 8.4.9.12.8.1 使用正弦波生成侧向偏移，创造螺旋效果
                    // 8.4.9.12.8.2 偏移量与当前宽度成正比，保持适当的比例
                    // 8.4.9.12.8.3 偏移的计算是螺旋几何形态的核心
                    const offsetX = Math.sin(segmentAngle) * width;
                    const offsetY = -Math.cos(segmentAngle) * width;
                    
                    // 8.4.9.12.9 计算最终点坐标
                    // 8.4.9.12.9.1 基于主方向角度和当前径向距离计算基础位置
                    // 8.4.9.12.9.2 添加侧向偏移，形成螺旋曲线
                    // 8.4.9.12.9.3 这种精确坐标计算确保螺旋的数学精确性
                    const pointX = x + Math.cos(angle) * segmentDist + offsetX;
                    const pointY = y + Math.sin(angle) * segmentDist + offsetY;
                    
                    // 8.4.9.12.10 连接到当前点
                    // 8.4.9.12.10.1 将上一点与当前点连接，形成连续线段
                    // 8.4.9.12.10.2 线段的积累形成完整的螺旋曲线
                    // 8.4.9.12.10.3 每个小线段对整体螺旋的精度贡献至关重要
                    ctx.lineTo(pointX, pointY);
                }
                
                // 8.4.9.13 设置螺旋线条样式
                // 8.4.9.13.1 使用与螺旋相同的颜色
                // 8.4.9.13.2 透明度0.8，使线条清晰但不过于锐利
                // 8.4.9.13.3 颜色一致性确保了能量束的视觉统一
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                
                // 8.4.9.14 设置线宽
                // 8.4.9.14.1 线宽为2个单位，确保螺旋清晰可见
                // 8.4.9.14.2 适当的线宽对于能量束的视觉表现至关重要
                // 8.4.9.14.3 线宽固定而非随机，确保螺旋的一致性和整体感
                ctx.lineWidth = 2;
                
                // 8.4.9.15 设置线端样式
                // 8.4.9.15.1 使用'round'样式使线条端点呈圆形
                // 8.4.9.15.2 圆形端点避免了锯齿感，增强了流畅性
                // 8.4.9.15.3 这种细节处理使能量束看起来更加精致和自然
                ctx.lineCap = 'round';
                
                // 8.4.9.16 设置线段连接样式
                // 8.4.9.16.1 使用'round'样式使线段连接处呈圆形
                // 8.4.9.16.2 圆形连接避免了尖角，增强了流畅性
                // 8.4.9.16.3 这种设计使螺旋看起来更加平滑自然
                ctx.lineJoin = 'round';
                
                // 8.4.9.17 执行描边操作
                // 8.4.9.17.1 用设定的颜色和宽度描绘螺旋路径
                // 8.4.9.17.2 在lighter混合模式下，螺旋线条会产生光照叠加效果
                // 8.4.9.17.3 这一步完成了单条螺旋的渲染
                ctx.stroke();
            }
        }
    }
    
    // 8.5 星云效果系统 - 尘埃与电离气体模拟
    // 8.5.1 星云密度计算
    // 8.5.1.1 基于坍缩进度计算星云粒子数量
    // 8.5.1.2 密度从最小100个点到最大300个点线性增长
    // 8.5.1.3 粒子数量足够多才能形成连续而自然的星云质感
    const nebulaDensity = Math.floor(100 + collapseProgress * 200);
    
    // 8.5.2 星云范围计算
    // 8.5.2.1 基于基础尺寸和坍缩进度计算星云覆盖范围
    // 8.5.2.2 从4倍size增加到10倍size，形成广阔的星云区域
    // 8.5.2.3 这种大范围设计模拟了黑洞吸积过程中扰动周围星际介质的现象
    const nebulaRange = size * (4 + collapseProgress * 6);
    
    // 8.5.3 保存渲染状态
    // 8.5.3.1 保存当前绘图状态，避免星云渲染影响其他组件
    // 8.5.3.2 状态隔离是复杂渲染过程中的重要工程实践
    // 8.5.3.3 这确保了星云特效与其他特效的独立性和可控性
    ctx.save();
    
    // 8.5.4 应用混合模式
    // 8.5.4.1 设置混合模式为lighter，使颜色叠加产生发光效果
    // 8.5.4.2 这种模式特别适合模拟星际气体的发光特性
    // 8.5.4.3 lighter模式是太空发光现象视觉表现的理想选择
    ctx.globalCompositeOperation = 'lighter';
    
    // 8.5.5 星云粒子循环创建
    // 8.5.5.1 根据密度参数循环创建粒子
    // 8.5.5.2 每个粒子代表星云中的一个气体/尘埃团块
    // 8.5.5.3 大量随机分布的粒子共同构成自然的星云结构
    for (let i = 0; i < nebulaDensity; i++) {
        // 8.5.6 粒子角度计算
        // 8.5.6.1 生成0-2π范围内的随机角度
        // 8.5.6.2 随机角度确保粒子在全方位均匀分布
        // 8.5.6.3 均匀的角度分布创造出自然的星云形态
        const angle = Math.random() * Math.PI * 2;
        
        // 8.5.7 粒子距离计算
        // 8.5.7.1 计算粒子到中心的距离
        // 8.5.7.2 使用平方根分布，使粒子在中心区域更加密集
        // 8.5.7.3 这种分布模拟了真实星云的密度梯度
        const distance = size * (3 + Math.sqrt(Math.random()) * (nebulaRange / size - 3));
        
        // 8.5.8 粒子坐标计算
        // 8.5.8.1 基于角度和距离计算粒子的x坐标
        // 8.5.8.2 使用余弦函数进行极坐标到直角坐标转换
        // 8.5.8.3 精确的位置计算确保粒子分布符合预期几何形态
        const px = x + Math.cos(angle) * distance;
        
        // 8.5.8.4 计算粒子的y坐标
        // 8.5.8.4.1 基于角度和距离计算粒子的y坐标
        // 8.5.8.4.2 使用正弦函数完成极坐标转换
        // 8.5.8.4.3 x和y坐标组合确定了粒子在二维平面的精确位置
        const py = y + Math.sin(angle) * distance;
        
        // 8.5.9 粒子尺寸计算
        // 8.5.9.1 基础尺寸在2-6之间随机变化
        // 8.5.9.2 远距离粒子尺寸减小，模拟透视效果
        // 8.5.9.3 变化的粒子尺寸增强了星云的层次感和立体感
        const size = (2 + Math.random() * 4) * (1 - (distance / nebulaRange) * 0.5);
        
        // 8.5.10 粒子颜色相位计算
        // 8.5.10.1 生成0-2π范围内的随机相位
        // 8.5.10.2 这个相位用于生成粒子的独特颜色
        // 8.5.10.3 随机相位确保星云呈现丰富多彩的外观
        const colorPhase = Math.random() * Math.PI * 2;
        
        // 8.5.11 颜色丰富度设置
        // 8.5.11.1 使用全局丰富度的1.5倍增强色彩表现力
        // 8.5.11.2 更高的丰富度使星云色彩更加绚丽多彩
        // 8.5.11.3 这种设计模拟了不同元素气体在星云中发光的多彩景象
        const richness = OPTIMIZATION.COLOR_RICHNESS * 1.5;
        
        // 8.5.12 RGB颜色分量计算
        // 8.5.12.1 红色分量 - 基础和相位变化
        // 8.5.12.1.1 基础值40确保足够的可见度
        // 8.5.12.1.2 振幅80与丰富度相乘，控制变化范围
        // 8.5.12.1.3 正弦波变化创造平滑的颜色过渡
        const r = Math.floor(40 + 80 * Math.sin(colorPhase) * richness);
        
        // 8.5.12.2 绿色分量 - 添加相位差
        // 8.5.12.2.1 基础值50略高于红色
        // 8.5.12.2.2 添加120°相位差，创造RGB三原色循环
        // 8.5.12.2.3 这种相位差安排是色彩理论的经典应用
        const g = Math.floor(50 + 80 * Math.sin(colorPhase + Math.PI/3) * richness);
        
        // 8.5.12.3 蓝色分量 - 更高基础值
        // 8.5.12.3.1 基础值90明显高于红绿，使整体偏向蓝紫色调
        // 8.5.12.3.2 添加240°相位差，完成三原色循环
        // 8.5.12.3.3 蓝色偏向创造深邃宇宙感，符合星云的科幻印象
        const b = Math.floor(90 + 80 * Math.sin(colorPhase + Math.PI*2/3) * richness);
        
        // 8.5.13 粒子透明度计算
        // 8.5.13.1 基础透明度在0.05-0.2之间随机变化
        // 8.5.13.2 与坍缩进度成正比，进度越高星云越明亮
        // 8.5.13.3 低透明度创造出朦胧缥缈的星云质感
        const alpha = (0.05 + Math.random() * 0.15) * collapseProgress;
        
        // 8.5.14 粒子渐变创建
        // 8.5.14.1 创建从粒子中心向外辐射的渐变
        // 8.5.14.2 渐变范围是粒子尺寸的两倍，形成柔和的边缘
        // 8.5.14.3 径向渐变完美模拟了星云气体团块的外观特征
        const particleGradient = ctx.createRadialGradient(
            px, py, 0,
            px, py, size * 2
        );
        
        // 8.5.15 粒子渐变色阶设置
        // 8.5.15.1 中心区域(0%) - 高亮核心
        // 8.5.15.1.1 使用计算的RGB颜色，透明度为alpha的两倍
        // 8.5.15.1.2 中心区域更亮，模拟气体密度较高的核心区
        // 8.5.15.1.3 这种设计使每个星云粒子都有明亮的中心区域
        particleGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 2})`);
        
        // 8.5.15.2 边缘区域(100%) - 完全透明
        // 8.5.15.2.1 使用相同的RGB颜色，但透明度为0
        // 8.5.15.2.2 这创造了柔和的边缘过渡，避免硬边界
        // 8.5.15.2.3 平滑的边缘过渡是真实星云外观的关键特征
        particleGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        
        // 8.5.16 应用粒子渐变
        // 8.5.16.1 将创建的渐变设为当前填充样式
        // 8.5.16.2 这个渐变定义了粒子的颜色分布
        // 8.5.16.3 渐变填充使星云粒子看起来自然而真实
        ctx.fillStyle = particleGradient;
        
        // 8.5.17 开始粒子路径绘制
        // 8.5.17.1 清除之前的路径数据，准备绘制当前粒子
        // 8.5.17.2 每个粒子需要独立的路径定义
        // 8.5.17.3 干净的路径隔离确保粒子之间不互相干扰
        ctx.beginPath();
        
        // 8.5.18 绘制粒子圆形
        // 8.5.18.1 以计算的粒子坐标为中心
        // 8.5.18.2 半径为粒子尺寸的两倍，绘制完整圆形
        // 8.5.18.3 圆形几何完美表现了星云气体团块的形态
        ctx.arc(px, py, size * 2, 0, Math.PI * 2);
        
        // 8.5.19 执行填充操作
        // 8.5.19.1 用设定的渐变填充绘制的圆形
        // 8.5.19.2 在lighter混合模式下，粒子会产生光照叠加效果
        // 8.5.19.3 这一步完成了单个星云粒子的渲染
        ctx.fill();
    }
    
    // 8.5.20 恢复渲染状态
    // 8.5.20.1 恢复保存的绘图状态，清除临时设置
    // 8.5.20.2 这确保了后续渲染不受当前特效设置的影响
    // 8.5.20.3 状态恢复是复杂渲染过程中的最佳实践
    ctx.restore();
}





        
        // 超级宇宙坍缩特效
        function createSuperUniverseCollapseEffect() {
            // 获取或创建canvas
            const collapseCanvas = document.getElementById('universe-collapse-canvas');
            const dpr = window.devicePixelRatio || 1;
            collapseCanvas.width = window.innerWidth * dpr;
            collapseCanvas.height = window.innerHeight * dpr;
            const ctx = collapseCanvas.getContext('2d', { alpha: true });
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = true;

            // 坍缩参数
            const maxParticleCount = OPTIMIZATION.PARTICLE_COUNT;
            const maxStageTime = OPTIMIZATION.MAX_STAGE_TIME;
            let stageTime = 0;
            let animating = false;
            let particles = [];
            let collapsePoint = {
                x: window.innerWidth / 2,
                y: window.innerHeight / 2
            };
            
            // 坍缩状态控制
            let collapseState = {
                phase: 'initial',     // 'initial', 'first_collapse', 'release', 'second_collapse', 'singularity', 'fade'
                phaseStartTime: 0,
                phaseProgress: 0,
                vortexSize: 0,
                singularitySize: 0,
                fadeOut: 0
            };

            // 更清晰的彗星粒子颜色配置
            const cometTypes = [
                { 
                    coreColor: {r: 0, g: 180, b: 220}, 
                    tailColor: {r: 0, g: 80, b: 220}, 
                    size: 2.5,
                    speed: 1.2
                },
                { 
                    coreColor: {r: 180, g: 0, b: 220}, 
                    tailColor: {r: 100, g: 0, b: 220}, 
                    size: 2.2,
                    speed: 1.1
                },
                { 
                    coreColor: {r: 220, g: 100, b: 0}, 
                    tailColor: {r: 220, g: 160, b: 0}, 
                    size: 3.0,
                    speed: 1.3
                }
            ];

            // 初始化粒子
            function initParticles() {
                particles = [];
                
                // 创建粒子
                for (let i = 0; i < maxParticleCount; i++) {
                    // 生成随机位置
                    let x, y;
                    const edgeProb = Math.random();
                    
                    if (edgeProb < 0.85) {
                        // 从屏幕边缘生成
                        const side = Math.floor(Math.random() * 4);
                        switch (side) {
                            case 0: // 上边
                                x = Math.random() * window.innerWidth;
                                y = -150 + Math.random() * 100;
                                break;
                            case 1: // 右边
                                x = window.innerWidth + Math.random() * 150;
                                y = Math.random() * window.innerHeight;
                                break;
                            case 2: // 下边
                                x = Math.random() * window.innerWidth;
                                y = window.innerHeight + Math.random() * 150;
                                break;
                            case 3: // 左边
                                x = -150 + Math.random() * 150;
                                y = Math.random() * window.innerHeight;
                                break;
                        }
                    } else {
                        // 随机分布在屏幕内
                        x = Math.random() * window.innerWidth;
                        y = Math.random() * window.innerHeight;
                    }
                    
                    // 粒子类型 - 增加彗星粒子的比例
                    const particleType = Math.random();
                    let size, alpha, color, speedFactor, physicsType, isComet = false;
                    
                    if (particleType < 0.25) { // 25% 彗星粒子
                        const cometType = cometTypes[Math.floor(Math.random() * cometTypes.length)];
                        size = cometType.size;
                        alpha = 0.8 + Math.random() * 0.15;
                        color = cometType.coreColor;
                        speedFactor = cometType.speed;
                        physicsType = 'comet';
                        isComet = true;
                    } else if (particleType < 0.4) { // 15% 核心粒子
                        size = 2.5 + Math.random() * 5;
                        alpha = 0.7 + Math.random() * 0.2;
                        color = {r: 180, g: 180, b: 220};
                        speedFactor = 1.2 + Math.random() * 0.6;
                        physicsType = 'core';
                    } else if (particleType < 0.8) { // 40% 环绕粒子
                        size = 1.5 + Math.random() * 2.5;
                        alpha = 0.6 + Math.random() * 0.2;
                        color = {
                            r: 100 + Math.floor(Math.random() * 120),
                            g: 100 + Math.floor(Math.random() * 120),
                            b: 150 + Math.floor(Math.random() * 100)
                        };
                        speedFactor = 0.8 + Math.random() * 0.5;
                        physicsType = 'orbit';
                    } else { // 20% 外围粒子
                        size = 1 + Math.random() * 1.5;
                        alpha = 0.5 + Math.random() * 0.3;
                        color = {
                            r: 50 + Math.floor(Math.random() * 100),
                            g: 50 + Math.floor(Math.random() * 100),
                            b: 80 + Math.floor(Math.random() * 100)
                        };
                        speedFactor = 0.5 + Math.random() * 0.7;
                        physicsType = 'dust';
                    }
                    
                    // 随机初始旋转角度和旋转方向
                    const angle = Math.random() * Math.PI * 2;
                    const rotationDirection = Math.random() > 0.5 ? 1 : -1;
                    
                    // 添加粒子
                    particles.push({
                        x,
                        y,
                        size,
                        alpha,
                        color,
                        speedFactor,
                        physicsType,
                        isComet,
                        cometType: isComet ? cometTypes[Math.floor(Math.random() * cometTypes.length)] : null,
                        glowFactor: 0.5 + Math.random() * 0.4,
                        pulseSpeed: 0.03 + Math.random() * 0.04,
                        pulsePhase: Math.random() * Math.PI * 2,
                        rotationSpeed: (0.01 + Math.random() * 0.02) * rotationDirection,
                        rotationAngle: angle,
                        rotationRadius: 15 + Math.random() * 40,
                        trailLength: isComet ? 12 + Math.floor(Math.random() * 10) : 5 + Math.floor(Math.random() * 5),
                        trail: [],
                        velocity: { x: 0, y: 0 },
                        acceleration: { x: 0, y: 0 },
                        mass: 0.8 + Math.random() * 1.7,
                        spin: Math.random() * Math.PI * 2,
                        spinSpeed: (Math.random() - 0.5) * 0.08
                    });
                }
            }
            
            // 超级宇宙坍缩效果
            function initSuperCollapseEffect() {
                if (animating) return;
                
                initParticles();
                
                stageTime = 0;
                animating = true;
                
                // 重置坍缩状态
                collapseState = {
                    phase: 'initial',
                    phaseStartTime: 0,
                    phaseProgress: 0,
                    vortexSize: 0,
                    singularitySize: 0,
                    fadeOut: 0
                };
                
                requestAnimationFrame(animateSuperCollapse);
            }
            
            // 超级坍缩动画
            function animateSuperCollapse() {
                if (!animating) return;
                
                // 帧数节流
                frameCounter++;
                if (frameCounter % OPTIMIZATION.FRAME_THROTTLE !== 0) {
                    requestAnimationFrame(animateSuperCollapse);
                    return;
                }
                
                // 清除画布 - 降低每帧清除的透明度以创造拖尾效果
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fillRect(0, 0, collapseCanvas.width, collapseCanvas.height);
                
                // 更新阶段状态
                updateCollapsePhase();
                
                // 计算总体进度
                const totalProgress = Math.min(1, stageTime / maxStageTime);
                
                // 根据不同阶段更新粒子
                updateParticlesBasedOnPhase();
                
                // 更新黑洞效果
                updateCosmicVortexEffect();
                
                // 自适应质量控制
                if (OPTIMIZATION.ADAPTIVE_QUALITY && stageTime % 10 === 0) {
                    const qualityMultiplier = adaptiveQuality.currentQualityMultiplier;
                    if (fps < 30 && qualityMultiplier > 0.5) {
                        adaptiveQuality.currentQualityMultiplier = Math.max(0.5, qualityMultiplier - 0.05);
                    } else if (fps > 50 && qualityMultiplier < 1.0) {
                        adaptiveQuality.currentQualityMultiplier = Math.min(1.0, qualityMultiplier + 0.02);
                    }
                }
                
                // 更新时间
                stageTime++;
                
                // 如果动画还在继续
                if (collapseState.phase !== 'fade' || collapseState.fadeOut < 1) {
                    requestAnimationFrame(animateSuperCollapse);
                } else {
                    // 结束动画
                    animating = false;
                    
                    // 最后清除画布
                    setTimeout(() => {
                        ctx.clearRect(0, 0, collapseCanvas.width, collapseCanvas.height);
                    }, 1000);
                }
            }
            
            // 更新坍缩阶段
            function updateCollapsePhase() {
                const totalProgress = stageTime / maxStageTime;
                
                // 阶段转换逻辑
                if (collapseState.phase === 'initial' && totalProgress > 0.4) {
                    collapseState.phase = 'first_collapse';
                    collapseState.phaseStartTime = stageTime;
                } 
                else if (collapseState.phase === 'first_collapse' && totalProgress > 0.6) {
                    collapseState.phase = 'release';
                    collapseState.phaseStartTime = stageTime;
                }
                else if (collapseState.phase === 'release' && totalProgress > 0.75) {
                    collapseState.phase = 'second_collapse';
                    collapseState.phaseStartTime = stageTime;
                }
                else if (collapseState.phase === 'second_collapse' && totalProgress > 0.9) {
                    collapseState.phase = 'singularity';
                    collapseState.phaseStartTime = stageTime;
                }
                else if (collapseState.phase === 'singularity' && totalProgress >= 1) {
                    collapseState.phase = 'fade';
                    collapseState.phaseStartTime = stageTime;
                }
                
                // 计算当前阶段的进度
                let phaseDuration;
                switch (collapseState.phase) {
                    case 'initial':
                        phaseDuration = maxStageTime * 0.4;
                        collapseState.phaseProgress = stageTime / phaseDuration;
                        break;
                    case 'first_collapse':
                        phaseDuration = maxStageTime * 0.2;
                        collapseState.phaseProgress = (stageTime - collapseState.phaseStartTime) / phaseDuration;
                        break;
                    case 'release':
                        phaseDuration = maxStageTime * 0.15;
                        collapseState.phaseProgress = (stageTime - collapseState.phaseStartTime) / phaseDuration;
                        break;
                    case 'second_collapse':
                        phaseDuration = maxStageTime * 0.15;
                        collapseState.phaseProgress = (stageTime - collapseState.phaseStartTime) / phaseDuration;
                        break;
                    case 'singularity':
                        phaseDuration = maxStageTime * 0.1;
                        collapseState.phaseProgress = (stageTime - collapseState.phaseStartTime) / phaseDuration;
                        break;
                    case 'fade':
                        collapseState.fadeOut = Math.min(1, (stageTime - collapseState.phaseStartTime) / 30);
                        break;
                }
                
                collapseState.phaseProgress = Math.min(1, collapseState.phaseProgress);
            }

            // 根据不同阶段更新粒子
            function updateParticlesBasedOnPhase() {
                // 优化: 批量渲染相似粒子
                let batchedParticles = {
                    core: [],
                    comet: [],
                    orbit: [],
                    dust: []
                };
                
                // 屏幕边界
                const screenPadding = 50;
                const screenBounds = {
                    left: -screenPadding,
                    top: -screenPadding,
                    right: window.innerWidth + screenPadding,
                    bottom: window.innerHeight + screenPadding
                };
                
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    
                    // 计算到坍缩点的距离和角度
                    const dx = collapsePoint.x - p.x;
                    const dy = collapsePoint.y - p.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // 距离影响因子
                    const distanceFactor = Math.max(0.1, Math.min(1, 1 - distance / Math.max(window.innerWidth, window.innerHeight)));
                    
                    // 根据当前阶段计算粒子行为
                    let speed, direction;
                    
                    switch(collapseState.phase) {
                        case 'initial':
                            // 初始加速阶段
                            if (p.physicsType === 'core') {
                                speed = collapseState.phaseProgress * 25 * p.speedFactor * distanceFactor;
                            } else if (p.physicsType === 'comet') {
                                speed = collapseState.phaseProgress * 22 * p.speedFactor * distanceFactor;
                            } else if (p.physicsType === 'orbit') {
                                speed = collapseState.phaseProgress * 18 * p.speedFactor * distanceFactor;
                            } else {
                                speed = collapseState.phaseProgress * 15 * p.speedFactor * distanceFactor;
                            }
                            
                            // 方向朝向中心
                            direction = angle;
                            break;
                            
                        case 'first_collapse':
                            // 第一次坍缩 - 加速向中心
                            const gravityFactor = 1 + collapseState.phaseProgress * 8;
                            
                            if (p.physicsType === 'core') {
                                speed = 15 * p.speedFactor * distanceFactor * gravityFactor;
                            } else if (p.physicsType === 'comet') {
                                speed = 13 * p.speedFactor * distanceFactor * gravityFactor;
                            } else if (p.physicsType === 'orbit') {
                                speed = 10 * p.speedFactor * distanceFactor * gravityFactor;
                            } else {
                                speed = 8 * p.speedFactor * distanceFactor * gravityFactor;
                            }
                            
                            // 添加轻微扭曲
                            if (distance < 300) {
                                const warpFactor = Math.min(1, (300 - distance) / 300) * collapseState.phaseProgress;
                                direction = angle + Math.sin(p.rotationAngle) * warpFactor * 0.4;
                            } else {
                                direction = angle;
                            }
                            break;
                            
                        case 'release':
                            // 释放阶段 - 首先爆发，然后准备二次坍缩
                            if (collapseState.phaseProgress < 0.5) {
                                // 爆发阶段 - 粒子向外喷射
                                const explosionSpeed = 10 + collapseState.phaseProgress * 40;
                                
                                if (distance < collapseState.vortexSize * 2) {
                                    // 内部粒子快速爆发
                                    speed = explosionSpeed * (1 - distance / (collapseState.vortexSize * 2));
                                    direction = angle + Math.PI; // 反方向
                                } else {
                                    // 外部粒子继续围绕旋转
                                    speed = p.speedFactor * 5;
                                    direction = angle + Math.PI/2 * (distance < 500 ? 1 : -1); // 切向运动
                                }
                            } else {
                                // 准备二次坍缩 - 粒子减速并开始旋转
                                const preparationProgress = (collapseState.phaseProgress - 0.5) * 2;
                                
                                if (distance < 500) {
                                    // 内部粒子减速并开始螺旋
                                    speed = p.speedFactor * (5 - preparationProgress * 3);
                                    
                                    // 增加旋转
                                    p.rotationSpeed *= (1 + preparationProgress * 0.1);
                                    p.rotationAngle += p.rotationSpeed * (1 + preparationProgress * 2);
                                    
                                    // 螺旋运动
                                    direction = angle + Math.sin(p.rotationAngle) * Math.PI/4 * preparationProgress;
                                } else {
                                    // 外部粒子开始向内移动
                                    speed = p.speedFactor * 3 * preparationProgress;
                                    direction = angle;
                                }
                            }
                            break;
                            
                        case 'second_collapse':
                            // 二次坍缩 - 比第一次更快、更剧烈
                            const secondGravityFactor = 3 + collapseState.phaseProgress * 15;
                            
                            // 所有粒子都被极速吸入
                            speed = p.speedFactor * distanceFactor * secondGravityFactor * 
                                   (15 + collapseState.phaseProgress * 30);
                            
                            // 添加螺旋扭曲
                            const spiralIntensity = collapseState.phaseProgress * 0.7;
                            direction = angle + Math.sin(p.rotationAngle + collapseState.phaseProgress * 10) * 
                                       spiralIntensity * Math.PI;
                            
                            // 接近中心的粒子透明度降低
                            if (distance < collapseState.vortexSize * 0.8) {
                                p.alpha *= 0.95;
                            }
                            break;
                            
                        case 'singularity':
                            // 奇点形成 - 粒子消失或被拉长成细丝
                            if (distance < 50) {
                                // 中心粒子逐渐消失
                                p.alpha *= 0.9;
                                speed = 0;
                                direction = angle;
                            } else {
                                // 形成环绕奇点的细丝
                                const streamFactor = collapseState.phaseProgress * 6;
                                
                                // 计算离奇点的理想距离
                                const idealRadius = 50 + Math.random() * 200;
                                const radiusDiff = idealRadius - distance;
                                
                                // 调整粒子位置以形成环
                                if (Math.abs(radiusDiff) < 20) {
                                    // 已经在理想环上，围绕奇点旋转
                                    speed = p.speedFactor * 5 * (1 + collapseState.phaseProgress * 3);
                                    direction = angle + Math.PI/2;
                                } else {
                                    // 向理想环移动
                                    speed = Math.abs(radiusDiff) * 0.1;
                                    direction = radiusDiff > 0 ? angle + Math.PI : angle;
                                }
                                
                                // 减小粒子尺寸，形成细丝
                                p.size = Math.max(0.5, p.size * 0.98);
                                
                                // 拉长尾迹
                                p.trailLength = Math.min(30, p.trailLength + collapseState.phaseProgress * 0.5);
                            }
                            break;
                            
                        case 'fade':
                            // 最终消失
                            p.alpha *= 0.95;
                            
                            if (p.alpha < 0.05) {
                                p.alpha = 0;
                            }
                            
                            if (distance < 100) {
                                // 中心粒子直接消失
                                p.alpha = 0;
                            } else {
                                // 外围粒子缓慢向外漂移
                                speed = p.speedFactor * 2;
                                direction = angle + Math.PI; // 远离中心
                            }
                            break;
                            
                        default:
                            // 默认行为
                            speed = 5 * p.speedFactor * distanceFactor;
                            direction = angle;
                    }
                    
                    // 优化: 检查粒子是否在屏幕上
                    if (OPTIMIZATION.OFFSCREEN_PARTICLES) {
                        // 屏幕外的粒子简化处理
                        const isOffscreen = 
                            p.x < screenBounds.left || 
                            p.x > screenBounds.right || 
                            p.y < screenBounds.top || 
                            p.y > screenBounds.bottom;
                        
                        if (isOffscreen && distance > 300) {
                            // 极简化更新 - 只做位置计算但不渲染
                            p.x += Math.cos(direction) * speed;
                            p.y += Math.sin(direction) * speed;
                            continue;
                        }
                    }
                    
                    // 更新位置
                    if (p.alpha > 0.05) {
                        p.x += Math.cos(direction) * speed;
                        p.y += Math.sin(direction) * speed;
                    }
                    
                    // 保存轨迹
                    if (p.trail.length >= p.trailLength) {
                        p.trail.shift();
                    }
                    if (stageTime % Math.max(1, Math.floor(OPTIMIZATION.TRAIL_SKIP / OPTIMIZATION.QUALITY)) === 0) {
                        p.trail.push({x: p.x, y: p.y, alpha: p.alpha});
                    }
                    
                    // 批量处理渲染
                    if (OPTIMIZATION.BATCH_RENDERING && p.alpha > 0.05) {
                        batchedParticles[p.physicsType].push(p);
                    } else {
                        // 渲染单个粒子
                        renderParticle(p);
                    }
                }
                
                // 批量渲染
                if (OPTIMIZATION.BATCH_RENDERING) {
                    Object.values(batchedParticles).forEach(particleGroup => {
                        particleGroup.forEach(p => renderParticle(p));
                    });
                }
            }
            
            // 渲染单个粒子
            function renderParticle(p) {
                const pulseFactor = 0.3 * Math.sin(stageTime * p.pulseSpeed + p.pulsePhase) + 1;
                
                // 绘制尾迹 - 对彗星粒子特别处理
                if (p.trail.length > 1 && p.alpha > 0.05) {
                    if (p.isComet) {
                        // 彗星尾迹 - 降低亮度
                        for (let j = 0; j < p.trail.length - 1; j += Math.max(1, Math.floor(2 / OPTIMIZATION.QUALITY))) {
                            const ratio = j / p.trail.length;
                            const alpha = ratio * p.trail[j].alpha * 0.5 * OPTIMIZATION.BRIGHTNESS_FACTOR;
                            const trailWidth = p.size * (1 - ratio) * 1.5;
                            
                            // 彗星尾迹渐变
                            const gradient = ctx.createLinearGradient(
                                p.trail[j].x, p.trail[j].y,
                                p.trail[j+1].x, p.trail[j+1].y
                            );
                            
                            const tailColor = p.cometType.tailColor;
                            gradient.addColorStop(0, `rgba(${tailColor.r}, ${tailColor.g}, ${tailColor.b}, ${alpha * 0.3})`);
                            gradient.addColorStop(0.5, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.7})`);
                            gradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`);
                            
                            ctx.beginPath();
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = trailWidth;
                            ctx.lineCap = 'round';
                            ctx.moveTo(p.trail[j].x, p.trail[j].y);
                            ctx.lineTo(p.trail[j+1].x, p.trail[j+1].y);
                            ctx.stroke();
                        }
                    } else {
                        // 普通粒子尾迹 - 降低亮度
                        for (let j = 0; j < p.trail.length - 1; j += Math.max(1, Math.floor(3 / OPTIMIZATION.QUALITY))) {
                            const ratio = j / p.trail.length;
                            const alpha = ratio * p.trail[j].alpha * 0.3 * OPTIMIZATION.BRIGHTNESS_FACTOR;
                            
                            // 尾迹渐变
                            const gradient = ctx.createLinearGradient(
                                p.trail[j].x, p.trail[j].y,
                                p.trail[j+1].x, p.trail[j+1].y
                            );
                            
                            const r = Math.min(200, p.color.r + 30);
                            const g = Math.min(200, p.color.g + 30);
                            const b = Math.min(200, p.color.b + 30);
                            
                            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.2})`);
                            gradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`);
                            
                            ctx.beginPath();
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = p.size * 0.6 * ratio;
                            ctx.lineCap = 'round';
                            ctx.moveTo(p.trail[j].x, p.trail[j].y);
                            ctx.lineTo(p.trail[j+1].x, p.trail[j+1].y);
                            ctx.stroke();
                        }
                    }
                }
                
                // 只绘制可见粒子
                if (p.alpha > 0.05) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    
                    // 光晕效果 - 降低亮度
                    const glowSize = p.size * 3 * p.glowFactor * pulseFactor * OPTIMIZATION.QUALITY;
                    const glowGradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize);
                    glowGradient.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.5 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                    glowGradient.addColorStop(0.5, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.2 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                    glowGradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
                    
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 粒子核心 - 降低亮度
                    const coreSize = p.size * pulseFactor * OPTIMIZATION.QUALITY;
                    
                    if (p.isComet) {
                        // 彗星粒子 - 更清晰的形状
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.spin);
                        
                        // 彗星核心
                        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize);
                        coreGradient.addColorStop(0, `rgba(180, 180, 200, ${p.alpha * 0.7 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                        coreGradient.addColorStop(0.3, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.6 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                        coreGradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.4 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                        
                        ctx.fillStyle = coreGradient;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, coreSize, coreSize * 0.6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    } else {
                        // 普通粒子
                        const coreGradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, coreSize);
                        coreGradient.addColorStop(0, `rgba(180, 180, 200, ${p.alpha * 0.6 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                        coreGradient.addColorStop(0.3, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.5 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                        coreGradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * 0.4 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                        
                        ctx.fillStyle = coreGradient;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, coreSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }

            // 更新宇宙漩涡效果
            function updateCosmicVortexEffect() {
                // 根据当前阶段计算宇宙漩涡效果
                let vortexSize = 0;
                let vortexProgress = 0;
                
                switch (collapseState.phase) {
                    case 'initial':
                        // 初始阶段没有宇宙漩涡
                        return;
                        
                    case 'first_collapse':
                        // 第一次坍缩，宇宙漩涡形成
                        vortexProgress = collapseState.phaseProgress;
                        vortexSize = 50 + vortexProgress * 200;
                        break;
                        
                    case 'release':
                        // 释放阶段，宇宙漩涡扩张然后准备二次坍缩
                        if (collapseState.phaseProgress < 0.5) {
                            // 释放初期 - 扩张
                            vortexProgress = 0.8 + collapseState.phaseProgress * 0.4;
                            vortexSize = 250 + collapseState.phaseProgress * 300;
                        } else {
                            // 释放后期 - 扭曲
                            vortexProgress = 1 - (collapseState.phaseProgress - 0.5) * 0.2;
                            vortexSize = 400 - (collapseState.phaseProgress - 0.5) * 100;
                        }
                        break;
                        
                    case 'second_collapse':
                        // 二次坍缩，宇宙漩涡迅速收缩
                        vortexProgress = 0.8 - collapseState.phaseProgress * 0.6;
                        vortexSize = 350 - collapseState.phaseProgress * 300;
                        
                        // 添加二次坍缩特效 - 时空撕裂
                        renderSpacetimeTears();
                        break;
                        
                    case 'singularity':
                        // 奇点形成，宇宙漩涡变为一个点
                        vortexProgress = 0.2 * (1 - collapseState.phaseProgress);
                        vortexSize = 50 * (1 - collapseState.phaseProgress);
                        
                        // 奇点效果
                        renderSingularityEffect();
                        break;
                        
                    case 'fade':
                        // 最终消失
                        vortexProgress = 0.1 * (1 - collapseState.fadeOut);
                        vortexSize = 5 * (1 - collapseState.fadeOut);
                        
                        // 奇点最终闪烁然后消失
                        renderFinalSingularityEffect();
                        break;
                }
                
                // 保存宇宙漩涡尺寸供其他函数使用
                collapseState.vortexSize = vortexSize;
                
                // 绘制宇宙漩涡
                createCosmicVortexEffect(
                    ctx, 
                    collapsePoint.x, 
                    collapsePoint.y, 
                    vortexSize,
                    vortexProgress
                );
                
                // 绘制扭曲效果
                if (vortexSize > 50) {
                    renderDistortionEffect(vortexSize, vortexProgress);
                }
            }
            
            // 渲染时空撕裂效果
            function renderSpacetimeTears() {
                const tearCount = 12;
                const tearProgress = collapseState.phaseProgress;
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                for (let i = 0; i < tearCount; i++) {
                    const angle = (i / tearCount) * Math.PI * 2 + tearProgress * 3;
                    const tearLength = 300 + tearProgress * 500;
                    
                    // 创建闪电状的撕裂
                    ctx.beginPath();
                    
                    let currentX = collapsePoint.x;
                    let currentY = collapsePoint.y;
                    const segments = 5 + Math.floor(tearProgress * 7);
                    
                    ctx.moveTo(currentX, currentY);
                    
                    for (let j = 1; j <= segments; j++) {
                        const segmentProgress = j / segments;
                        const segmentAngle = angle + (Math.random() - 0.5) * 1.2 * tearProgress;
                        const segmentLength = tearLength * segmentProgress;
                        
                        // 增加随机偏移，形成闪电状
                        const jitter = tearProgress * 50 * (Math.random() - 0.5) * segmentProgress;
                        
                        currentX = collapsePoint.x + Math.cos(segmentAngle) * segmentLength + 
                                 Math.cos(segmentAngle + Math.PI/2) * jitter;
                        currentY = collapsePoint.y + Math.sin(segmentAngle) * segmentLength + 
                                 Math.sin(segmentAngle + Math.PI/2) * jitter;
                        
                        ctx.lineTo(currentX, currentY);
                    }
                    
                    // 撕裂光芒渐变
                    const tearGradient = ctx.createLinearGradient(
                        collapsePoint.x, collapsePoint.y, 
                        currentX, currentY
                    );
                    
                    tearGradient.addColorStop(0, `rgba(20, 5, 50, ${0.2 * tearProgress})`);
                    tearGradient.addColorStop(0.3, `rgba(5, 15, 40, ${0.15 * tearProgress})`);
                    tearGradient.addColorStop(0.7, `rgba(0, 5, 20, ${0.1 * tearProgress})`);
                    tearGradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    
                    ctx.strokeStyle = tearGradient;
                    ctx.lineWidth = 2 + tearProgress * 3;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // 渲染奇点效果
            function renderSingularityEffect() {
                const singularityProgress = collapseState.phaseProgress;
                const pulseSize = 10 + Math.sin(singularityProgress * Math.PI * 10) * 5;
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                // 奇点核心
                const coreGradient = ctx.createRadialGradient(
                    collapsePoint.x, collapsePoint.y, 0,
                    collapsePoint.x, collapsePoint.y, pulseSize
                );
                
                coreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 * (1 - singularityProgress * 0.5)})`);
                coreGradient.addColorStop(0.3, `rgba(100, 150, 255, ${0.5 * (1 - singularityProgress * 0.5)})`);
                coreGradient.addColorStop(0.7, `rgba(50, 0, 100, ${0.3 * (1 - singularityProgress * 0.5)})`);
                coreGradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(collapsePoint.x, collapsePoint.y, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 最后的能量喷射
                const jetCount = 6;
                const jetLength = 80 + singularityProgress * 400;
                
                for (let i = 0; i < jetCount; i++) {
                    const angle = (i / jetCount) * Math.PI * 2 + singularityProgress * 5;
                    
                    const jetGradient = ctx.createLinearGradient(
                        collapsePoint.x, collapsePoint.y,
                        collapsePoint.x + Math.cos(angle) * jetLength,
                        collapsePoint.y + Math.sin(angle) * jetLength
                    );
                    
                    jetGradient.addColorStop(0, `rgba(180, 180, 255, ${0.4 * (1 - singularityProgress * 0.7)})`);
                    jetGradient.addColorStop(0.3, `rgba(80, 60, 150, ${0.3 * (1 - singularityProgress * 0.7)})`);
                    jetGradient.addColorStop(0.7, `rgba(40, 0, 80, ${0.2 * (1 - singularityProgress * 0.7)})`);
                    jetGradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = jetGradient;
                    ctx.lineWidth = 3 + Math.sin(singularityProgress * Math.PI * 8 + i) * 2;
                    ctx.moveTo(collapsePoint.x, collapsePoint.y);
                    ctx.lineTo(
                        collapsePoint.x + Math.cos(angle) * jetLength,
                        collapsePoint.y + Math.sin(angle) * jetLength
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // 渲染最终消失效果
            function renderFinalSingularityEffect() {
                const fadeOutProgress = collapseState.fadeOut;
                
                if (fadeOutProgress < 0.3) {
                    // 最终闪烁
                    const flashIntensity = Math.sin(fadeOutProgress * Math.PI * 20) * (1 - fadeOutProgress / 0.3);
                    
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    
                    const flashGradient = ctx.createRadialGradient(
                        collapsePoint.x, collapsePoint.y, 0,
                        collapsePoint.x, collapsePoint.y, 50 + flashIntensity * 100
                    );
                    
                    flashGradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * flashIntensity})`);
                    flashGradient.addColorStop(0.2, `rgba(150, 200, 255, ${0.6 * flashIntensity})`);
                    flashGradient.addColorStop(0.5, `rgba(80, 50, 180, ${0.4 * flashIntensity})`);
                    flashGradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    
                    ctx.fillStyle = flashGradient;
                    ctx.beginPath();
                    ctx.arc(collapsePoint.x, collapsePoint.y, 50 + flashIntensity * 100, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
            
            // 渲染空间扭曲效果
            function renderDistortionEffect(size, progress) {
                const distortionSize = size * 2;
                const distortionStrength = progress * 30;
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                // 创建扭曲渐变
                const distortionGradient = ctx.createRadialGradient(
                    collapsePoint.x, collapsePoint.y, 0,
                    collapsePoint.x, collapsePoint.y, distortionSize
                );
                distortionGradient.addColorStop(0, `rgba(0, 40, 80, ${0.06 * progress})`);
                distortionGradient.addColorStop(0.3, `rgba(20, 0, 50, ${0.03 * progress})`);
                distortionGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                // 应用扭曲效果
                for (let i = 0; i < 3; i++) {
                    const offsetAngle = (i / 3) * Math.PI * 2 + stageTime * 0.02;
                    const offsetX = Math.cos(offsetAngle) * distortionStrength;
                    const offsetY = Math.sin(offsetAngle) * distortionStrength;
                    
                    ctx.fillStyle = distortionGradient;
                    ctx.beginPath();
                    ctx.arc(
                        collapsePoint.x + offsetX,
                        collapsePoint.y + offsetY,
                        distortionSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            // 闪光效果
            function createFlashEffect(ctx, canvas, x, y, size) {
                let alpha = 0.5; // 降低初始亮度
                let currentSize = size * 0.1;
                const maxSize = size;
                const growthSpeed = size * 0.15;
                const color = Math.random() > 0.5 ? 
                    `rgba(0, 70, 120, ${alpha})` : 
                    `rgba(80, 20, 100, ${alpha})`;
                
                function animateFlash() {
                    if (alpha <= 0) return;
                    
                    // 更新大小和透明度
                    currentSize = Math.min(maxSize, currentSize + growthSpeed);
                    alpha -= 0.02;
                    
                    // 绘制闪光
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    
                    const gradient = ctx.createRadialGradient(
                        x, y, 0,
                        x, y, currentSize
                    );
                    gradient.addColorStop(0, `rgba(120, 120, 180, ${alpha * 0.5 * OPTIMIZATION.BRIGHTNESS_FACTOR})`);
                    gradient.addColorStop(0.3, color.replace(')', `, ${alpha * 0.4 * OPTIMIZATION.BRIGHTNESS_FACTOR})`));
                    gradient.addColorStop(0.6, color.replace(')', `, ${alpha * 0.15 * OPTIMIZATION.BRIGHTNESS_FACTOR})`));
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    requestAnimationFrame(animateFlash);
                }
                
                animateFlash();
            }

            // 窗口大小改变时重设画布尺寸
            window.addEventListener('resize', () => {
                collapseCanvas.width = window.innerWidth * dpr;
                collapseCanvas.height = window.innerHeight * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            });

            // 返回初始化函数供外部调用
            return initSuperCollapseEffect;
        }

        // ====== 添加事件监听器 ======
        document.addEventListener('DOMContentLoaded', function() {
            // 启动three.js超级宇宙背景
            let destroyThreeJSBG = createThreeJSUniverseBackground();
            let collapseEffectStarted = false;

            // 移除所有文本元素，保持空容器
            const container = document.querySelector('.container');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            // 监听鼠标左键单击
            document.addEventListener('mousedown', function(e) {
                if (e.button === 2 && !collapseEffectStarted) {
                    collapseEffectStarted = true;
                    // 销毁three.js背景
                    if (destroyThreeJSBG) destroyThreeJSBG.destroy(); // 调用返回的destroy方法
                    // 启动终极宇宙坍缩特效
                    const triggerSuperCollapseEffect = createSuperUniverseCollapseEffect();
                    triggerSuperCollapseEffect();
                } else if (e.button === 1) { // 鼠标中键 (button === 1)
                    // 激活七彩斑斓的渐变电流
                    if (destroyThreeJSBG && destroyThreeJSBG.activateGradientCurrentEffect) {
                        destroyThreeJSBG.activateGradientCurrentEffect();
                    }
                }
            });
        });

        // 彩色粒子星光背景效果
        function createStarlightBackground() {
            const canvas = document.getElementById('starlight-background');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            const ctx = canvas.getContext('2d', { alpha: true });
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            // 星星分层：近景巨星、主星、远景暗星、星团
            const layers = [
                { count: Math.floor(window.innerWidth * window.innerHeight / 1800), size: [2.5, 4.5], alpha: [0.7, 1], color: 'main' }, // 巨星
                { count: Math.floor(window.innerWidth * window.innerHeight / 1200), size: [1.2, 2.5], alpha: [0.4, 0.8], color: 'main' }, // 主星
                { count: Math.floor(window.innerWidth * window.innerHeight / 800), size: [0.5, 1.2], alpha: [0.15, 0.4], color: 'dim' }, // 暗星
                { count: Math.floor(window.innerWidth * window.innerHeight / 6000), size: [8, 18], alpha: [0.12, 0.22], color: 'cluster' } // 星团
            ];
            // 星云/银河色板
            const nebulaColors = [
                { r: 120, g: 80, b: 220 }, // 紫
                { r: 70, g: 180, b: 255 }, // 蓝
                { r: 255, g: 180, b: 80 }, // 橙
                { r: 80, g: 255, b: 200 }, // 青
                { r: 255, g: 80, b: 180 }  // 粉
            ];
            // 主星色板
            const starColors = [
                { r: 255, g: 255, b: 255 }, // 白
                { r: 180, g: 220, b: 255 }, // 蓝白
                { r: 255, g: 220, b: 180 }, // 黄白
                { r: 255, g: 180, b: 220 }, // 粉白
                { r: 180, g: 255, b: 220 }, // 青白
                { r: 255, g: 200, b: 80 },  // 橙
                { r: 120, g: 80, b: 220 },  // 紫
                { r: 70, g: 200, b: 150 }   // 青
            ];
            // 暗星色板
            const dimColors = [
                { r: 80, g: 100, b: 180 },
                { r: 120, g: 80, b: 120 },
                { r: 80, g: 120, b: 80 },
                { r: 100, g: 80, b: 120 }
            ];
            // 星团色板
            const clusterColors = [
                { r: 255, g: 255, b: 200 },
                { r: 200, g: 220, b: 255 },
                { r: 255, g: 220, b: 255 }
            ];
            // 星星数据
            const stars = [];
            // 星团数据
            const clusters = [];
            // 流星数据
            let meteors = [];

            // 初始化星星
            function initStars() {
                stars.length = 0;
                clusters.length = 0;
                // 星团先生成中心
                for (let i = 0; i < layers[3].count; i++) {
                    const cx = Math.random() * window.innerWidth;
                    const cy = Math.random() * window.innerHeight;
                    const csize = layers[3].size[0] + Math.random() * (layers[3].size[1] - layers[3].size[0]);
                    const color = clusterColors[Math.floor(Math.random() * clusterColors.length)];
                    clusters.push({ x: cx, y: cy, size: csize, color });
                    // 星团内小星星
                    const subCount = 10 + Math.floor(Math.random() * 20);
                    for (let j = 0; j < subCount; j++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * csize * 2.5;
                        const sx = cx + Math.cos(angle) * dist;
                        const sy = cy + Math.sin(angle) * dist;
                        const size = 0.5 + Math.random() * 1.2;
                        stars.push({
                            x: sx, y: sy, size, alpha: 0.08 + Math.random() * 0.12,
                            color: color, blinkSpeed: 0.001 + Math.random() * 0.01, blinkPhase: Math.random() * Math.PI * 2, drift: { x: 0, y: 0 }
                        });
                    }
                }
                // 其他层星星
                layers.forEach((layer, idx) => {
                    if (idx === 3) return; // 星团已处理
                    for (let i = 0; i < layer.count; i++) {
                        let color;
                        if (layer.color === 'main') color = starColors[Math.floor(Math.random() * starColors.length)];
                        else color = dimColors[Math.floor(Math.random() * dimColors.length)];
                        const size = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                        const alpha = layer.alpha[0] + Math.random() * (layer.alpha[1] - layer.alpha[0]);
                        stars.push({
                            x: Math.random() * window.innerWidth,
                            y: Math.random() * window.innerHeight,
                            size,
                            alpha,
                            color,
                            blinkSpeed: 0.001 + Math.random() * 0.012,
                            blinkPhase: Math.random() * Math.PI * 2,
                            drift: {
                                x: (Math.random() - 0.5) * (0.08 + 0.12 * (idx + 1)),
                                y: (Math.random() - 0.5) * (0.08 + 0.12 * (idx + 1))
                            }
                        });
                    }
                });
            }

            // 初始化流星
            function spawnMeteor() {
                // 随机起点在屏幕上方或左侧
                const fromTop = Math.random() > 0.5;
                const x = fromTop ? Math.random() * window.innerWidth : -40;
                const y = fromTop ? -40 : Math.random() * window.innerHeight;
                const angle = fromTop ? Math.PI / 2 + (Math.random() - 0.5) * 0.5 : Math.PI / 4 + (Math.random() - 0.5) * 0.3;
                const speed = 8 + Math.random() * 8;
                const length = 120 + Math.random() * 80;
                const color = starColors[Math.floor(Math.random() * starColors.length)];
                meteors.push({ x, y, angle, speed, length, color, alpha: 0.7 + Math.random() * 0.3 });
            }

            // 绘制银河/星云
            function renderNebula() {
                for (let i = 0; i < 3; i++) {
                    const cx = window.innerWidth * (0.2 + 0.6 * Math.random());
                    const cy = window.innerHeight * (0.2 + 0.6 * Math.random());
                    const r1 = window.innerWidth * (0.18 + 0.18 * Math.random());
                    const r2 = r1 * (1.2 + Math.random() * 0.8);
                    const color = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                    const alpha = 0.10 + Math.random() * 0.10;
                    const g = ctx.createRadialGradient(cx, cy, r1 * 0.2, cx, cy, r2);
                    g.addColorStop(0, `rgba(${color.r},${color.g},${color.b},${alpha})`);
                    g.addColorStop(0.5, `rgba(${color.r},${color.g},${color.b},${alpha * 0.5})`);
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.save();
                    ctx.globalAlpha = 1;
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.arc(cx, cy, r2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                }
                // 银河带
                ctx.save();
                ctx.globalAlpha = 0.18;
                ctx.globalCompositeOperation = 'lighter';
                const gx = window.innerWidth * 0.5;
                const gy = window.innerHeight * (0.45 + Math.random() * 0.1);
                const gr = window.innerWidth * 0.6;
                const g = ctx.createLinearGradient(gx - gr, gy, gx + gr, gy);
                g.addColorStop(0, 'rgba(80,120,255,0.08)');
                g.addColorStop(0.2, 'rgba(180,120,255,0.18)');
                g.addColorStop(0.5, 'rgba(255,255,255,0.22)');
                g.addColorStop(0.8, 'rgba(120,220,255,0.18)');
                g.addColorStop(1, 'rgba(80,120,255,0.08)');
                ctx.beginPath();
                ctx.ellipse(gx, gy, gr, gr * 0.18, Math.PI / 8, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = g;
                ctx.fill();
                ctx.restore();
            }

            // 绘制星空
            function renderStars() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                renderNebula();
                // 星团
                clusters.forEach(cluster => {
                    const g = ctx.createRadialGradient(cluster.x, cluster.y, 0, cluster.x, cluster.y, cluster.size * 2.5);
                    g.addColorStop(0, `rgba(${cluster.color.r},${cluster.color.g},${cluster.color.b},0.18)`);
                    g.addColorStop(0.5, `rgba(${cluster.color.r},${cluster.color.g},${cluster.color.b},0.08)`);
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.arc(cluster.x, cluster.y, cluster.size * 2.5, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fillStyle = g;
                    ctx.fill();
                    ctx.restore();
                });
                // 星星
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const now = performance.now() * 0.001;
                stars.forEach(star => {
                    const blink = 0.7 + 0.3 * Math.sin(now * star.blinkSpeed * 5 + star.blinkPhase);
                    star.x += star.drift.x;
                    star.y += star.drift.y;
                    if (star.x < -10) star.x = window.innerWidth + 10;
                    if (star.x > window.innerWidth + 10) star.x = -10;
                    if (star.y < -10) star.y = window.innerHeight + 10;
                    if (star.y > window.innerHeight + 10) star.y = -10;
                    const g = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.size * 2.2);
                    g.addColorStop(0, `rgba(${star.color.r},${star.color.g},${star.color.b},${star.alpha * blink})`);
                    g.addColorStop(0.8, `rgba(${star.color.r},${star.color.g},${star.color.b},${star.alpha * 0.2 * blink})`);
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size * 2.2, 0, Math.PI * 2);
                    ctx.fillStyle = g;
                    ctx.fill();
                });
                ctx.restore();
                // 流星
                meteors.forEach((m, idx) => {
                    ctx.save();
                    ctx.globalAlpha = m.alpha;
                    ctx.globalCompositeOperation = 'lighter';
                    const tx = m.x - Math.cos(m.angle) * m.length;
                    const ty = m.y - Math.sin(m.angle) * m.length;
                    const grad = ctx.createLinearGradient(m.x, m.y, tx, ty);
                    grad.addColorStop(0, `rgba(${m.color.r},${m.color.g},${m.color.b},1)`);
                    grad.addColorStop(0.7, `rgba(${m.color.r},${m.color.g},${m.color.b},0.3)`);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 2.2 + Math.random() * 1.2;
                    ctx.beginPath();
                    ctx.moveTo(m.x, m.y);
                    ctx.lineTo(tx, ty);
                    ctx.stroke();
                    ctx.restore();
                    // 更新流星位置
                    m.x += Math.cos(m.angle) * m.speed;
                    m.y += Math.sin(m.angle) * m.speed;
                    m.alpha *= 0.97;
                    if (m.x < -100 || m.x > window.innerWidth + 100 || m.y > window.innerHeight + 100 || m.alpha < 0.05) {
                        meteors.splice(idx, 1);
                    }
                });
                // 随机生成流星
                if (Math.random() < 0.012 && meteors.length < 3) {
                    spawnMeteor();
                }
                requestAnimationFrame(renderStars);
            }

            // 窗口大小改变时重设画布尺寸
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                initStars();
            });
            // 初始化并开始动画
            initStars();
            renderStars();
        }

        // ====== three.js 超级宇宙背景 ======
        function createThreeJSUniverseBackground() {
            // 移除原有canvas背景
            const oldCanvas = document.getElementById('starlight-background');
            if (oldCanvas) oldCanvas.style.display = 'none';

            // 创建three.js渲染器
            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setClearColor(0x000010, 1);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'fixed';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100vw';
            renderer.domElement.style.height = '100vh';
            renderer.domElement.style.zIndex = '9990';
            renderer.domElement.id = 'threejs-universe-bg';
            document.body.appendChild(renderer.domElement);

            // 创建场景
            const scene = new THREE.Scene();

            // 相机
            const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(0, 0, 1200);

            // 添加环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 3); // 柔和的白光，强度稍高
            scene.add(ambientLight);

            // 添加点光源，模拟远处的恒星或星云发光
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 2000); // 亮白光，强度适中
            pointLight.position.set(500, 500, 1500);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0xffccaa, 1, 1500); // 暖色光
            pointLight2.position.set(-800, -600, -1000);
            scene.add(pointLight2);

            // 定义一个变量来控制线条宽度
            let currentLineWidth = 2; // 初始线条宽度

            // 渐变电流效果相关变量
            let currentEffectActive = false;
            let currentEffectTimer = 0;
            const CURRENT_EFFECT_DURATION = 360; // 效果持续时间，增加到6秒 (6秒 @ 60 FPS)

            // 添加鼠标滚轮事件监听器
            window.addEventListener('wheel', (event) => {
                // 根据滚轮方向调整线条宽度
                currentLineWidth -= event.deltaY * 0.005; // 调整敏感度
                // 限制线条宽度在合理范围内
                currentLineWidth = Math.max(0.5, Math.min(10.0, currentLineWidth)); 
                
                // 更新所有流线和流星的线条宽度和透明度
                fleetParticles.forEach(fleet => {
                    if (fleet.material) {
                        fleet.material.linewidth = currentLineWidth;
                        fleet.material.opacity = Math.min(1, 0.5 + currentLineWidth * 0.05); // 根据线条宽度调整透明度，影响密度
                    }
                });
                meteors.forEach(meteor => {
                    if (meteor.material) {
                        meteor.material.linewidth = currentLineWidth; // corrected typo
                        meteor.material.opacity = Math.min(1, 0.6 + currentLineWidth * 0.04); // 根据线条宽度调整透明度，影响密度
                    }
                });
            });

            // 3D立体星空 InstancedMesh
            const starCount = 10000;
            const baseGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const starsMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                specular: 0x111111,
                shininess: 30,
                transparent: true,
                opacity: 0.9,
                vertexColors: true
            });
            const stars = new THREE.InstancedMesh(baseGeometry, starsMaterial, starCount);
            stars.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            const color = new THREE.Color();
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const scale = new THREE.Vector3();
            const colors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                // 随机分布在3000立方空间
                position.set(
                    (Math.random() - 0.5) * 3000,
                    (Math.random() - 0.5) * 3000,
                    (Math.random() - 0.5) * 3000
                );
                // 星星尺寸0.3~1.4
                const size = Math.random() * 1.1 + 0.3;
                scale.set(size, size, size);
                // 超级无敌丰富的七彩渐变色彩（HSL色相全覆盖+空间渐变+多频率扰动）
                const baseHue = (i / starCount + (position.x + 1500) / 6000 + (position.y + 1500) / 6000 + (position.z + 1500) / 6000) % 1.0;
                const extra = Math.sin(i * 0.618) * 0.08 + Math.sin(i * 2.17) * 0.06 + Math.sin(i * 5.13) * 0.04;
                const hue = (baseHue + extra + Math.random() * 0.04) % 1.0;
                const saturation = 0.85 + 0.15 * Math.sin(i * 1.77 + size * 2.3) + 0.1 * Math.sin(position.x * 0.002 + position.y * 0.002);
                const lightness = 0.68 + 0.22 * Math.sin(i * 2.33 + size * 1.7) + 0.08 * Math.sin(position.z * 0.003);
                color.setHSL(hue, Math.min(1, Math.max(0.7, saturation)), Math.min(1, Math.max(0.5, lightness)));
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                matrix.compose(position, new THREE.Quaternion(), scale);
                stars.setMatrixAt(i, matrix);
                stars.setColorAt(i, color);
            }
            stars.geometry.setAttribute('color', new THREE.InstancedBufferAttribute(colors, 3));
            scene.add(stars);

            // 银河/星云
            const STAR_COLORS = [0xffffff, 0xffe9c6, 0xbadfff, 0xffb6ff, 0x80ffd4, 0xffe080, 0x8c7aff, 0x00eaff, 0xff6b6b];
            for (let i = 0; i < 4; i++) {
                const nebulaGeometry = new THREE.SphereGeometry(400 + Math.random() * 300, 32, 32);
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: STAR_COLORS[Math.floor(Math.random() * STAR_COLORS.length)],
                    transparent: true,
                    opacity: 0.08 + Math.random() * 0.08,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.set(
                    (Math.random() - 0.5) * 1200,
                    (Math.random() - 0.5) * 800,
                    (Math.random() - 0.5) * 1200
                );
                nebula.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(nebula);
            }

            // 星际穿梭流线
            const FLEET_COUNT = 18;
            const fleetParticles = [];
            for (let i = 0; i < FLEET_COUNT; i++) {
                const fleetGeo = new THREE.BufferGeometry();
                const fleetLen = 80 + Math.random() * 120;
                const fleetPos = [];
                const fleetColors = [];
                for (let j = 0; j < fleetLen; j++) {
                    const t = j / fleetLen;
                    const angle = Math.PI * 2 * t + Math.random() * Math.PI * 2;
                    // Original r calculation: const r = 200 + Math.random() * 800 + t * 1200;
                    // To make it more complex 3D:
                    const baseRadius = 200 + t * 1000; // Base radius increasing with t
                    const turbulentRadius = baseRadius + Math.sin(j * 0.2 + i * 0.5) * 150 + Math.cos(j * 0.3 + i * 0.7) * 100; // Adding turbulence
                    const xOffset = Math.sin(j * 0.15 + i * 0.8) * 100 * (1 - Math.abs(t - 0.5)); // Oscillations
                    const yOffset = Math.cos(j * 0.18 + i * 0.9) * 100 * (1 - Math.abs(t - 0.5)); // Oscillations
                    const zOffset = Math.sin(j * 0.22 + i * 0.7) * 200 * (1 - Math.abs(t - 0.5)); // Oscillations

                    fleetPos.push(
                        Math.cos(angle) * turbulentRadius + xOffset,
                        Math.sin(angle) * turbulentRadius * (0.5 + Math.random() * 0.5) + yOffset, // Random factor for Y
                        (Math.random() - 0.5) * 1200 + t * 800 + zOffset + Math.sin(j * 0.1 + i * 0.6) * 100 // Add another Z oscillation
                    );
                    // 七彩渐变色：色相从0~1，和星空风格适配
                    const color = new THREE.Color();
                    const baseHue = (i / FLEET_COUNT + t * 0.5 + Math.sin(j * 0.13 + i) * 0.08) % 1.0;
                    const hueOffset1 = Math.sin(j * 0.23 + i * 0.5) * 0.1;
                    const hueOffset2 = Math.sin(j * 0.07 + i * 0.3) * 0.05;
                    const hue = (baseHue + hueOffset1 + hueOffset2 + Math.random() * 0.03) % 1.0;

                    const saturation = 0.85 + 0.15 * Math.sin(j * 0.19 + i * 0.7) + 0.1 * Math.sin(t * 2.5 + i * 0.4);
                    const lightness = 0.6 + 0.15 * Math.sin(j * 0.15 + i * 0.6) + 0.08 * Math.sin(t * 3.0 + i * 0.2);

                    color.setHSL(hue, Math.min(1, Math.max(0.7, saturation)), Math.min(1, Math.max(0.5, lightness)));
                    fleetColors.push(color.r, color.g, color.b);
                }
                fleetGeo.setAttribute('position', new THREE.Float32BufferAttribute(fleetPos, 3));
                fleetGeo.setAttribute('color', new THREE.Float32BufferAttribute(fleetColors, 3));
                const fleetMat = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    linewidth: currentLineWidth, // 使用动态线条宽度
                    transparent: true,
                    opacity: 0.7 + Math.random() * 0.3,
                    blending: THREE.AdditiveBlending
                });
                const fleet = new THREE.Line(fleetGeo, fleetMat);
                fleetParticles.push(fleet);
                scene.add(fleet);
            }

            // 动态星际穿梭粒子（流星）
            const METEOR_COUNT = 8;
            const meteors = [];
            for (let i = 0; i < METEOR_COUNT; i++) {
                const meteorGeo = new THREE.BufferGeometry();
                const meteorLen = 32 + Math.floor(Math.random() * 32);
                const meteorPos = new Float32Array(meteorLen * 3);
                const meteorColors = new Float32Array(meteorLen * 3);
                const baseHue = Math.random();
                for (let j = 0; j < meteorLen; j++) {
                    const t = j / meteorLen;
                    // 轨迹色彩渐变
                    const color = new THREE.Color();
                    const hueOffset1 = Math.sin(j * 0.31 + baseHue * 0.5) * 0.12;
                    const hueOffset2 = Math.sin(j * 0.09 + baseHue * 0.7) * 0.07;
                    const hue = (baseHue + t * 0.5 + hueOffset1 + hueOffset2 + Math.random() * 0.04) % 1.0;

                    const saturation = 0.9 + 0.1 * Math.sin(j * 0.27 + baseHue * 0.6) + 0.05 * Math.sin(t * 3.5 + baseHue * 0.8);
                    const lightness = 0.7 - t * 0.3 + 0.1 * Math.sin(j * 0.22 + baseHue * 0.4) + 0.05 * Math.sin(t * 4.0 + baseHue * 0.9);

                    color.setHSL(hue, Math.min(1, Math.max(0.8, saturation)), Math.min(1, Math.max(0.4, lightness)));
                    meteorColors[j * 3] = color.r;
                    meteorColors[j * 3 + 1] = color.g;
                    meteorColors[j * 3 + 2] = color.b;
                }
                meteorGeo.setAttribute('position', new THREE.BufferAttribute(meteorPos, 3));
                meteorGeo.setAttribute('color', new THREE.BufferAttribute(meteorColors, 3));
                const meteorMat = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    linewidth: currentLineWidth, // 使用动态线条宽度
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                const meteor = new THREE.Line(meteorGeo, meteorMat);
                meteor.userData = {
                    speed: 12 + Math.random() * 18,
                    base: [
                        (Math.random() - 0.5) * 1800,
                        (Math.random() - 0.5) * 1200,
                        -1800 + Math.random() * 1200
                    ],
                    dir: [
                        (Math.random() - 0.5) * 0.5, // Wider range for initial X direction
                        (Math.random() - 0.5) * 0.5, // Wider range for initial Y direction
                        0.8 + Math.random() * 0.8 // Increased range for Z direction (still mostly forward)
                    ]
                };
                meteors.push(meteor);
                scene.add(meteor);
            }

            // ====== 黑色/深色星辰粒子划过屏幕 ======
            const BLACK_STAR_COUNT = 40;
            const blackStars = [];
            for (let i = 0; i < BLACK_STAR_COUNT; i++) {
                const geo = new THREE.SphereGeometry(1.2 + Math.random() * 2.2, 8, 8);
                // 更丰富的七彩渐变色彩：色相随idx、空间、时间多频率扰动，亮度饱和度动态变化
                const baseHue = (i / BLACK_STAR_COUNT + Math.random() * 0.5 + (Math.random() - 0.5) * 0.2) % 1.0;
                const extra = Math.sin(i * 0.618) * 0.12 + Math.sin(i * 2.17) * 0.09 + Math.sin(i * 5.13) * 0.07;
                const timeSeed = performance.now() * 0.0001 + Math.random() * 0.1;
                const hue = (baseHue + extra + Math.sin(i + timeSeed) * 0.09 + Math.random() * 0.06) % 1.0;
                const saturation = 0.98 + 0.18 * Math.sin(i * 1.77 + geo.parameters.radius * 2.3) + 0.12 * Math.sin(i * 0.13 + geo.parameters.radius * 0.7);
                const lightness = 0.72 + 0.28 * Math.sin(i * 2.33 + geo.parameters.radius * 1.7) + 0.18 * Math.sin(i * 0.23);
                const color = new THREE.Color();
                color.setHSL(hue, Math.min(1, Math.max(0.85, saturation)), Math.min(1, Math.max(0.55, lightness)));
                const mat = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.92 + Math.random() * 0.08, // 更高亮度和透明度
                    shininess: 30, // 添加光泽度
                    specular: 0x333333 // 添加镜面反射颜色
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 3200,
                    (Math.random() - 0.5) * 3200,
                    -1800 + Math.random() * 1200
                );
                mesh.userData = {
                    vx: (Math.random() - 0.5) * 2.5,
                    vy: (Math.random() - 0.5) * 2.5,
                    vz: 6 + Math.random() * 8
                };
                blackStars.push(mesh);
                scene.add(mesh);
            }

            // 鼠标交互变量
            let targetX = 0;
            let targetY = 0;
            const mouseMoveSensitivity = 200; // 调整鼠标移动对相机的影响程度，从80增加到150，现在到200

            // 鼠标移动事件监听器
            window.addEventListener('mousemove', (event) => {
                targetX = (event.clientX / window.innerWidth) * 2 - 1; // 归一化到 -1 到 1
                targetY = -(event.clientY / window.innerHeight) * 2 + 1; // 归一化到 -1 到 1，Y轴反转
            });

            let running = true;
            let rotationEnabled = false; // 新增：控制线条旋转的开关
            const lineRotationSpeed = 0.05; // 新增：线条旋转速度

            // 新增：切换线条旋转的方法
            function toggleLineRotation() {
                rotationEnabled = !rotationEnabled;
            }

            function animate() {
                if (!running) return;
                const now_global = performance.now(); // 优化：在帧开始时只调用一次performance.now()

                // 让星空缓慢自转
                stars.rotation.y += 0.0007;
                stars.rotation.x += 0.0002;
                scene.children.forEach(obj => {
                    if (obj.type === 'Mesh' && obj !== stars) {
                        obj.rotation.y += 0.0003;
                        obj.rotation.x += 0.0001;
                    }
                });
                fleetParticles.forEach((fleet, idx) => {
                    fleet.rotation.z += 0.001 + idx * 0.0001;
                    fleet.rotation.x += 0.0005 * Math.sin(now_global * 0.0002 + idx);
                    // ====== 新增：动态流动七彩流光特效 ======
                    const colors = fleet.geometry.attributes.color;
                    const now = now_global * 0.0005;
                    for (let j = 0; j < colors.count; j++) {
                        const t = j / colors.count;
                        let hue;
                        let saturation = 0.95;
                        let lightness = 0.6;

                        if (currentEffectActive) {
                            // 七彩斑斓的渐变电流效果
                            const effectProgress = currentEffectTimer / CURRENT_EFFECT_DURATION; // 0 to 1
                            hue = (t * 0.7 + now * 1.5 + idx * 0.2 + Math.sin(effectProgress * Math.PI * 2) * 0.5) % 1.0; // 使用sin函数平滑色相变化
                            saturation = 0.8 + 0.2 * Math.sin(effectProgress * Math.PI * 4); // 增加饱和度动态范围
                            lightness = 0.7 + 0.3 * Math.sin(now * 5 + t * 20 + idx + effectProgress * Math.PI * 6); // 更强的脉冲，与效果进度关联
                        } else {
                            // 原始的七彩渐变色
                            hue = (t + now + idx * 0.13) % 1.0;
                            saturation = 0.95;
                            lightness = 0.6 + 0.2 * Math.sin(now * 2 + t * 10 + idx);
                        }
                        const color = new THREE.Color();
                        color.setHSL(hue, saturation, lightness);
                        colors.setXYZ(j, color.r, color.g, color.b);
                    }
                    colors.needsUpdate = true;
                    if (rotationEnabled) {
                        // 360度旋转效果
                        fleet.rotation.y += lineRotationSpeed; // 围绕Y轴旋转
                        fleet.rotation.x += lineRotationSpeed * 0.5; // 辅助X轴旋转，增加视觉效果
                    }
                });
                meteors.forEach((meteor, i) => {
                    const pos = meteor.geometry.attributes.position;
                    const base = meteor.userData.base;
                    const dir = meteor.userData.dir;
                    const speed = meteor.userData.speed; // Define speed here
                    // const now = performance.now(); // Define now here // 优化：已移到函数顶部

                    // ====== 新增：动态流动七彩流光特效 ======
                    const colors = meteor.geometry.attributes.color;
                    const colorNow = now_global * 0.0007; // 优化：使用全局now_global
                    for (let j = 0; j < colors.count; j++) {
                        const t = j / colors.count;
                        let hue;
                        let saturation = 1;
                        let lightness = 0.65;

                        if (currentEffectActive) {
                            // 七彩斑斓的渐变电流效果
                            const effectProgress = currentEffectTimer / CURRENT_EFFECT_DURATION; // 0 to 1
                            hue = (colorNow * 2 + t * 0.9 + i * 0.25 + Math.sin(effectProgress * Math.PI * 2) * 0.6) % 1.0; // 使用sin函数平滑色相变化，增加影响
                            saturation = 0.85 + 0.15 * Math.sin(effectProgress * Math.PI * 4); // 增加饱和度动态范围
                            lightness = 0.7 + 0.25 * Math.sin(colorNow * 6 + t * 15 + i + effectProgress * Math.PI * 8); // 更强的脉冲，与效果进度关联
                        } else {
                            hue = (colorNow + t * 0.7 + i * 0.13) % 1.0;
                            saturation = 1;
                            lightness = 0.65 + 0.15 * Math.sin(colorNow * 2 + t * 8);
                        }
                        const color = new THREE.Color();
                        color.setHSL(hue, saturation, lightness);
                        colors.setXYZ(j, color.r, color.g, color.b);
                    }
                    colors.needsUpdate = true;
                    if (rotationEnabled) {
                        // 360度旋转效果
                        meteor.rotation.y += lineRotationSpeed; // 围绕Y轴旋转
                        meteor.rotation.x += lineRotationSpeed * 0.5; // 辅助X轴旋转，增加视觉效果
                    }

                    for (let i_point = 0; i_point < pos.count; i_point++) { // Renamed i to i_point to avoid conflict with outer i in forEach
                        const t = i_point / pos.count;
                        const zMotion = base[2] + dir[2] * t * 1200 + now_global * 0.08 * speed * t; // 优化：使用全局now_global

                        // Introduce sine wave for X and Y components to create curved paths
                        const waveAmplitude1 = 100 + t * 200 + Math.sin(now_global * 0.0001 + i * 0.2) * 50; // Amplitude grows with distance, plus slight time/meteor specific variation
                        const waveFrequencyX1 = 0.5 + t * 1.5 + Math.cos(now_global * 0.00008 + i * 0.3) * 0.3; // Frequency changes along the path
                        const waveFrequencyY1 = 0.6 + t * 1.3 + Math.sin(now_global * 0.00009 + i * 0.4) * 0.2;
                        const wavePhaseX1 = now_global * 0.0005 + i_point * 0.1;
                        const wavePhaseY1 = now_global * 0.0006 + i_point * 0.12;

                        const waveAmplitude2 = 50 + t * 100 + Math.cos(now_global * 0.00015 + i * 0.5) * 30; // Second wave amplitude
                        const waveFrequencyX2 = 1.0 + t * 2.0 + Math.sin(now_global * 0.00012 + i * 0.6) * 0.4;
                        const waveFrequencyY2 = 1.1 + t * 1.8 + Math.cos(now_global * 0.00013 + i * 0.7) * 0.3;
                        const wavePhaseX2 = now_global * 0.0008 + i_point * 0.15;
                        const wavePhaseY2 = now_global * 0.0009 + i_point * 0.18;

                        const xComponent = base[0] + dir[0] * t * 1200 + 
                                           Math.sin(wavePhaseX1 * waveFrequencyX1) * waveAmplitude1 +
                                           Math.cos(wavePhaseX2 * waveFrequencyX2) * waveAmplitude2 * 0.5; // Adding a second term with different phase and amplitude for more complex motion
                        const yComponent = base[1] + dir[1] * t * 1200 + 
                                           Math.cos(wavePhaseY1 * waveFrequencyY1) * waveAmplitude1 +
                                           Math.sin(wavePhaseY2 * waveFrequencyY2) * waveAmplitude2 * 0.5; // Adding a second term

                        pos.setXYZ(
                            i_point,
                            xComponent,
                            yComponent,
                            zMotion
                        );
                    }
                    pos.needsUpdate = true;
                    if (pos.getZ(pos.count - 1) > 2000) {
                        meteor.userData.base = [
                            (Math.random() - 0.5) * 1800,
                            (Math.random() - 0.5) * 1200,
                            -1800 + Math.random() * 1200
                        ];
                        meteor.userData.dir = [
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2,
                            1 + Math.random() * 0.5
                        ];
                    }
                });
                // 黑色星辰粒子运动
                blackStars.forEach((star, idx) => {
                    const wobbleFactor = 0.8; // Controls the intensity of the wobble
                    const wobbleSpeedX = 0.005 + idx * 0.0001;
                    const wobbleSpeedY = 0.006 + idx * 0.0001;

                    star.position.x += star.userData.vx + Math.sin(now_global * wobbleSpeedX) * wobbleFactor; // 优化：使用全局now_global
                    star.position.y += star.userData.vy + Math.cos(now_global * wobbleSpeedY) * wobbleFactor; // 优化：使用全局now_global
                    star.position.z += star.userData.vz; // Keep vz as is for now, main movement forward
                    // 更丰富的动态七彩渐变色彩
                    const t = now_global * 0.00038 + idx * 0.19; // 优化：使用全局now_global
                    const px = star.position.x, py = star.position.y, pz = star.position.z;
                    // 色相：idx+空间+时间多频率扰动
                    const baseHue = (idx / BLACK_STAR_COUNT + Math.sin(t) * 0.32 + Math.cos(t * 0.7) * 0.23 + Math.sin(px * 0.0003 + py * 0.0002 + pz * 0.0001) * 0.18) % 1.0;
                    const extra = Math.sin(idx * 0.618 + t * 0.7) * 0.18 + Math.sin(idx * 2.17 + t * 0.3) * 0.13 + Math.sin(idx * 5.13 + t * 0.5) * 0.11;
                    const hue = (baseHue + extra + Math.sin(idx + t) * 0.13 + Math.sin(px * 0.0007 + t * 0.5) * 0.09) % 1.0;
                    // 饱和度和亮度也动态变化
                    const saturation = 0.98 + 0.22 * Math.sin(idx * 1.77 + t * 1.2 + px * 0.0005) + 0.18 * Math.sin(idx * 0.13 + t * 0.8 + py * 0.0005);
                    const lightness = 0.72 + 0.32 * Math.sin(idx * 2.33 + t * 1.1 + pz * 0.0006) + 0.18 * Math.cos(idx * 0.23 + t * 0.9 + px * 0.0003);
                    star.material.color.setHSL((hue + 1) % 1.0, Math.min(1, Math.max(0.7, saturation)), Math.min(1, Math.max(0.45, lightness)));

                    // 鼠标位置对黑色星辰粒子的影响：速度、透明度和尺寸
                    const mouseInfluenceFactor = 0.2; // 鼠标影响强度
                    // 计算粒子到屏幕中心鼠标位置的距离
                    const mouseX_screen = (targetX * mouseMoveSensitivity + camera.position.x);
                    const mouseY_screen = (targetY * mouseMoveSensitivity + camera.position.y);

                    // 转换粒子世界坐标到屏幕坐标以便计算2D距离，这里简化处理，直接用相机位置作偏移
                    const distanceToMouse = Math.sqrt(
                        Math.pow(star.position.x - (camera.position.x + targetX * mouseMoveSensitivity), 2) +
                        Math.pow(star.position.y - (camera.position.y + targetY * mouseMoveSensitivity), 2)
                    );
                    const proximityFactor = Math.max(0, 1 - distanceToMouse / 800); // 距离越近，影响越大

                    // 调整速度，使粒子向鼠标方向"偏移"
                    star.userData.vx += (targetX * star.userData.vz * 0.002 - star.userData.vx) * proximityFactor * mouseInfluenceFactor;
                    star.userData.vy += (targetY * star.userData.vz * 0.002 - star.userData.vy) * proximityFactor * mouseInfluenceFactor;
                    
                    // 尺寸和透明度随鼠标接近而变化
                    const baseOpacity = 0.92;
                    const baseSize = 1.2;
                    star.material.opacity = baseOpacity + proximityFactor * 0.2; // 鼠标接近时更亮
                    star.scale.setScalar(baseSize + proximityFactor * 1.5); // 鼠标接近时更大
                    
                    // 超出视野后重置
                    if (star.position.z > 2000 || Math.abs(star.position.x) > 3500 || Math.abs(star.position.y) > 3500) {
                        star.position.set(
                            (Math.random() - 0.5) * 3200,
                            (Math.random() - 0.5) * 3200,
                            -1800 + Math.random() * 1200
                        );
                        star.userData.vx = (Math.random() - 0.5) * 2.5;
                        star.userData.vy = (Math.random() - 0.5) * 2.5;
                        star.userData.vz = 5 + Math.random() * 10; // Slightly larger range for Z speed
                    }
                });

                // 根据鼠标位置调整摄像机位置
                camera.position.x += (targetX * mouseMoveSensitivity - camera.position.x) * 0.08; // 更灵敏
                camera.position.y += (targetY * mouseMoveSensitivity - camera.position.y) * 0.08; // 更灵敏

                // 鼠标移动对场景和星星的旋转影响
                scene.rotation.y += (targetX * 0.06 - scene.rotation.y) * 0.08; // 更灵敏，更大的旋转范围
                scene.rotation.x += (targetY * 0.06 - scene.rotation.x) * 0.08; // 更灵敏，更大的旋转范围

                renderer.render(scene, camera);
                requestAnimationFrame(animate);

                // 更新渐变电流效果计时器
                if (currentEffectActive) {
                    currentEffectTimer++;
                    if (currentEffectTimer > CURRENT_EFFECT_DURATION) {
                        currentEffectActive = false;
                        currentEffectTimer = 0;
                    }
                }
            }
            animate();

            function onResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', onResize);

            // 返回销毁函数和新的效果激活函数
            return {
                destroy: function() {
                    running = false;
                    window.removeEventListener('resize', onResize);
                    renderer.forceContextLoss && renderer.forceContextLoss();
                    renderer.dispose && renderer.dispose();
                    if (renderer.domElement && renderer.domElement.parentNode) {
                        renderer.domElement.parentNode.removeChild(renderer.domElement);
                    }
                },
                activateGradientCurrentEffect: function() {
                    currentEffectActive = true;
                    currentEffectTimer = 0;
                }
            };
        }








        
        document.addEventListener('DOMContentLoaded', function() {
            // 启动three.js超级宇宙背景
            let destroyThreeJSBG = createThreeJSUniverseBackground();
            let collapseEffectStarted = false;

            // 移除所有文本元素，保持空容器
            const container = document.querySelector('.container');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            // 监听鼠标右键单击
            document.addEventListener('mousedown', function(e) {
                if (e.button === 2 && !collapseEffectStarted) {
                    collapseEffectStarted = true;
                    // 销毁three.js背景
                    if (destroyThreeJSBG) destroyThreeJSBG.destroy(); // 调用返回的destroy方法
                    // 启动终极宇宙坍缩特效
                    const triggerSuperCollapseEffect = createSuperUniverseCollapseEffect();
                    triggerSuperCollapseEffect();
                } else if (e.button === 1) { // 鼠标中键 (button === 1)
                    // 激活七彩斑斓的渐变电流
                    if (destroyThreeJSBG && destroyThreeJSBG.activateGradientCurrentEffect) {
                        destroyThreeJSBG.activateGradientCurrentEffect();
                    }
                }
            });
        });
    </script>
    <script src="my-function.js"></script>
</body>
</html>