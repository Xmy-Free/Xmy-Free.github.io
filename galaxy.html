<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>银河系宇宙</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;

        }
        .info {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(180, 200, 255, 0.5);
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(100, 150, 255, 0.3);
            z-index: 100;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(200, 220, 255, 0.7);
            font-family: Arial, sans-serif;
            font-size: 18px;
            pointer-events: none;
        }
    </style>

<link rel="stylesheet" href="my-cursor.css"></link>">

</head>
<body>

            <!-- 自定义鼠标指针 -->
            <div class="custom-cursor" id="custom-cursor">
                <div class="cursor-core"></div>
                <div class="cursor-ring"></div>
            </div>
    <div class="loading" id="loading">正在生成银河系...</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 全局变量，方便在外部JS访问
        let scene, camera, renderer, controls, galaxy;

        // 显示加载状态
        const loadingElement = document.getElementById('loading');
        
        // 初始化场景、相机和渲染器
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
        renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // 限制像素比以提高性能
        renderer.setClearColor(0x000000);
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // 添加轨道控制器
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1000;
        controls.maxDistance = 40000;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;
        controls.enablePan = false;

        // 相机位置                                    
        camera.position.set(14000, 15000, 20000); // 调整初始相机位置，从旋臂面开始
        controls.update();

        // 银河系参数
        const galaxyParams = {
            spiralArms: 4,
            coreRadius: 1200, // 增大核心半径，更密集
            diskRadius: 30000, // 增大盘面半径，更广阔
            armWidth: 0.9, // 稍微增大螺旋臂宽度
            starCount: 1200000, // 大幅增加螺旋臂恒星数量
            dustCount: 600000, // 大幅增加尘埃数量
            coreStarCount: 300000, // 大幅增加核心恒星数量
            haloStarCount: 200000, // 增加恒星晕数量
            globularClusterCount: 45, // 增加星团数量
            pulsarCount: 320, // 增加脉冲星数量，银河系上的星星
            nebulaCloudCount: 50 // 增加大型星云数量
        };

        // 创建银河系
        function createGalaxy() {
            const galaxyGroup = new THREE.Group();
            
            // 中央黑洞/引力源的视觉提示 (非常微弱且几乎不可见)
            const blackHoleGeometry = new THREE.SphereGeometry(64, 64, 64); // 增大尺寸
            const blackHoleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2288FF, // 更深更纯的蓝色
                emissive: 0x1166FF, // 明亮蓝色自发光
                specular: 0x66AAFF, // 柔和蓝色高光
                shininess: 80, // 提高光泽度
                transparent: true, // 允许透明度
                opacity: 0.92, // 略微提高不透明度
                blending: THREE.AdditiveBlending // 使用叠加混合模式以增强发光效果
            });
            const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            
            // 添加一个点光源，模拟宝石发光
            const gemLight = new THREE.PointLight(0xFFE066, 50.0, 5000, 2); // 增强光照强度和距离
            blackHole.add(gemLight); // 将光源添加到宝石物体上，这样它会随宝石移动

            galaxyGroup.add(blackHole); // 加到银河系组，这样它会随银河系倾斜和旋转

            loadingElement.textContent = "生成银河核心...";
            galaxyGroup.add(createCore());

            loadingElement.textContent = "生成螺旋臂...";
            galaxyGroup.add(createSpiralArms());

            loadingElement.textContent = "生成星际尘埃和星云...";
            galaxyGroup.add(createDustAndNebulae());

            loadingElement.textContent = "生成恒星晕...";
            galaxyGroup.add(createHalo());
            
            loadingElement.textContent = "生成恒星团...";
            galaxyGroup.add(createGlobularClusters());

            loadingElement.textContent = "生成脉冲星...";
            galaxyGroup.add(createPulsars()); // 新增脉冲星

            loadingElement.textContent = "生成背景星系...";
            scene.add(createBackgroundGalaxies());
            
            loadingElement.textContent = "生成背景恒星场...";
            scene.add(createBackgroundStars());
            
            // 设置银河系倾斜角度
            galaxyGroup.rotation.x = Math.PI / 5;
            galaxyGroup.rotation.z = Math.PI / 12; // 增加Z轴倾斜，更具动态感
            
            loadingElement.style.display = "none";
            return galaxyGroup;
        }

        // 新增函数：创建银河核心
        function createCore() {
            // 1. 银河核心 - 密集明亮的恒星
            const coreGeometry = new THREE.BufferGeometry();
            const corePositions = new Float32Array(galaxyParams.coreStarCount * 3);
            const coreColors = new Float32Array(galaxyParams.coreStarCount * 3);
            const coreSizes = new Float32Array(galaxyParams.coreStarCount);
            
            for (let i = 0; i < galaxyParams.coreStarCount; i++) {
                // 球体分布，中心密度更高
                const radius = Math.pow(Math.random(), 8) * galaxyParams.coreRadius; // 更强的中心聚集，更致密
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                corePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                corePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta) * 0.02; // 更扁平化，原为0.05
                corePositions[i * 3 + 2] = radius * Math.cos(phi);
                
                // 核心恒星颜色 - 更突出更纯的蓝色
                const colorIntensity = 0.8 + Math.random() * 0.2; // 调整亮度范围，更亮
                const hue = 0.60 + Math.random() * 0.06; // 更纯正的蓝色
                const saturation = 0.95 + Math.random() * 0.05; // 极高饱和度
                const lightness = 0.45 + Math.random() * 0.13 * colorIntensity; // 降低亮度，更蓝
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                
                coreColors[i * 3] = color.r;
                coreColors[i * 3 + 1] = color.g;
                coreColors[i * 3 + 2] = color.b;
                
                // 大小 - 核心恒星更大且有更大范围的变化
                coreSizes[i] = 1.5 + Math.random() * 3.5; // 调整大小范围，更大
            }
            
            coreGeometry.setAttribute('position', new THREE.BufferAttribute(corePositions, 3));
            coreGeometry.setAttribute('color', new THREE.BufferAttribute(coreColors, 3));
            coreGeometry.setAttribute('size', new THREE.BufferAttribute(coreSizes, 1));
            
            const coreMaterial = new THREE.PointsMaterial({
                size: 1.2, // 更小，原为2.0
                vertexColors: true,
                transparent: true,
                opacity: 0.45, // 更暗，原为0.75
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                fog: false
            });
            
            return new THREE.Points(coreGeometry, coreMaterial);
        }

        // 新增函数：创建螺旋臂
        function createSpiralArms() {
            const spiralGeometry = new THREE.BufferGeometry();
            const spiralPositions = new Float32Array(galaxyParams.starCount * 3);
            const spiralColors = new Float32Array(galaxyParams.starCount * 3);
            const spiralSizes = new Float32Array(galaxyParams.starCount);

            for (let i = 0; i < galaxyParams.starCount; i++) {
                // 主臂编号
                const arm = i % galaxyParams.spiralArms;
                // 半径分布，中心更密集
                const t = Math.pow(Math.random(), 2.2);
                const radius = galaxyParams.coreRadius + t * (galaxyParams.diskRadius - galaxyParams.coreRadius);

                // 主螺旋臂角度
                const armAngle = arm * (Math.PI * 2 / galaxyParams.spiralArms);
                // 螺旋紧密度和扰动
                let spiralAngle = radius * 0.015 * (1 + 0.8 * Math.sin(arm * 0.5));
                // 分形扰动（羽状分支）
                const feather = Math.sin(radius * 0.04 + Math.random() * 2) * (0.2 + 0.8 * Math.pow(1 - t, 2));
                // 臂间恒星
                const interArm = Math.random() < 0.12;
                let angle = armAngle + spiralAngle + feather;
                if (interArm) angle += Math.PI / galaxyParams.spiralArms * (Math.random() - 0.5);

                // 盘面高度波动，增强立体感
                // 增强高度变化，使旋臂更具起伏
                let height;
                if (t < 0.08) { // 最靠近核心的8%粒子，极度扁平
                    height = (Math.random() - 0.5) * 80; // 极小高度
                } else if (t < 0.18) { // 靠近核心的18%粒子，较扁平
                    height = (Math.random() - 0.5) * 300 * (1 - Math.pow(t, 0.5)) + Math.sin(radius * 0.003 + armAngle * 2) * 60;
                } else {
                    height = (Math.random() - 0.5) * 800 * (1 - Math.pow(t, 0.5)) + Math.sin(radius * 0.003 + armAngle * 2) * 180;
                }

                spiralPositions[i * 3] = radius * Math.cos(angle);
                spiralPositions[i * 3 + 1] = height;
                spiralPositions[i * 3 + 2] = radius * Math.sin(angle);

                // 颜色：臂内更蓝，臂间更黄/红，外围更暗
                let hue, saturation, lightness;
                if (interArm) {
                    hue = 0.1 + Math.random() * 0.08; // 金色到浅橙色
                    saturation = 0.7 + Math.random() * 0.2; // 高饱和度
                    lightness = 0.08 + Math.random() * 0.28; // 更暗，原为0.1+0.7
                } else if (t < 0.3) {
                    hue = 0.58 + Math.random() * 0.08; // 蓝色到浅蓝色
                    saturation = 0.8 + Math.random() * 0.15; // 高饱和度
                    lightness = 0.28 + Math.random() * 0.32; // 更暗，原为0.4+0.6
                } else {
                    hue = 0.5 + Math.random() * 0.2; // 青色到蓝紫色，用于外围混色
                    saturation = 0.7 + Math.random() * 0.2;
                    lightness = 0.12 + Math.random() * 0.22; // 提高外围亮度，原为0.04+0.18
                }
                // 超巨星点缀（更亮更显眼）
                if (Math.random() < 0.0008) { // 稍微降低出现几率，但更亮
                    hue = 0.55 + Math.random() * 0.1; // 极亮的蓝白色
                    saturation = 0.9 + Math.random() * 0.1;
                    lightness = 0.7 + Math.random() * 0.18; // 亮但不刺眼，原为0.95+0.05
                }
                // 距离越远越暗
                if (t < 0.5) {
                  lightness *= 0.5 + 0.5 * (1 - t); // 只对中心和中间区域做衰减，外围不再进一步降低
                }

                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                spiralColors[i * 3] = color.r;
                spiralColors[i * 3 + 1] = color.g;
                spiralColors[i * 3 + 2] = color.b;

                // 大小 - 螺旋臂恒星的大小变化更丰富，增强明暗对比
                spiralSizes[i] = (Math.random() < 0.98) ? (0.5 + Math.random() * 1.5) : (4.0 + Math.random() * 8.0); // 更多非常小和非常大的恒星
            }

            spiralGeometry.setAttribute('position', new THREE.BufferAttribute(spiralPositions, 3));
            spiralGeometry.setAttribute('color', new THREE.BufferAttribute(spiralColors, 3));
            spiralGeometry.setAttribute('size', new THREE.BufferAttribute(spiralSizes, 1));

            const spiralMaterial = new THREE.PointsMaterial({
                size: 1.0, // 更小，原为1.5
                vertexColors: true,
                transparent: true,
                opacity: 0.7, // 显著提高不透明度，外围更明显
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                fog: false
            });

            return new THREE.Points(spiralGeometry, spiralMaterial);
        }

        // 新增函数：创建星际尘埃和星云
        function createDustAndNebulae() {
            const dustAndNebulaeGroup = new THREE.Group();
            
            // 1. 星际尘埃 - 更自然分布，更柔和
            const dustGeometry = new THREE.BufferGeometry();
            const dustPositions = new Float32Array(galaxyParams.dustCount * 3);
            const dustColors = new Float32Array(galaxyParams.dustCount * 3);
            const dustSizes = new Float32Array(galaxyParams.dustCount);
            
            for (let i = 0; i < galaxyParams.dustCount; i++) {
                const inArm = Math.random() > 0.08; // 更多尘埃在螺旋臂中
                let radius, angle;
                
                if (inArm) {
                    const arm = Math.floor(Math.random() * galaxyParams.spiralArms);
                    const t = Math.pow(Math.random(), 1.5); // 尘埃更集中在臂上
                    radius = galaxyParams.coreRadius + t * (galaxyParams.diskRadius - galaxyParams.coreRadius);
                    const armAngle = arm * (Math.PI * 2 / galaxyParams.spiralArms);
                    const spiralAngle = radius * 0.015 * (1 + 0.8 * Math.sin(arm * 0.5));
                    angle = armAngle + spiralAngle + (Math.random() - 0.5) * 1.2; // 增加随机偏移
                } else {
                    const t = Math.pow(Math.random(), 1.8); // 盘面内分布更均匀
                    radius = galaxyParams.coreRadius * 0.4 + t * (galaxyParams.diskRadius * 1.4 - galaxyParams.coreRadius * 0.4); // 扩展分布范围
                    angle = Math.random() * Math.PI * 2;
                }
                
                const height = (Math.random() - 0.5) * 600 * (1 - (radius / galaxyParams.diskRadius) * 0.7); // 调整高度范围，更扁平
                
                dustPositions[i * 3] = radius * Math.cos(angle);
                dustPositions[i * 3 + 1] = height;
                dustPositions[i * 3 + 2] = radius * Math.sin(angle);
                
                // 尘埃颜色 - 更广的色域，提高亮度
                const hue = 0.65 + Math.random() * 0.2; // 偏向紫蓝色，范围更广，模拟"荧光颜料"
                const saturation = 0.8 + Math.random() * 0.15; // 提高饱和度，更鲜艳
                const lightness = 0.08 + Math.random() * 0.1; // 提高亮度
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                
                dustColors[i * 3] = color.r;
                dustColors[i * 3 + 1] = color.g;
                dustColors[i * 3 + 2] = color.b;
                
                dustSizes[i] = 20.0 + Math.random() * 30.0; // 调整大小范围，更大
            }
            
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute('color', new THREE.BufferAttribute(dustColors, 3));
            dustGeometry.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));
            
            const dustMaterial = new THREE.PointsMaterial({
                size: 25.0, // 调整整体大小，更大
                vertexColors: true,
                transparent: true,
                opacity: 0.02, // 降低不透明度，更柔和，更像"轻纱"和"半透明琉璃盘"
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                fog: false
            });
            
            dustAndNebulaeGroup.add(new THREE.Points(dustGeometry, dustMaterial));

            // 2. 大型星云 - 更明显、更大、色彩更丰富
            for (let i = 0; i < galaxyParams.nebulaCloudCount; i++) {
                const nebulaStarCount = 3000 + Math.floor(Math.random() * 7000); // 增加星云恒星数量
                const nebulaRadius = 2000 + Math.random() * 4000; // 星云大小更大

                const nebulaGeometry = new THREE.BufferGeometry();
                const nebulaPositions = new Float32Array(nebulaStarCount * 3);
                const nebulaColors = new Float32Array(nebulaStarCount * 3);
                const nebulaSizes = new Float32Array(nebulaStarCount);

                const baseHue = 0.7 + Math.random() * 0.15; // 星云的基础色相偏向紫色
                
                for (let j = 0; j < nebulaStarCount; j++) {
                    const r = Math.pow(Math.random(), 1.5) * nebulaRadius; // 更集中
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    nebulaPositions[j * 3] = r * Math.sin(phi) * Math.cos(theta);
                    nebulaPositions[j * 3 + 1] = r * Math.sin(phi) * Math.sin(theta) * 0.5; // 略微扁平
                    nebulaPositions[j * 3 + 2] = r * Math.cos(phi);

                    // 星云内部颜色变化，提高亮度和饱和度
                    const hue = baseHue + (Math.random() - 0.5) * 0.15; // 色相范围更窄，更集中在紫色
                    const saturation = 0.9 + Math.random() * 0.1; // 提高饱和度，更浓郁
                    const lightness = 0.25 + Math.random() * 0.3; // 提高亮度，更具"荧光"感
                    const color = new THREE.Color().setHSL(hue, saturation, lightness);
                    
                    nebulaColors[j * 3] = color.r;
                    nebulaColors[j * 3 + 1] = color.g;
                    nebulaColors[j * 3 + 2] = color.b;
                    
                    nebulaSizes[j] = 60.0 + Math.random() * 120.0; // 星云粒子更大
                }
                
                nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
                nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
                nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));
                
                const nebulaMaterial = new THREE.PointsMaterial({
                    size: 80.0, // 整体星云粒子大小，更大
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.018, // 降低不透明度，形成更明显的朦胧感和"紫雾"效果
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    fog: false
                });
                
                const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);

                // 随机放置星云在银河系盘面和光晕之间，更具视觉冲击力
                const distance = galaxyParams.diskRadius * 1.5 + Math.random() * (galaxyParams.diskRadius * 4.0); // 放置更远
                const nebulaTheta = Math.random() * Math.PI * 2;
                const nebulaPhi = Math.acos(2 * Math.random() - 1) * 0.9; // 更集中在盘面附近，但有一定散布
                
                nebula.position.x = distance * Math.sin(nebulaPhi) * Math.cos(nebulaTheta);
                nebula.position.y = distance * Math.sin(nebulaPhi) * Math.sin(nebulaTheta) * (Math.random() > 0.5 ? 1 : -1) * 0.8; // 增加Y轴对称分布
                nebula.position.z = distance * Math.cos(nebulaPhi);

                dustAndNebulaeGroup.add(nebula);
            }
            return dustAndNebulaeGroup;
        }

        // 新增函数：创建恒星晕
        function createHalo() {
            // 4. 恒星晕 - 围绕银河系的稀疏恒星
            const haloGeometry = new THREE.BufferGeometry();
            const haloPositions = new Float32Array(galaxyParams.haloStarCount * 3);
            const haloColors = new Float32Array(galaxyParams.haloStarCount * 3);
            const haloSizes = new Float32Array(galaxyParams.haloStarCount);
            
            for (let i = 0; i < galaxyParams.haloStarCount; i++) {
                // 球体分布，延伸到很远，中心密度略高
                const radius = galaxyParams.diskRadius * (2.0 + Math.pow(Math.random(), 1.0) * 5.0); // 调整半径分布，更向外延伸，有一定聚集
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                haloPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                haloPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta) * 0.8; // 略微拉伸Y轴，更接近球形
                haloPositions[i * 3 + 2] = radius * Math.cos(phi);
                
                // 晕恒星颜色 - 偏红的老恒星，亮度更低，但有更多变化
                const hue = 0.005 + Math.random() * 0.04; // 更偏红，色相范围更窄
                const saturation = 0.4 + Math.random() * 0.3; // 略微提高饱和度
                const lightness = 0.05 + Math.random() * 0.05; // 进一步降低亮度，但有更多随机性
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                
                haloColors[i * 3] = color.r;
                haloColors[i * 3 + 1] = color.g;
                haloColors[i * 3 + 2] = color.b;
                
                // 大小 - 晕恒星更小，但有更多尺寸变化
                haloSizes[i] = 0.15 + Math.random() * 0.4; // 进一步缩小大小，但有更大变化范围
            }
            
            haloGeometry.setAttribute('position', new THREE.BufferAttribute(haloPositions, 3));
            haloGeometry.setAttribute('color', new THREE.BufferAttribute(haloColors, 3));
            haloGeometry.setAttribute('size', new THREE.BufferAttribute(haloSizes, 1));
            
            const haloMaterial = new THREE.PointsMaterial({
                size: 0.35, // 进一步缩小整体大小，但仍可见
                vertexColors: true,
                transparent: true,
                opacity: 0.2, // 降低不透明度，更稀疏
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                fog: false
            });
            
            return new THREE.Points(haloGeometry, haloMaterial);
        }

        // 新增函数：创建球状星团
        function createGlobularClusters() {
            // 5. 恒星团 (Globular Clusters) - 密集的小型球状星团
            const globularClustersGroup = new THREE.Group();
            for (let i = 0; i < galaxyParams.globularClusterCount; i++) {
                const clusterStarCount = 1500 + Math.floor(Math.random() * 2000); // 每个星团的恒星数量增加
                const clusterRadius = 300 + Math.random() * 600; // 星团大小略微增大
                
                const clusterGeometry = new THREE.BufferGeometry();
                const clusterPositions = new Float32Array(clusterStarCount * 3);
                const clusterColors = new Float32Array(clusterStarCount * 3);
                const clusterSizes = new Float32Array(clusterStarCount);
                
                for (let j = 0; j < clusterStarCount; j++) {
                    const r = Math.pow(Math.random(), 3.5) * clusterRadius; // 更强的中心聚集
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    clusterPositions[j * 3] = r * Math.sin(phi) * Math.cos(theta);
                    clusterPositions[j * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    clusterPositions[j * 3 + 2] = r * Math.cos(phi);
                    
                    // 星团恒星颜色 - 偏红的古老恒星，亮度适中且柔和，增加更多变化
                    const hue = 0.08 + Math.random() * 0.05; // 偏向暖白色调，更接近珍珠色
                    const saturation = 0.2 + Math.random() * 0.2; // 降低饱和度，更柔和
                    const lightness = 0.5 + Math.random() * 0.2; // 提高亮度，更像珍珠光泽
                    const color = new THREE.Color().setHSL(hue, saturation, lightness);
                    
                    clusterColors[j * 3] = color.r;
                    clusterColors[j * 3 + 1] = color.g;
                    clusterColors[j * 3 + 2] = color.b;
                    
                    clusterSizes[j] = 1.0 + Math.random() * 1.8; // 略微增大大小，更明显
                }
                
                clusterGeometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                clusterGeometry.setAttribute('color', new THREE.BufferAttribute(clusterColors, 3));
                clusterGeometry.setAttribute('size', new THREE.BufferAttribute(clusterSizes, 1));
                
                const clusterMaterial = new THREE.PointsMaterial({
                    size: 1.5, // 略微增大整体大小
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.95, // 提高不透明度，更致密
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    fog: false
                });
                
                const cluster = new THREE.Points(clusterGeometry, clusterMaterial);
                
                // 随机放置在银河系外围的晕区域，但距离银河系中心更远，更具立体感
                const distance = galaxyParams.diskRadius * (3.0 + Math.random() * 3.5); // 放置更远，有更大变化
                const clusterTheta = Math.random() * Math.PI * 2;
                const clusterPhi = Math.acos(2 * Math.random() - 1) * 1.1; // 稍微更集中在赤道平面附近
                
                cluster.position.x = distance * Math.sin(clusterPhi) * Math.cos(clusterTheta);
                cluster.position.y = distance * Math.sin(clusterPhi) * Math.sin(clusterTheta);
                cluster.position.z = distance * Math.cos(clusterPhi);
                
                globularClustersGroup.add(cluster);
            }
            return globularClustersGroup;
        }

        // 创建背景星系天体，黑暗森林
        // "宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间······能做的只有一件事：开枪消灭之"
        function createBackgroundGalaxies() {
            // 6. 背景星系（椭圆+螺旋臂）
            const bgGalaxyCount = 520;
            const bgGalaxies = new THREE.Group();
            for (let i = 0; i < bgGalaxyCount; i++) {
                const bgGalaxy = new THREE.Group();
                // 星系参数
                const bgStarCount = 10000 + Math.floor(Math.random() * 20000);
                const coreStarCount = Math.floor(bgStarCount * 0.18); // 18%核心
                const armStarCount = bgStarCount - coreStarCount; // 其余分配给螺旋臂
                const spiralArms = 2 + Math.floor(Math.random() * 3); // 2~4条臂
                const spiralTightness = 0.012 + Math.random() * 0.012; // 紧密度
                const armWidth = 0.7 + Math.random() * 0.5; // 臂宽
                const size = 4000 + Math.random() * 9000; // 星系大小
                const coreSize = size * (0.18 + Math.random() * 0.08); // 核心半径
                const hue = Math.random();
                // 1. 核心恒星（椭圆分布）
                const corePositions = new Float32Array(coreStarCount * 3);
                const coreColors = new Float32Array(coreStarCount * 3);
                const coreSizes = new Float32Array(coreStarCount);
                for (let j = 0; j < coreStarCount; j++) {
                    const t = Math.pow(Math.random(), 7);
                    const radius = t * coreSize;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    corePositions[j * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    corePositions[j * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta) * (0.5 + Math.random() * 0.2);
                    corePositions[j * 3 + 2] = radius * Math.cos(phi);
                    // 颜色和亮度随t递减，核心更亮更饱和，外围更暗
                    const colorHue = hue + (Math.random() - 0.5) * 0.08; // 减小hue的变化范围，保持颜色一致性
                    const saturation = 0.7 + (1 - t) * 0.25 + Math.random() * 0.1;
                    const lightness = 0.3 + (1 - t) * 0.18 + Math.random() * 0.08;
                    const color = new THREE.Color().setHSL(colorHue, saturation, lightness);
                    coreColors[j * 3] = color.r;
                    coreColors[j * 3 + 1] = color.g;
                    coreColors[j * 3 + 2] = color.b;
                    coreSizes[j] = 1.8 + (1 - t) * 2.2 + Math.random() * 1.2;
                }
                // 2. 螺旋臂恒星
                const armPositions = new Float32Array(armStarCount * 3);
                const armColors = new Float32Array(armStarCount * 3);
                const armSizes = new Float32Array(armStarCount);
                for (let j = 0; j < armStarCount; j++) {
                    // 分配到某一条臂
                    const arm = j % spiralArms;
                    const t = Math.pow(Math.random(), 2.1); // 越靠近中心越密集
                    const radius = coreSize + t * (size - coreSize);
                    const armAngle = arm * (Math.PI * 2 / spiralArms);
                    let spiralAngle = radius * spiralTightness * (1 + 0.7 * Math.sin(arm * 0.5));
                    // 臂扰动
                    const feather = Math.sin(radius * 0.04 + Math.random() * 2) * (0.2 + 0.7 * Math.pow(1 - t, 2));
                    let angle = armAngle + spiralAngle + feather;
                    // 臂宽扰动
                    angle += (Math.random() - 0.5) * armWidth;
                    // 高度扰动
                    let height = (Math.random() - 0.5) * size * 0.12 * (1 - t);
                    armPositions[j * 3] = radius * Math.cos(angle);
                    armPositions[j * 3 + 1] = height;
                    armPositions[j * 3 + 2] = radius * Math.sin(angle);
                    // 颜色：臂内更蓝，外围更暗
                    let ahue, asat, alight;
                    if (t < 0.3) {
                        // 内部旋臂颜色，与核心颜色保持一致性
                        ahue = hue + (Math.random() - 0.5) * 0.08;
                        asat = 0.8 + Math.random() * 0.15;
                        alight = 0.28 + Math.random() * 0.32;
                    } else {
                        // 外部旋臂颜色，还是与核心保持相同的基础色调
                        ahue = hue + (Math.random() - 0.5) * 0.1;
                        asat = 0.7 + Math.random() * 0.2;
                        alight = 0.12 + Math.random() * 0.22;
                    }
                    // 超亮点缀
                    if (Math.random() < 0.001) {
                        // 对于超亮点缀，保持与核心相同的基础色调
                        ahue = hue + (Math.random() - 0.5) * 0.12;
                        asat = 0.9 + Math.random() * 0.1;
                        alight = 0.7 + Math.random() * 0.18;
                    }
                    const acolor = new THREE.Color().setHSL(ahue, asat, alight);
                    armColors[j * 3] = acolor.r;
                    armColors[j * 3 + 1] = acolor.g;
                    armColors[j * 3 + 2] = acolor.b;
                    armSizes[j] = (Math.random() < 0.98) ? (0.5 + Math.random() * 1.5) : (4.0 + Math.random() * 8.0);
                }
                // 合并核心和臂
                const bgPositions = new Float32Array(bgStarCount * 3);
                const bgColors = new Float32Array(bgStarCount * 3);
                const bgSizes = new Float32Array(bgStarCount);
                bgPositions.set(corePositions, 0);
                bgPositions.set(armPositions, coreStarCount * 3);
                bgColors.set(coreColors, 0);
                bgColors.set(armColors, coreStarCount * 3);
                bgSizes.set(coreSizes, 0);
                bgSizes.set(armSizes, coreStarCount);
                const bgGeometry = new THREE.BufferGeometry();
                bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
                bgGeometry.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));
                bgGeometry.setAttribute('size', new THREE.BufferAttribute(bgSizes, 1));
                const bgMaterial = new THREE.PointsMaterial({
                    size: 2.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending,
                    fog: false
                });
                const bgStars = new THREE.Points(bgGeometry, bgMaterial);
                bgGalaxy.add(bgStars);
                // 随机位置和方向，放置更远且更随机
                const distance = 80000 + Math.random() * 120000;
                const bgTheta = Math.random() * Math.PI * 2;
                const bgPhi = Math.acos(2 * Math.random() - 1);
                bgGalaxy.position.x = distance * Math.sin(bgPhi) * Math.cos(bgTheta);
                bgGalaxy.position.y = distance * Math.sin(bgPhi) * Math.sin(bgTheta);
                bgGalaxy.position.z = distance * Math.cos(bgPhi);
                bgGalaxy.rotation.x = Math.random() * Math.PI * 2;
                bgGalaxy.rotation.y = Math.random() * Math.PI * 2;
                bgGalaxy.rotation.z = Math.random() * Math.PI * 2;
                bgGalaxies.add(bgGalaxy);
            }
            return bgGalaxies;
        }

        // 背景星星
        function createBackgroundStars() {
            const bgStarCount = 5000; // 增加背景星星数量，更密集
            const bgStarGeometry = new THREE.BufferGeometry();
            const bgStarPositions = new Float32Array(bgStarCount * 3);
            const bgStarColors = new Float32Array(bgStarCount * 3);
            const bgStarSizes = new Float32Array(bgStarCount);
            
            for (let i = 0; i < bgStarCount; i++) {
                // 在更大范围内随机分布
                const distance = 60000 + Math.random() * 250000; // 扩大分布范围，更深邃
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                bgStarPositions[i * 3] = distance * Math.sin(phi) * Math.cos(theta);
                bgStarPositions[i * 3 + 1] = distance * Math.sin(phi) * Math.sin(theta);
                bgStarPositions[i * 3 + 2] = distance * Math.cos(phi);
                
                // 进一步增强亮度
                const hue = Math.random();
                const saturation = 0.9 + Math.random() * 0.1; // 饱和度极高
                const lightness = 0.97 + Math.random() * 0.03; // 亮度极高
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                
                bgStarColors[i * 3] = color.r;
                bgStarColors[i * 3 + 1] = color.g;
                bgStarColors[i * 3 + 2] = color.b;
                
                // 近大远小效果进一步增强
                const minSize = 80.0, maxSize = 180.0; // 近处更大，远处也更大
                const tSize = 1 - (distance - 60000) / (250000); // 近处 tSize 趋近于1，远处趋近于0
                bgStarSizes[i] = minSize + (maxSize - minSize) * Math.pow(tSize, 2.5) + Math.random() * 4.5;
            }
            
            bgStarGeometry.setAttribute('position', new THREE.BufferAttribute(bgStarPositions, 3));
            bgStarGeometry.setAttribute('color', new THREE.BufferAttribute(bgStarColors, 3));
            bgStarGeometry.setAttribute('size', new THREE.BufferAttribute(bgStarSizes, 1));
            
            const bgStarMaterial = new THREE.PointsMaterial({
                size: 240, // 整体星点尺寸更大
                vertexColors: true,
                transparent: true,
                opacity: 3.0, // 极高不透明度，极亮
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                fog: false
            });
            
            return new THREE.Points(bgStarGeometry, bgStarMaterial);
        }

        // 新增函数：创建脉冲星
        function createPulsars() {
            const pulsarsGroup = new THREE.Group();
            for (let i = 0; i < galaxyParams.pulsarCount; i++) {
                // 脉冲星视觉体
                const geometry = new THREE.SphereGeometry(30, 32, 32); // 稍大一些，更明显
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF, // 青色
                    transparent: true,
                    opacity: 0.9, // 提高不透明度
                    blending: THREE.AdditiveBlending
                });
                const pulsarVisual = new THREE.Mesh(geometry, material);

                // 脉冲星光点
                const pulsarLight = new THREE.PointLight(0x00FFFF, 1.5, 1200, 2); // 青色光，强度1.5，距离1200，衰减2
                pulsarVisual.add(pulsarLight);

                // 让脉冲星分布更远，靠近银河盘外缘甚至更远
                const minRadius = galaxyParams.diskRadius * 0.2; // 最小距离为盘面30%
                const maxRadius = galaxyParams.diskRadius * 0.6; // 最大距离为盘面0.9倍
                const radius = minRadius + Math.random() * (maxRadius - minRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 800; // 略微上下浮动，范围更大

                pulsarVisual.position.x = radius * Math.cos(angle);
                pulsarVisual.position.y = height;
                pulsarVisual.position.z = radius * Math.sin(angle);
                
                // 将脉冲星添加到 pulsarsGroup
                pulsarsGroup.add(pulsarVisual);
            }
            return pulsarsGroup;
        }

        // 创建银河系并添加到场景
        galaxy = createGalaxy();
        scene.add(galaxy);

        // === 新增：布满宇宙的3D立体星星 ===
        (function addUniverseStars() {
            const starCount = 10000; // 可根据性能调整数量
            const baseGeometry = new THREE.SphereGeometry(0.5, 5, 5); // 星星基础球体
            const starsMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                specular: 0x111111,
                shininess: 30,
                transparent: true,
                opacity: 1.0,
                vertexColors: true
            });
            const stars = new THREE.InstancedMesh(baseGeometry, starsMaterial, starCount);
            stars.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            const color = new THREE.Color();
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const scale = new THREE.Vector3();
            const colors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                // 随机分布在更大空间，覆盖整个宇宙
                position.set(
                    (Math.random() - 0.5) * 30000,
                    (Math.random() - 0.5) * 30000,
                    (Math.random() - 0.5) * 30000
                );
                // 银河系周围旋转的背景星星
                const size = Math.random() * 10 + 9;
                scale.set(size, size, size);
                // 随机HSL颜色，偏白蓝色，亮度高
                const hue = Math.random() * 0.2 + 0.8;
                const saturation = Math.random() * 0.2 + 0.8;
                const lightness = Math.random() * 0.2 + 0.85; // 更亮
                color.setHSL(hue, saturation, lightness);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                matrix.compose(position, new THREE.Quaternion(), scale);
                stars.setMatrixAt(i, matrix);
                stars.setColorAt(i, color);
            }
            stars.geometry.setAttribute('color', new THREE.InstancedBufferAttribute(colors, 3));
            scene.add(stars);
        })();

        // 获取脉冲星组，以便在动画中控制它们
        const pulsars = [];
        galaxy.children.forEach(group => {
            if (group.children) {
                group.children.forEach(child => {
                    // 检查是否是脉冲星（例如，通过一个特定的属性或名称）
                    // 这里假设 pulsarsGroup 是 createPulsars 返回的组，并且其直接子元素是 pulsarVisual
                    if (child.isMesh && child.children.some(c => c.isPointLight)) {
                        pulsars.push(child);
                    }
                });
            }
        });

        // 光照系统 - 更柔和的环境光，并增强立体感
        const ambientLight = new THREE.AmbientLight(0x404040); // 略微增加环境光，模拟宇宙背景微弱光线，更亮
        scene.add(ambientLight);
        
        // 添加微弱的定向光增强立体感
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.15); // 略微增加定向光强度
        directionalLight.position.set(0.8, 1.2, 0.8).normalize(); // 调整光源方向
        scene.add(directionalLight);
        
        // 添加微弱的半球光模拟宇宙环境光
        const hemisphereLight = new THREE.HemisphereLight(0x7788BB, 0x443322, 0.15); // 调整颜色，天空偏蓝紫，地面偏暗红，强度增加
        scene.add(hemisphereLight);

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 动画循环
        let pulsarTime = 0;
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsed = clock.getElapsedTime();
            
            // 整个银河系旋转
            galaxy.rotation.y += 0.0006; // 稍微降低旋转速度，更宏大

            // 脉冲星闪烁效果
            pulsarTime += 0.15; // 调整闪烁速度，更快一些
            pulsars.forEach((pulsar, index) => {
                const phase = (pulsarTime + index * Math.PI * 0.4) % (Math.PI * 2); // 错开每个脉冲星的闪烁相位
                const scale = 1.0 + Math.sin(phase) * 0.4; // 缩放范围，更明显
                pulsar.scale.set(scale, scale, scale);

                const lightIntensity = 1.0 + Math.sin(phase) * 1.0; // 光照强度范围，更明显
                if (pulsar.children[0] && pulsar.children[0].isPointLight) {
                    pulsar.children[0].intensity = lightIntensity; 
                }
            });

            // 更新宏大特效
            if (window.updateGrandCosmicEffect) {
                window.updateGrandCosmicEffect(elapsed);
            }
            
            // 更新控制器
            controls.update();
            
            // 渲染场景
            renderer.render(scene, camera);
        }

        animate();

        // 初始化新的宏大特效
        if (window.initGrandCosmicEffect) {
            window.initGrandCosmicEffect(scene, camera, controls);
        }

        // ================== 超级宇宙感：右键双击银河光线汇聚特效 ==================
        // 原有的右键双击逻辑已被 galaxy-effect.js 中的长按逻辑替代
        
        // 左键双击监听 - 强制恢复控制
        let lastLeftClickTime = 0;
        let leftClickCount = 0;
        window.addEventListener('mousedown', function(e) {
            if (e.button === 0) { // 左键
                const now = Date.now();
                if (now - lastLeftClickTime < 400) {
                    leftClickCount++;
                } else {
                    leftClickCount = 1;
                }
                lastLeftClickTime = now;
                if (leftClickCount === 2) {
                    leftClickCount = 0;
                    forceRestoreControls(); // 强制恢复控制
                }
            }
        });

        // 强制恢复控制函数
        function forceRestoreControls() {
            // 如果特效仍在运行，也强制恢复控制
            if (cosmicCollapseState.active) {
                console.log("强制恢复控制");
                // 清理所有特效
                cleanupLasersAndParticles();
                cleanupVoidEffects();
                
                // 恢复银河系可见性
                galaxy.visible = true;
                
                // 恢复银河系所有材质
                galaxy.children.forEach(child => {
                    if (child.material && typeof child.material.opacity !== 'undefined' && 
                        child.userData && typeof child.userData.originalOpacity !== 'undefined') {
                        child.material.opacity = child.userData.originalOpacity;
                    }
                    if (child.children) {
                        child.children.forEach(subchild => {
                            if (subchild.material && typeof subchild.material.opacity !== 'undefined' && 
                                subchild.userData && typeof subchild.userData.originalOpacity !== 'undefined') {
                                subchild.material.opacity = subchild.userData.originalOpacity;
                            }
                        });
                    }
                });
                
                // 强制恢复控制器
                controls.enabled = true;
                controls.autoRotate = true;
                
                // 清除所有恢复阶段特效
                if (cosmicCollapseState.restorationCore) {
                    scene.remove(cosmicCollapseState.restorationCore);
                    cosmicCollapseState.restorationCore = null;
                }
                
                if (cosmicCollapseState.restorationBeams) {
                    scene.remove(cosmicCollapseState.restorationBeams);
                    cosmicCollapseState.restorationBeams = null;
                }
                
                if (cosmicCollapseState.smallBeams) {
                    scene.remove(cosmicCollapseState.smallBeams);
                    cosmicCollapseState.smallBeams = null;
                }
                
                if (cosmicCollapseState.restorationWave) {
                    scene.remove(cosmicCollapseState.restorationWave);
                    cosmicCollapseState.restorationWave = null;
                }
                
                if (cosmicCollapseState.restorationParticles) {
                    scene.remove(cosmicCollapseState.restorationParticles.system);
                    cosmicCollapseState.restorationParticles = null;
                }
                
                // 确保场景中没有遗留的平面特效
                scene.children.forEach(child => {
                    // 移除任何着色器材质的平面物体（可能是残留的蓝色光晕）
                    if ((child.isPlane || child.isRing || child.geometry instanceof THREE.PlaneGeometry || 
                         child.geometry instanceof THREE.RingGeometry || child.geometry instanceof THREE.CircleGeometry) && 
                        (child.material && (child.material.isShaderMaterial || 
                                           (child.material.color && 
                                            (child.material.color.b > 0.5 && child.material.color.r < 0.5))))) {
                        console.log("移除残留平面特效", child);
                        scene.remove(child);
                    }
                });
                
                // 重置状态
                cosmicCollapseState.active = false;
                cosmicCollapseState.phase = 'none';
            } else if (galaxyLightRayAnimating) {
                // 如果光线特效正在运行，也强制结束
                galaxyLightRays.forEach(ray => scene.remove(ray.mesh));
                galaxyLightRays = [];
                galaxyLightRayAnimating = false;
            }
            
            // 无论如何都确保控制器可用
            controls.enabled = true;
            controls.autoRotate = true;
            
            // 执行一次全面的清理
            thoroughCleanup();
        }
        
        // 全面清理所有可能的特效残留
        function thoroughCleanup() {
            // 清理所有特效相关对象
            cleanupLasersAndParticles();
            cleanupVoidEffects();
            
            // 尝试清理所有可能的蓝色平面
            const objectsToRemove = [];
            
            // 递归函数检查对象及其子对象
            function checkAndMarkForRemoval(obj) {
                // 检查是否是可能的蓝色平面/光晕
                if ((obj.isPlane || obj.isRing || obj.isMesh || obj.isPoints) && 
                    obj.material && (
                        // 着色器材质
                        obj.material.isShaderMaterial || 
                        // 或者蓝色基础材质
                        (obj.material.color && obj.material.color.b > 0.5 && obj.material.color.r < 0.5) ||
                        // 或者有蓝色相关的uniform
                        (obj.material.uniforms && (
                            (obj.material.uniforms.color && obj.material.uniforms.color.value && 
                             obj.material.uniforms.color.value.b > 0.5) ||
                            (obj.material.uniforms.color1 && obj.material.uniforms.color1.value && 
                             obj.material.uniforms.color1.value.b > 0.5) ||
                            (obj.material.uniforms.color2 && obj.material.uniforms.color2.value && 
                             obj.material.uniforms.color2.value.b > 0.5)
                        ))
                    )) {
                    objectsToRemove.push(obj);
                }
                
                // 递归检查所有子对象
                if (obj.children && obj.children.length > 0) {
                    obj.children.forEach(child => checkAndMarkForRemoval(child));
                }
            }
            
            // 检查场景中所有对象
            scene.children.forEach(obj => checkAndMarkForRemoval(obj));
            
            // 从场景中移除标记的对象
            objectsToRemove.forEach(obj => {
                console.log("移除可能的特效残留:", obj);
                scene.remove(obj);
                if (obj.material) {
                    if (obj.material.dispose) obj.material.dispose();
                }
                if (obj.geometry) {
                    if (obj.geometry.dispose) obj.geometry.dispose();
                }
            });
            
            // 强制更新场景
            renderer.render(scene, camera);
        }

        // 2. 获取银河系中心坐标（黑洞位置）
        function getGalaxyCoreWorldPosition() {
            // 黑洞是galaxy的第一个子对象
            const blackHole = galaxy.children[0];
            const pos = new THREE.Vector3();
            blackHole.getWorldPosition(pos);
            return pos;
        }

        // 3. 获取所有星系（银河、背景星系、球状星团、脉冲星等）及其主色
        function collectAllGalacticObjects() {
            const objects = [];
            // 1. 银河本体（螺旋臂、核心、尘埃、晕）
            galaxy.children.forEach(child => {
                // 只收集Points类型（恒星云、尘埃、晕等）
                if (child.isPoints && child.geometry && child.material) {
                    // 取几何中心
                    const pos = new THREE.Vector3();
                    child.getWorldPosition(pos);
                    // 取主色（取材质第一个颜色或平均色）
                    let color = new THREE.Color(1,1,1);
                    if (child.material.vertexColors && child.geometry.attributes.color) {
                        // 取前1000个点的平均色
                        const colors = child.geometry.attributes.color.array;
                        let r=0,g=0,b=0,n=Math.min(1000,colors.length/3);
                        for(let i=0;i<n;i++){
                            r+=colors[i*3];g+=colors[i*3+1];b+=colors[i*3+2];
                        }
                        color.setRGB(r/n,g/n,b/n);
                    } else if (child.material.color) {
                        color.copy(child.material.color);
                    }
                    objects.push({pos,color});
                }
                // 也收集Mesh类型（如脉冲星、黑洞等）
                if (child.isMesh && child.material) {
                    const pos = new THREE.Vector3();
                    child.getWorldPosition(pos);
                    let color = new THREE.Color(1,1,1);
                    if (child.material.color) color.copy(child.material.color);
                    objects.push({pos,color});
                }
                // 递归收集子组（如球状星团、脉冲星组等）
                if (child.isGroup && child.children) {
                    child.children.forEach(sub => {
                        if (sub.isPoints && sub.geometry && sub.material) {
                            const pos = new THREE.Vector3();
                            sub.getWorldPosition(pos);
                            let color = new THREE.Color(1,1,1);
                            if (sub.material.vertexColors && sub.geometry.attributes.color) {
                                const colors = sub.geometry.attributes.color.array;
                                let r=0,g=0,b=0,n=Math.min(1000,colors.length/3);
                                for(let i=0;i<n;i++){
                                    r+=colors[i*3];g+=colors[i*3+1];b+=colors[i*3+2];
                                }
                                color.setRGB(r/n,g/n,b/n);
                            } else if (sub.material.color) {
                                color.copy(sub.material.color);
                            }
                            objects.push({pos,color});
                        }
                        if (sub.isMesh && sub.material) {
                            const pos = new THREE.Vector3();
                            sub.getWorldPosition(pos);
                            let color = new THREE.Color(1,1,1);
                            if (sub.material.color) color.copy(sub.material.color);
                            objects.push({pos,color});
                        }
                    });
                }
            });
            // 2. 背景星系
            scene.children.forEach(obj => {
                if (obj.isGroup && obj !== galaxy) {
                    // 只收集背景星系组
                    obj.children && obj.children.forEach(bg => {
                        if (bg.isGroup && bg.children[0] && bg.children[0].isPoints) {
                            // 取星系中心
                            const pos = new THREE.Vector3();
                            bg.getWorldPosition(pos);
                            // 取主色
                            let color = new THREE.Color(1,1,1);
                            const points = bg.children[0];
                            if (points.material.vertexColors && points.geometry.attributes.color) {
                                const colors = points.geometry.attributes.color.array;
                                let r=0,g=0,b=0,n=Math.min(1000,colors.length/3);
                                for(let i=0;i<n;i++){
                                    r+=colors[i*3];g+=colors[i*3+1];b+=colors[i*3+2];
                                }
                                color.setRGB(r/n,g/n,b/n);
                            } else if (points.material.color) {
                                color.copy(points.material.color);
                            }
                            objects.push({pos,color});
                        }
                    });
                }
            });
            return objects;
        }

        // 4. 光线特效生成与动画
        let galaxyLightRays = [];
        function triggerGalaxyLightRays() {
            // 检查是否已经在动画中或宇宙坍缩状态
            if (galaxyLightRayAnimating || (window.cosmicCollapseState && window.cosmicCollapseState.active)) {
                console.log("特效已经在运行中，不重复触发");
                return;
            }
            
            console.log("触发银河光线特效");
            
            // 清理旧光线
            galaxyLightRays.forEach(ray => scene.remove(ray.mesh));
            galaxyLightRays = [];
            // 获取所有星系对象
            const galacticObjects = collectAllGalacticObjects();
            const corePos = getGalaxyCoreWorldPosition();
            // 每个星系发射多条光线
            galacticObjects.forEach(({pos, color}) => {
                const rayCount = 20 + Math.floor(Math.random()*9); // 每个星系发射20-29条光线
                for(let i=0;i<rayCount;i++){
                    // 起点为星系中心，终点为银河系中心
                    const start = pos.clone();
                    const end = corePos.clone();
                    // 曲线路径：加入宇宙感的弯曲、波动
                    const mid = start.clone().lerp(end, 0.5);
                    // 在中点附近加扰动，制造空间波动感
                    const offset = new THREE.Vector3(
                        (Math.random()-0.5)*3000,
                        (Math.random()-0.5)*3000,
                        (Math.random()-0.5)*3000
                    );
                    mid.add(offset);
                    // 生成CatmullRom曲线
                    const curve = new THREE.CatmullRomCurve3([
                        start,
                        mid,
                        end
                    ]);
                    // 采样点数
                    const points = curve.getPoints(120);
                    // 生成几何体
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    // 颜色渐变：头部为星系主色，尾部为中心极暗金色
                    const colors = [];
                    const alphas = [];
                    for(let j=0;j<points.length;j++){
                        const t = j/(points.length-1);
                        // 渐变到银河中心极暗金色，几乎不变色
                        const c = color.clone().lerp(new THREE.Color(0x332200), t*0.00000001);
                        colors.push(c.r, c.g, c.b);
                        // 从中间向中心渐变消失，扩大不可见区域
                        if (t > 0.70) {
                            // 渐变过渡区域：0.70-0.85之间平滑过渡为不可见
                            const fadeT = (t - 0.70) / (0.85 - 0.70);
                            alphas.push(Math.max(0, 1.0 - fadeT * fadeT * 1.5));
                        } else {
                            alphas.push(1.0);
                        }
                    }
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    geometry.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));
                    // 材质
                    const material = new THREE.LineBasicMaterial({
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.28 + Math.random()*0.12, // 降低整体亮度，从0.38降至0.28
                        blending: THREE.AdditiveBlending,
                        linewidth: 2 // 仅WebGL2有效
                    });
                    // 创建Line
                    const line = new THREE.Line(geometry, material);
                    // 叠加星尘粒子流（用Points）
                    const particleCount = 60 + Math.floor(Math.random()*40);
                    const particlePositions = [];
                    const particleColors = [];
                    const particleAlphas = [];
                    for(let k=0;k<particleCount;k++){
                        const t = k/(particleCount-1);
                        const p = curve.getPoint(t);
                        particlePositions.push(p.x, p.y, p.z);
                        // 粒子颜色：主色到极暗金色渐变
                        const c = color.clone().lerp(new THREE.Color(0x332200), t*0.00000001);
                        particleColors.push(c.r, c.g, c.b);
                        // 从中间向中心渐变消失，扩大不可见区域
                        if (t > 0.70) {
                            // 渐变过渡区域：0.70-0.85之间平滑过渡为不可见
                            const fadeT = (t - 0.70) / (0.85 - 0.70);
                            particleAlphas.push(Math.max(0, 1.0 - fadeT * fadeT * 1.5));
                        } else {
                            particleAlphas.push(1.0);
                        }
                    }
                    const particleGeometry = new THREE.BufferGeometry();
                    particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
                    particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
                    particleGeometry.setAttribute('alpha', new THREE.Float32BufferAttribute(particleAlphas, 1));
                    const particleMaterial = new THREE.PointsMaterial({
                        size: 32 + Math.random()*18,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.12 + Math.random()*0.08, // 降低整体亮度，从0.18降至0.12
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });
                    const pointsObj = new THREE.Points(particleGeometry, particleMaterial);
                    // 组合为组
                    const group = new THREE.Group();
                    group.add(line);
                    group.add(pointsObj);
                    scene.add(group);
                    // 存储动画数据
                    galaxyLightRays.push({mesh: group, curve, color, start, end, t: 0, particleGeometry, pointsObj});
                }
            });
            // 触发动画
            galaxyLightRayAnimating = true;
            galaxyLightRayStartTime = performance.now();
        }

        // 将函数暴露为全局函数，方便从galaxy-effect.js中调用
        window.triggerGalaxyLightRays = triggerGalaxyLightRays;

        // 5. 动画循环与自动清理
        let galaxyLightRayAnimating = false;
        let galaxyLightRayStartTime = 0;
        function animateGalaxyLightRays() {
            if (!galaxyLightRayAnimating) return;
            const now = performance.now();
            const duration = 25000; // 延长动画总时长从20000到25000
            const fadeDuration = 15000; // 延长消散时长从12000到15000
            const t = Math.min(1, (now - galaxyLightRayStartTime) / duration);
            // 动态更新每条光线
            galaxyLightRays.forEach(ray => {
                // 粒子透明度渐变+中心段完全不可见
                const alphaAttr = ray.particleGeometry.attributes.alpha;
                const mat = ray.pointsObj.material;
                let maxAlpha = 0;
                for(let i=0;i<alphaAttr.count;i++){
                    let baseAlpha = alphaAttr.array[i];
                    if (baseAlpha > maxAlpha) maxAlpha = baseAlpha;
                }
                mat.opacity = (0.12 + Math.sin(t*Math.PI)*0.08) * maxAlpha; // 降低亮度从0.18到0.12
                // 线的透明度渐变+中心段完全不可见
                const lineAlphaAttr = ray.mesh.children[0].geometry.attributes.alpha;
                let lineMaxAlpha = 0;
                for(let i=0;i<lineAlphaAttr.count;i++){
                    if (lineAlphaAttr.array[i] > lineMaxAlpha) lineMaxAlpha = lineAlphaAttr.array[i];
                }
                ray.mesh.children[0].material.opacity = (0.28 + Math.sin(t*Math.PI)*0.12) * lineMaxAlpha; // 降低亮度从0.38到0.28
            });
            // 动画结束后自动消散
            if (t >= 1) {
                const fadeT = Math.min(1, (now - galaxyLightRayStartTime - duration) / fadeDuration);
                galaxyLightRays.forEach(ray => {
                    ray.mesh.children.forEach(obj => {
                        if (obj.material) {
                            obj.material.opacity = (1-fadeT) * (0.28 + 0.12); // 调整fade透明度，从0.38到0.28
                        }
                    });
                    ray.pointsObj.material.opacity = (1-fadeT) * (0.12 + 0.08); // 调整fade透明度，从0.18到0.12
                });
                
                // 当光线接近完全消失时（70%淡出），开始准备触发下一阶段
                // 这样可以确保激光效果完全无缝衔接，避免中间出现断开
                if (fadeT >= 0.70 && !cosmicCollapseState.active) {
                    // 当光线大部分消失后，触发垂直激光射线和宇宙坍缩特效
                    triggerCosmicCollapse();
                }
                
                // 完全消失后清理资源
                if (fadeT >= 1) {
                    galaxyLightRays.forEach(ray => scene.remove(ray.mesh));
                    galaxyLightRays = [];
                    galaxyLightRayAnimating = false;
                }
            }
        }
        
        // ================== 宇宙坍缩特效 ==================
        // 状态变量
        let cosmicCollapseState = {
            active: false,         // 特效是否激活
            startTime: 0,          // 开始时间
            phase: 'none',         // 当前阶段：none, laser, collapse, void, restore
            verticalLasers: [],    // 垂直激光对象数组
            collapseParticles: [], // 坍缩粒子对象数组
            originalState: null,   // 存储原始状态以便恢复
            voidSphere: null       // 虚空球体
        };
        
        // 触发宇宙坍缩特效
        function triggerCosmicCollapse() {
            // 避免重复触发或过早触发
            if (cosmicCollapseState.active) return;
            
            // 确保新效果启动之前，旧效果已经基本淡出
            // 添加一个小延迟，确保过渡平滑
            if (galaxyLightRayAnimating) {
                const now = performance.now();
                const t = (now - galaxyLightRayStartTime) / 25000; // 匹配新的duration
                const fadeT = t >= 1 ? Math.min(1, (now - galaxyLightRayStartTime - 25000) / 15000) : 0; // 匹配新的时间
                
                if (t < 1 || fadeT < 0.85) {
                    // 如果前一效果未结束，则延迟后再尝试触发
                    // 设置更短的延迟时间，确保更平滑衔接
                    setTimeout(triggerCosmicCollapse, 100);
                    return;
                }
            }
            
            // 在开始新效果前先清理所有现有效果，确保干净的开始
            cleanupLasersAndParticles();
            
            // 添加延迟，以确保渲染循环中的顺序正确
            setTimeout(() => {
                console.log("触发宇宙坍缩特效");
                cosmicCollapseState.active = true;
                cosmicCollapseState.startTime = performance.now();
                cosmicCollapseState.phase = 'laser';
                
                // 保存原始状态以便恢复
                cosmicCollapseState.originalState = {
                    galaxyVisible: galaxy.visible,
                    galaxyPosition: galaxy.position.clone(),
                    galaxyRotation: {
                        x: galaxy.rotation.x,
                        y: galaxy.rotation.y,
                        z: galaxy.rotation.z
                    },
                    cameraPosition: camera.position.clone(),
                    controlsEnabled: controls.enabled,
                    controlsAutoRotate: controls.autoRotate
                };
                
                // 禁用轨道控制器，防止用户干扰动画
                controls.enabled = false;
                controls.autoRotate = false;
                
                // 创建垂直激光射线
                createVerticalLasers();
            }, 50);
        }
        
        // 创建垂直激光射线
        function createVerticalLasers() {
            // 获取银河系中心位置
            const corePos = getGalaxyCoreWorldPosition();
            
            // 创建多道垂直激光 - 大幅增加数量以覆盖整个银河系
            const laserCount = 1500; // 增加激光数量到条，更加壮观
            const baseRadius = galaxyParams.diskRadius * 0.9; // 激光覆盖整个银河系盘面
            const heightVariation = 30000; // 增加高度变化，更加宏大
            const laserColors = [
                0x0088FF, 0x00BBFF, 0x00FFFF, 0x55FFFF, 
                0x88DDFF, 0x0044FF, 0x00AAEE, 0x66CCFF
            ];
            
            // 创建由中心向外扩散的光芒效果
            const radialLaserCount = 1500; // 36道径向激光
            const radialSegments = 5; // 每道径向激光分成5段
            
            // 从中心发散的径向激光
            for (let i = 0; i < radialLaserCount; i++) {
                const angle = (i / radialLaserCount) * Math.PI * 2;
                const radialColor = laserColors[i % laserColors.length];
                
                // 创建分段激光，实现亮度递减效果
                for (let j = 0; j < radialSegments; j++) {
                    const startDistance = j * (baseRadius / radialSegments);
                    const endDistance = (j + 1) * (baseRadius / radialSegments);
                    
                    // 计算起始和结束点
                    const startPos = new THREE.Vector3(
                        corePos.x + Math.cos(angle) * startDistance,
                        corePos.y,
                        corePos.z + Math.sin(angle) * startDistance
                    );
                    
                    const endPos = new THREE.Vector3(
                        corePos.x + Math.cos(angle) * endDistance,
                        corePos.y,
                        corePos.z + Math.sin(angle) * endDistance
                    );
                    
                    // 亮度随距离中心远近递减
                    const opacityFactor = 1 - (j / radialSegments) * 0.7;
                    const sizeFactor = 1 - (j / radialSegments) * 0.5;
                    
                    // 创建平面径向激光
                    const radialLaser = createLaserBeam(startPos, endPos, radialColor, opacityFactor, sizeFactor);
                    scene.add(radialLaser);
                    
                    // 存储径向激光对象
                    cosmicCollapseState.radialLasers = cosmicCollapseState.radialLasers || [];
                    cosmicCollapseState.radialLasers.push(radialLaser);
                }
            }
            
            // 为整个银河系盘面随机生成垂直激光
            for (let i = 0; i < laserCount; i++) {
                // 在银河系盘面上分布，密度随距离中心远近变化
                const t = Math.pow(Math.random(), 1.5); // 使激光在中心区域更密集
                const radius = t * baseRadius;
                const angle = Math.random() * Math.PI * 2;
                
                const startPos = new THREE.Vector3(
                    corePos.x + Math.cos(angle) * radius,
                    corePos.y,
                    corePos.z + Math.sin(angle) * radius
                );
                
                // 激光高度（上下对称）与到中心距离成正比
                const heightBase = 10000 + Math.random() * heightVariation;
                const height = heightBase * (0.5 + 0.5 * t); // 越靠近边缘的激光越长
                
                // 亮度随距离中心远近递减
                const opacityFactor = 1 - t * 0.6; // 中心区域更亮
                const sizeFactor = 1 - t * 0.3; // 中心区域更粗
                
                // 创建向上的激光
                const upEndPos = new THREE.Vector3(
                    startPos.x,
                    startPos.y + height,
                    startPos.z
                );
                
                // 创建向下的激光
                const downEndPos = new THREE.Vector3(
                    startPos.x,
                    startPos.y - height,
                    startPos.z
                );
                
                // 随机选择激光颜色
                const colorIndex = Math.floor(Math.random() * laserColors.length);
                const laserColor = laserColors[colorIndex];
                
                // 创建激光射线，应用亮度因子
                const upLaser = createLaserBeam(startPos, upEndPos, laserColor, opacityFactor, sizeFactor);
                const downLaser = createLaserBeam(startPos, downEndPos, laserColor, opacityFactor, sizeFactor);
                
                // 添加到场景
                scene.add(upLaser);
                scene.add(downLaser);
                
                // 存储激光对象
                cosmicCollapseState.verticalLasers.push(upLaser, downLaser);
            }
            
            // 创建中心能量球 - 更加强大
            createCoreEnergySphere(corePos);
            
            // 创建银河系发光盘面
            createGalaxyLuminousDisk(corePos, baseRadius);
        }
        
        // 创建激光射线
        function createLaserBeam(startPos, endPos, color, opacityFactor = 1.0, sizeFactor = 1.0) {
            // 创建激光几何体（线段）
            const laserGeometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                startPos.x, startPos.y, startPos.z,
                endPos.x, endPos.y, endPos.z
            ]);
            laserGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            // 创建激光材质
            const laserMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.22, // 初始时就有较高可见度，确保过渡顺滑
                linewidth: 2,
                blending: THREE.AdditiveBlending
            });
            
            // 创建激光线
            const laserLine = new THREE.Line(laserGeometry, laserMaterial);
            
            // 添加发光效果
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(color) },
                    opacity: { value: 0.12 } // 初始就有较高发光效果
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float opacity;
                    varying vec3 vPosition;
                    void main() {
                        float intensity = opacity * 0.8;
                        gl_FragColor = vec4(color, intensity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建粗一点的发光线，粗细由sizeFactor决定
            const glowGeometry = new THREE.TubeBufferGeometry(
                new THREE.LineCurve3(
                    new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                    new THREE.Vector3(endPos.x, endPos.y, endPos.z)
                ),
                20, // 分段数
                15 * sizeFactor, // 管径乘以大小因子
                8,  // 管径分段
                false // 闭合
            );
            const glowLine = new THREE.Mesh(glowGeometry, glowMaterial);
            
            // 组合成组
            const laserGroup = new THREE.Group();
            laserGroup.add(laserLine);
            laserGroup.add(glowLine);
            
            // 添加额外数据
            laserGroup.userData = {
                startPos: startPos.clone(),
                endPos: endPos.clone(),
                lineMaterial: laserMaterial,
                glowMaterial: glowMaterial,
                color: color,
                opacityFactor: opacityFactor, // 保存亮度因子
                sizeFactor: sizeFactor // 保存大小因子
            };
            
            return laserGroup;
        }
        
        // 创建银河系发光盘面
        function createGalaxyLuminousDisk(position, radius) {
            // 创建盘面几何体
            const diskGeometry = new THREE.CircleGeometry(radius, 128);
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0x0088FF) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    // 噪声函数
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }
                    
                    void main() {
                        // 从中心计算距离
                        vec2 center = vec2(0.5, 0.5);
                        float dist = length(vUv - center) * 2.0;
                        
                        // 创建环状波纹
                        float rings = sin(dist * 15.0 - time * 0.5) * 0.5 + 0.5;
                        
                        // 噪声扰动
                        float noiseVal = noise(vUv * 10.0 + time * 0.1) * 0.1;
                        
                        // 径向渐变 + 环状波纹 + 噪声
                        float alpha = (1.0 - dist) * 0.15 * rings + noiseVal * 0.05;
                        alpha = smoothstep(0.0, 0.1, alpha) * alpha;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.position.copy(position);
            disk.rotation.x = -Math.PI / 2; // 水平放置
            
            // 添加到场景
            scene.add(disk);
            
            // 存储到状态中
            cosmicCollapseState.galaxyDisk = disk;
        }
        
        // 创建中心能量球
        function createCoreEnergySphere(position) {
            // 创建核心能量球几何体
            const sphereGeometry = new THREE.SphereGeometry(400, 64, 64);
            const sphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0x00FFFF) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    
                    // 噪声函数
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }
                    
                    float fbm(vec2 p) {
                        float sum = 0.0;
                        float amp = 1.0;
                        float freq = 1.0;
                        for (int i = 0; i < 4; i++) {
                            sum += amp * noise(p * freq);
                            amp *= 0.5;
                            freq *= 2.0;
                            p = p * 1.1 + vec2(time * 0.05, 0.0);
                        }
                        return sum;
                    }
                    
                    void main() {
                        // 计算法线贡献
                        vec3 normal = normalize(vNormal);
                        float rim = 1.0 - max(dot(normalize(normal), vec3(0.0, 0.0, 1.0)), 0.0);
                        rim = pow(rim, 2.0) * 0.8;
                        
                        // 添加分形噪声
                        float noiseVal = fbm(vUv * 4.0 + time * 0.1);
                        
                        // 脉冲效果
                        float pulse = (sin(time * 2.0) * 0.5 + 0.5) * 0.3;
                        
                        // 环状波纹
                        float rings = sin(length(vUv - vec2(0.5, 0.5)) * 20.0 - time * 3.0) * 0.5 + 0.5;
                        
                        // 组合效果
                        float glow = rim + noiseVal * 0.2 + pulse + rings * 0.3;
                        
                        // 输出颜色
                        gl_FragColor = vec4(color, glow * 0.7);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const energySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            energySphere.position.copy(position);
            
            // 内部光源
            const light = new THREE.PointLight(0x00FFFF, 2.0, 2000);
            energySphere.add(light);
            
            // 添加到场景
            scene.add(energySphere);
            
            // 存储到状态中
            cosmicCollapseState.energySphere = energySphere;
        }

        // 创建坍缩粒子效果
        function createCollapseParticles() {
            // 获取银河系中心位置
            const corePos = getGalaxyCoreWorldPosition();
            
            // 1. 主坍缩粒子系统 - 大幅增加粒子数量
            createMainCollapseParticles(corePos, 30000); // 增加到30000个主粒子
            
            // 2. 创建螺旋能量波动粒子
            createEnergyWaveParticles(corePos, galaxyParams.diskRadius * 1.5, 15000); // 15000个能量波动粒子
            
            // 3. 创建能量冲击波粒子
            createShockwaveParticles(corePos, 8000); // 8000个冲击波粒子
            
            // 4. 创建空间撕裂效果
            createSpaceRiftParticles(corePos, 5000); // 5000个空间撕裂粒子
            
            // 5. 创建能量残影效果
            createEnergyTrailParticles(corePos, 12000); // 12000个能量残影粒子
            
            // 6. 创建量子波动粒子
            createQuantumFluctuationParticles(corePos, 20000); // 20000个量子波动粒子
        }
        
        // 创建主坍缩粒子
        function createMainCollapseParticles(corePos, particleCount) {
            // 创建粒子几何体
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // 随机分布在银河系周围的球形空间内
            const distributionRadius = galaxyParams.diskRadius * 2.0; // 分布范围更大
            
            // 用于控制分布密度的函数
            function distributionFn(x) {
                // 在中心和边缘都有较高密度，中间区域较低密度
                return 0.2 + 0.5 * Math.sin(x * Math.PI) + 0.3 * Math.random();
            }
            
            for (let i = 0; i < particleCount; i++) {
                // 球坐标，使用更复杂的分布
                const r = Math.random();
                const normalizedRadius = distributionFn(r) * distributionRadius;
                const theta = Math.random() * Math.PI * 2;
                
                // 使粒子分布更接近银河系平面
                const phi = (Math.random() * 0.4 + 0.3) * Math.PI; // 更集中在赤道平面附近
                
                // 直角坐标
                const x = normalizedRadius * Math.sin(phi) * Math.cos(theta);
                const y = normalizedRadius * Math.sin(phi) * Math.sin(theta) * (Math.random() < 0.5 ? 0.2 : 1.0); // Y轴压缩，形成盘状
                const z = normalizedRadius * Math.cos(phi);
                
                // 设置初始位置（以银河系中心为参考点）
                positions[i * 3] = corePos.x + x;
                positions[i * 3 + 1] = corePos.y + y;
                positions[i * 3 + 2] = corePos.z + z;
                
                // 随机颜色（更丰富的色彩）
                let hue, saturation, lightness;
                
                // 给20%的粒子分配与银河系核心相似的亮蓝色
                if (Math.random() < 0.2) {
                    hue = 0.6 + (Math.random() - 0.5) * 0.1; // 蓝色范围
                    saturation = 0.9 + Math.random() * 0.1;
                    lightness = 0.6 + Math.random() * 0.3;
                }
                // 给30%的粒子分配星臂类似的冷色调
                else if (Math.random() < 0.5) {
                    hue = 0.5 + (Math.random() - 0.5) * 0.3; // 青色到紫色范围
                    saturation = 0.7 + Math.random() * 0.3;
                    lightness = 0.4 + Math.random() * 0.3;
                }
                // 给剩余粒子分配星尘类似的暖色调
                else {
                    hue = 0.05 + (Math.random() - 0.5) * 0.1; // 金色到浅橙色范围
                    saturation = 0.6 + Math.random() * 0.4;
                    lightness = 0.3 + Math.random() * 0.3;
                }
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                // 随机大小（更大范围）
                sizes[i] = 10 + Math.pow(Math.random(), 2) * 120; // 更多小粒子，少量大粒子
            }
            
            // 设置属性
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // 粒子材质
            const particleMaterial = new THREE.PointsMaterial({
                size: 40, // 整体更大
                vertexColors: true,
                transparent: true,
                opacity: 0.0, // 初始不可见
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建粒子系统
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            
            // 添加到场景
            scene.add(particleSystem);
            
            // 存储到状态中
            cosmicCollapseState.collapseParticles.push({
                system: particleSystem,
                originalPositions: positions.slice(), // 保存初始位置副本以便动画
                targetPositions: new Float32Array(positions.length), // 目标位置（将在动画中设置）
                type: 'main' // 标记类型
            });
            
            // 设置粒子的目标位置（全部坍缩到中心点）
            const targetPositions = cosmicCollapseState.collapseParticles[cosmicCollapseState.collapseParticles.length-1].targetPositions;
            for (let i = 0; i < particleCount; i++) {
                targetPositions[i * 3] = corePos.x;
                targetPositions[i * 3 + 1] = corePos.y;
                targetPositions[i * 3 + 2] = corePos.z;
            }
        }
        
        // 创建能量波动粒子
        function createEnergyWaveParticles(corePos, radius, waveParticleCount) {
            // 创建粒子几何体
            const waveGeometry = new THREE.BufferGeometry();
            const wavePositions = new Float32Array(waveParticleCount * 3);
            const waveColors = new Float32Array(waveParticleCount * 3);
            const waveSizes = new Float32Array(waveParticleCount);
            
            // 在螺旋形状中分布粒子
            for (let i = 0; i < waveParticleCount; i++) {
                // 螺旋参数
                const t = i / waveParticleCount; // 归一化索引
                const spiralRadius = radius * 0.1 + t * radius * 1.0; // 螺旋半径
                const angle = t * Math.PI * 20; // 螺旋角度
                const heightVar = (Math.random() - 0.5) * radius * 0.2; // 高度变化
                
                wavePositions[i * 3] = corePos.x + spiralRadius * Math.cos(angle);
                wavePositions[i * 3 + 1] = corePos.y + heightVar;
                wavePositions[i * 3 + 2] = corePos.z + spiralRadius * Math.sin(angle);
                
                // 明亮的蓝白色系
                const hue = 0.55 + (Math.random() - 0.5) * 0.1; // 蓝色范围
                const saturation = 0.8 + Math.random() * 0.2;
                const lightness = 0.7 + Math.random() * 0.3;
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                waveColors[i * 3] = color.r;
                waveColors[i * 3 + 1] = color.g;
                waveColors[i * 3 + 2] = color.b;
                
                // 大小随螺旋距离变化
                waveSizes[i] = 10 + (1 - t) * 80; // 越靠近中心越大
            }
            
            // 设置属性
            waveGeometry.setAttribute('position', new THREE.BufferAttribute(wavePositions, 3));
            waveGeometry.setAttribute('color', new THREE.BufferAttribute(waveColors, 3));
            waveGeometry.setAttribute('size', new THREE.BufferAttribute(waveSizes, 1));
            
            // 粒子材质
            const waveMaterial = new THREE.PointsMaterial({
                size: 30,
                vertexColors: true,
                transparent: true,
                opacity: 0.0, // 初始不可见
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建粒子系统
            const waveSystem = new THREE.Points(waveGeometry, waveMaterial);
            
            // 添加到场景
            scene.add(waveSystem);
            
            // 存储到状态中
            cosmicCollapseState.collapseParticles.push({
                system: waveSystem,
                originalPositions: wavePositions.slice(),
                targetPositions: new Float32Array(wavePositions.length), // 目标位置（螺旋收缩到中心）
                type: 'wave' // 标记类型
            });
            
            // 设置波动粒子的目标位置（螺旋收缩）
            const waveTargets = cosmicCollapseState.collapseParticles[cosmicCollapseState.collapseParticles.length-1].targetPositions;
            for (let i = 0; i < waveParticleCount; i++) {
                waveTargets[i * 3] = corePos.x;
                waveTargets[i * 3 + 1] = corePos.y;
                waveTargets[i * 3 + 2] = corePos.z;
            }
        }
        
        // 创建能量冲击波粒子
        function createShockwaveParticles(corePos, particleCount) {
            // 创建几何体
            const shockGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // 创建一个冲击波型的粒子分布
            for (let i = 0; i < particleCount; i++) {
                // 在圆盘状冲击波上分布粒子
                const radius = galaxyParams.diskRadius * (0.5 + Math.random() * 0.5);
                const angle = Math.random() * Math.PI * 2;
                const thickness = (Math.random() - 0.5) * galaxyParams.diskRadius * 0.1;
                
                // 位置
                positions[i * 3] = corePos.x + radius * Math.cos(angle);
                positions[i * 3 + 1] = corePos.y + thickness;
                positions[i * 3 + 2] = corePos.z + radius * Math.sin(angle);
                
                // 颜色 - 能量冲击波使用明亮的蓝紫色
                const hue = 0.72 + (Math.random() - 0.5) * 0.08; // 紫色范围
                const saturation = 0.9 + Math.random() * 0.1;
                const lightness = 0.5 + Math.random() * 0.3;
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                // 大小 - 冲击波粒子较大
                sizes[i] = 60 + Math.random() * 100;
            }
            
            // 设置属性
            shockGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            shockGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            shockGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // 创建材质 - 使用自定义着色器以获得更好的波动效果
            const shockMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: null },
                    time: { value: 0 },
                    opacity: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vColor;
                    
                    void main() {
                        // 创建圆形粒子
                        float r = 0.0, delta = 0.0, alpha = 1.0;
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        r = dot(cxy, cxy);
                        
                        if (r > 1.0) {
                            discard;
                        }
                        
                        // 创建发光效果
                        delta = 1.0 - r;
                        alpha = opacity * smoothstep(0.0, 1.0, delta * 2.0);
                        
                        // 脉冲效果
                        float pulse = sin(time * 10.0 + r * 5.0) * 0.5 + 0.5;
                        alpha *= pulse * 0.3 + 0.7;
                        
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true
            });
            
            // 创建粒子系统
            const shockSystem = new THREE.Points(shockGeometry, shockMaterial);
            
            // 添加到场景
            scene.add(shockSystem);
            
            // 存储到状态中
            cosmicCollapseState.collapseParticles.push({
                system: shockSystem,
                originalPositions: positions.slice(),
                targetPositions: new Float32Array(positions.length),
                type: 'shockwave'
            });
            
            // 设置目标位置 - 冲击波粒子会在坍缩过程中向外扩散，然后再向内坍缩
            const targetPositions = cosmicCollapseState.collapseParticles[cosmicCollapseState.collapseParticles.length-1].targetPositions;
            for (let i = 0; i < particleCount; i++) {
                targetPositions[i * 3] = corePos.x;
                targetPositions[i * 3 + 1] = corePos.y;
                targetPositions[i * 3 + 2] = corePos.z;
            }
        }
        
        // 创建空间撕裂效果
        function createSpaceRiftParticles(corePos, particleCount) {
            // 创建几何体
            const riftGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // 创建撕裂状的分布
            for (let i = 0; i < particleCount; i++) {
                // 随机选择一条撕裂线
                const riftCount = 12; // 创建12条撕裂线
                const riftIndex = Math.floor(Math.random() * riftCount);
                const riftAngle = (riftIndex / riftCount) * Math.PI * 2;
                
                // 沿撕裂线随机分布
                const radius = (Math.random() * 0.6 + 0.3) * galaxyParams.diskRadius * 2.0;
                const thickness = Math.pow(Math.random(), 2) * 1500; // 撕裂线厚度
                
                // 扭曲撕裂线形状
                const twist = Math.sin(radius * 0.0005) * Math.PI * 0.3;
                const pulseShape = Math.sin(radius * 0.001) * 1000;
                
                positions[i * 3] = corePos.x + radius * Math.cos(riftAngle + twist);
                positions[i * 3 + 1] = corePos.y + (Math.random() - 0.5) * thickness + pulseShape;
                positions[i * 3 + 2] = corePos.z + radius * Math.sin(riftAngle + twist);
                
                // 颜色 - 深蓝带红紫色调
                const hue = (0.65 + (Math.random() - 0.5) * 0.1) % 1.0; // 深蓝到紫色
                const saturation = 0.8 + Math.random() * 0.2;
                const lightness = 0.3 + Math.random() * 0.4;
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                // 尺寸 - 边缘较大
                sizes[i] = 15 + Math.random() * 60;
            }
            
            // 设置属性
            riftGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            riftGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            riftGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // 材质
            const riftMaterial = new THREE.PointsMaterial({
                size: 40,
                vertexColors: true,
                transparent: true,
                opacity: 0.0, // 初始不可见
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建粒子系统
            const riftSystem = new THREE.Points(riftGeometry, riftMaterial);
            
            // 添加到场景
            scene.add(riftSystem);
            
            // 存储到状态中
            cosmicCollapseState.collapseParticles.push({
                system: riftSystem,
                originalPositions: positions.slice(),
                targetPositions: new Float32Array(positions.length),
                type: 'rift'
            });
            
            // 设置目标位置 - 撕裂粒子最终也会坍缩到中心点
            const targetPositions = cosmicCollapseState.collapseParticles[cosmicCollapseState.collapseParticles.length-1].targetPositions;
            for (let i = 0; i < particleCount; i++) {
                targetPositions[i * 3] = corePos.x;
                targetPositions[i * 3 + 1] = corePos.y;
                targetPositions[i * 3 + 2] = corePos.z;
            }
        }
        
        // 创建能量残影效果
        function createEnergyTrailParticles(corePos, particleCount) {
            // 创建几何体
            const trailGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // 创建残影路径
            const pathCount = 36; // 36条残影路径
            const particlesPerPath = Math.floor(particleCount / pathCount);
            
            for (let i = 0; i < pathCount; i++) {
                // 每条路径都从中心向外辐射
                const pathAngle = (i / pathCount) * Math.PI * 2;
                
                // 每条路径上分布粒子
                for (let j = 0; j < particlesPerPath; j++) {
                    const index = i * particlesPerPath + j;
                    if (index >= particleCount) continue;
                    
                    // 沿路径均匀分布
                    const t = j / particlesPerPath;
                    const radius = t * galaxyParams.diskRadius * 2.5;
                    
                    // 添加路径扭曲
                    const waveOffset = Math.sin(t * Math.PI * 5) * 0.2;
                    const finalAngle = pathAngle + waveOffset;
                    
                    // 位置
                    positions[index * 3] = corePos.x + radius * Math.cos(finalAngle);
                    positions[index * 3 + 1] = corePos.y + (Math.random() - 0.5) * 600; // 高度变化
                    positions[index * 3 + 2] = corePos.z + radius * Math.sin(finalAngle);
                    
                    // 颜色 - 绚丽的蓝紫渐变
                    const hue = 0.6 + t * 0.1; // 沿路径颜色渐变
                    const saturation = 0.8 + Math.random() * 0.2;
                    const lightness = 0.5 - t * 0.3; // 越靠近末端越暗
                    
                    const color = new THREE.Color().setHSL(hue, saturation, lightness);
                    colors[index * 3] = color.r;
                    colors[index * 3 + 1] = color.g;
                    colors[index * 3 + 2] = color.b;
                    
                    // 尺寸 - 越靠近末端越小
                    sizes[index] = 30 * (1.0 - t * 0.5) + Math.random() * 20;
                }
            }
            
            // 设置属性
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            trailGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // 材质 - 使用自定义着色器获得更好的拖尾效果
            const trailMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vColor;
                    
                    void main() {
                        // 流线效果
                        vec2 uv = gl_PointCoord;
                        float trail = smoothstep(0.0, 1.0, uv.x) * smoothstep(1.0, 0.7, uv.x);
                        float alpha = trail * opacity;
                        
                        // 脉冲效果
                        float pulse = sin(time * 5.0 + uv.x * 10.0) * 0.5 + 0.5;
                        alpha *= 0.7 + pulse * 0.3;
                        
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true
            });
            
            // 创建粒子系统
            const trailSystem = new THREE.Points(trailGeometry, trailMaterial);
            
            // 添加到场景
            scene.add(trailSystem);
            
            // 存储到状态中
            cosmicCollapseState.collapseParticles.push({
                system: trailSystem,
                originalPositions: positions.slice(),
                targetPositions: new Float32Array(positions.length),
                type: 'trail'
            });
            
            // 设置目标位置
            const targetPositions = cosmicCollapseState.collapseParticles[cosmicCollapseState.collapseParticles.length-1].targetPositions;
            for (let i = 0; i < particleCount; i++) {
                targetPositions[i * 3] = corePos.x;
                targetPositions[i * 3 + 1] = corePos.y;
                targetPositions[i * 3 + 2] = corePos.z;
            }
        }
        
        // 创建量子波动粒子
        function createQuantumFluctuationParticles(corePos, particleCount) {
            // 创建几何体
            const quantumGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // 创建体积分布
            for (let i = 0; i < particleCount; i++) {
                // 在银河系周围的空间体积中随机分布
                const radius = galaxyParams.diskRadius * (1.0 + Math.random() * 1.2);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1); // 完全球形分布
                
                positions[i * 3] = corePos.x + radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = corePos.y + radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = corePos.z + radius * Math.cos(phi);
                
                // 颜色 - 彩虹色谱
                const hue = Math.random(); // 全色相范围
                const saturation = 0.7 + Math.random() * 0.3;
                const lightness = 0.3 + Math.random() * 0.3;
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                // 尺寸 - 较小的粒子
                sizes[i] = 3 + Math.random() * 12;
            }
            
            // 设置属性
            quantumGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            quantumGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            quantumGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // 材质
            const quantumMaterial = new THREE.PointsMaterial({
                size: 10,
                vertexColors: true,
                transparent: true,
                opacity: 0.0, // 初始不可见
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建粒子系统
            const quantumSystem = new THREE.Points(quantumGeometry, quantumMaterial);
            
            // 添加到场景
            scene.add(quantumSystem);
            
            // 存储到状态中
            cosmicCollapseState.collapseParticles.push({
                system: quantumSystem,
                originalPositions: positions.slice(),
                targetPositions: new Float32Array(positions.length),
                type: 'quantum'
            });
            
            // 设置目标位置 - 量子粒子随机散布后最终坍缩
            const targetPositions = cosmicCollapseState.collapseParticles[cosmicCollapseState.collapseParticles.length-1].targetPositions;
            for (let i = 0; i < particleCount; i++) {
                targetPositions[i * 3] = corePos.x;
                targetPositions[i * 3 + 1] = corePos.y;
                targetPositions[i * 3 + 2] = corePos.z;
            }
        }

        // 创建虚空球体（代表宇宙坍缩后的奇点）
        function createVoidSphere() {
            // 获取银河系中心位置
            const corePos = getGalaxyCoreWorldPosition();
            
            // 创建黑洞几何体
            const sphereGeometry = new THREE.SphereGeometry(300, 64, 64);
            
            // 创建自定义着色器材质，实现黑洞扭曲效果
            const voidMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x000000) },
                    color2: { value: new THREE.Color(0x000033) },
                    color3: { value: new THREE.Color(0x110022) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    uniform vec3 color3;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    // 噪声函数
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }
                    
                    // 分形噪声
                    float fbm(vec2 p) {
                        float sum = 0.0;
                        float amp = 1.0;
                        float freq = 1.0;
                        for (int i = 0; i < 6; i++) {
                            sum += amp * noise(p * freq);
                            amp *= 0.5;
                            freq *= 2.0;
                            p = p * 1.1 + vec2(time * 0.1, 0.0);
                        }
                        return sum;
                    }
                    
                    void main() {
                        // 从中心计算距离
                        vec2 center = vec2(0.5, 0.5);
                        float dist = length(vUv - center) * 2.0;
                        
                        // 基于距离和时间创建扭曲效果
                        float distortion = sin(dist * 10.0 - time * 0.5) * 0.1 + 0.9;
                        
                        // 添加分形噪声
                        float noiseVal = fbm(vUv * 5.0 + time * 0.1) * 0.3;
                        
                        // 根据噪声和距离混合多种颜色
                        vec3 innerColor = mix(color2, color1, noiseVal);
                        vec3 outerColor = mix(color3, color2, noiseVal * 2.0);
                        vec3 color = mix(innerColor, outerColor, dist * distortion);
                        
                        // 边缘暗化
                        float alpha = smoothstep(1.0, 0.6, dist + noiseVal * 0.2);
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建虚空球体
            const voidSphere = new THREE.Mesh(sphereGeometry, voidMaterial);
            voidSphere.position.copy(corePos);
            voidSphere.scale.set(0.01, 0.01, 0.01); // 初始非常小
            
            // 添加到场景
            scene.add(voidSphere);
            
            // 创建虚空光环
            createVoidHalo(corePos);
            
            // 存储到状态中
            cosmicCollapseState.voidSphere = voidSphere;
        }
        
        // 创建虚空光环
        function createVoidHalo(position) {
            const haloGeometry = new THREE.RingGeometry(150, 800, 64);
            const haloMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0x1A1A66) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec2 vUv;
                    
                    void main() {
                        // 从中心计算径向距离
                        float dist = length(vUv - vec2(0.5, 0.5)) * 2.0;
                        
                        // 创建脉冲效果
                        float pulse = (sin(dist * 20.0 - time * 2.0) + 1.0) * 0.5;
                        
                        // 计算透明度（边缘渐变）
                        float alpha = smoothstep(0.0, 0.3, 1.0 - abs(dist - 0.5) * 2.0) * 0.3;
                        alpha *= pulse * 0.8 + 0.2;
                        
                        // 输出颜色
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                side: THREE.DoubleSide,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建光环
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.copy(position);
            halo.rotation.x = Math.PI / 2; // 水平放置
            halo.scale.set(0.01, 0.01, 0.01); // 初始非常小
            
            // 添加到场景
            scene.add(halo);
            
            // 存储到状态中
            cosmicCollapseState.voidHalo = halo;
        }
        
        // 动画虚空阶段
        function animateVoid(elapsed) {
            // 虚空阶段开始时间：激光+坍缩后
            const voidStartTime = 10000 + 12000; // 调整为总共22秒（激光10秒+坍缩12秒）
            const voidDuration = 7000; // 7秒虚空
            
            // 虚空动画时间
            const voidElapsed = elapsed - voidStartTime;
            const voidT = Math.min(1.0, voidElapsed / voidDuration);
            
            // 更新相机位置 - 进一步靠近中心点
            if (voidT < 0.5) {
                const cameraT = voidT * 2; // 0-1范围
                const corePos = getGalaxyCoreWorldPosition();
                const startDistance = cosmicCollapseState.originalState.cameraPosition.distanceTo(corePos) * 0.6; // 坍缩结束时的距离
                const endDistance = startDistance * 0.3; // 最终距离更近
                
                const currentDistance = startDistance - (startDistance - endDistance) * Math.pow(cameraT, 1.5);
                
                // 计算从当前位置到中心的方向
                const direction = new THREE.Vector3()
                    .subVectors(camera.position, corePos)
                    .normalize();
                
                // 添加微小扰动，使相机轻微震动
                const shake = (Math.random() - 0.5) * 30 * (1 - cameraT);
                direction.x += (Math.random() - 0.5) * 0.01 * shake;
                direction.y += (Math.random() - 0.5) * 0.01 * shake;
                
                // 新位置 = 中心 + 方向 * 当前距离
                const newPosition = corePos.clone().add(direction.multiplyScalar(currentDistance));
                
                // 柔和地靠近
                camera.position.lerp(newPosition, 0.05);
            } else if (voidT > 0.8) {
                // 虚空阶段后期，相机开始缓慢后退
                const retreatT = (voidT - 0.8) / 0.2;
                const corePos = getGalaxyCoreWorldPosition();
                const minDistance = cosmicCollapseState.originalState.cameraPosition.distanceTo(corePos) * 0.18; // 最近距离
                const endDistance = minDistance * 1.5; // 稍微后退一些
                
                const currentDistance = minDistance + (endDistance - minDistance) * Math.pow(retreatT, 0.5);
                
                // 计算从当前位置到中心的方向
                const direction = new THREE.Vector3()
                    .subVectors(camera.position, corePos)
                    .normalize();
                
                // 新位置 = 中心 + 方向 * 当前距离
                const newPosition = corePos.clone().add(direction.multiplyScalar(currentDistance));
                
                // 柔和地移动
                camera.position.lerp(newPosition, 0.03);
            }
            
            // 动画虚空球体
            if (cosmicCollapseState.voidSphere) {
                // 更新着色器时间
                cosmicCollapseState.voidSphere.material.uniforms.time.value = voidElapsed * 0.001;
                
                // 大小变化 - 一开始快速增长，然后稳定脉动
                let scale;
                if (voidT < 0.2) {
                    // 快速增长阶段
                    scale = 1.5 + voidT * 2.0;
                } else {
                    // 脉动阶段
                    const pulse = Math.sin(voidElapsed * 0.001) * 0.15;
                    scale = 1.9 + pulse;
                }
                cosmicCollapseState.voidSphere.scale.set(scale, scale, scale);
                
                // 后半段阶段，淡出虚空球
                if (voidT > 0.7) {
                    const fadeT = (voidT - 0.7) / 0.3; // 归一化到[0,1]
                    cosmicCollapseState.voidSphere.material.opacity = 1.0 - fadeT;
                }
            }
            
            // 动画虚空光环
            if (cosmicCollapseState.voidHalo) {
                // 更新着色器时间
                cosmicCollapseState.voidHalo.material.uniforms.time.value = voidElapsed * 0.001;
                
                // 光环旋转 - 速度随时间变化
                const rotationSpeed = 0.0003 + Math.sin(voidElapsed * 0.0005) * 0.0002;
                cosmicCollapseState.voidHalo.rotation.z += rotationSpeed;
                
                // 脉冲效果 - 大小和强度变化
                let haloScale;
                if (voidT < 0.3) {
                    // 初期膨胀
                    haloScale = 1.0 + voidT * 2.0;
                } else {
                    // 后期脉冲
                    const pulse = Math.sin(voidElapsed * 0.0015) * 0.3;
                    haloScale = 1.6 + pulse;
                }
                cosmicCollapseState.voidHalo.scale.set(haloScale, haloScale, haloScale);
                
                // 后半段阶段，淡出光环
                if (voidT > 0.7) {
                    const fadeT = (voidT - 0.7) / 0.3; // 归一化到[0,1]
                    cosmicCollapseState.voidHalo.material.opacity = 1.0 - fadeT;
                }
            }
            
            // 创建虚空能量冲击 - 在中期出现短暂的能量冲击波
            if (voidT > 0.3 && voidT < 0.35 && !cosmicCollapseState.voidShockwave) {
                createVoidShockwave();
            }
            
            // 动画虚空能量冲击波
            if (cosmicCollapseState.voidShockwave) {
                // 能量冲击波迅速向外扩散
                const shockwaveT = (voidT - 0.3) / 0.2; // 0-1范围，持续0.2的时间比例
                if (shockwaveT <= 1.0) {
                    const scale = 0.1 + shockwaveT * 15.0; // 快速扩大
                    cosmicCollapseState.voidShockwave.scale.set(scale, scale, scale);
                    
                    // 冲击波透明度随着扩散而降低
                    cosmicCollapseState.voidShockwave.material.opacity = 1.0 - Math.pow(shockwaveT, 2);
                    
                    // 更新着色器时间
                    if (cosmicCollapseState.voidShockwave.material.uniforms) {
                        cosmicCollapseState.voidShockwave.material.uniforms.time.value = voidElapsed * 0.001;
                    }
                } else {
                    // 冲击波结束后移除
                    scene.remove(cosmicCollapseState.voidShockwave);
                    cosmicCollapseState.voidShockwave = null;
                }
            }
            
            // 随机散布虚空能量粒子
            if (Math.random() < 0.05) {
                createVoidEnergyParticle();
            }
            
            // 动画虚空能量粒子
            if (cosmicCollapseState.voidParticles) {
                cosmicCollapseState.voidParticles.forEach((particle, index) => {
                    if (!particle) return;
                    
                    // 粒子生命周期
                    const particleAge = voidElapsed - particle.birthTime;
                    const particleLifespan = particle.lifespan || 2000; // 默认2秒
                    const particleT = particleAge / particleLifespan;
                    
                    if (particleT >= 1.0) {
                        // 生命周期结束，移除粒子
                        scene.remove(particle);
                        cosmicCollapseState.voidParticles[index] = null;
                    } else {
                        // 扩散动画
                        const scale = particle.initialScale * (1 + particleT * 2.0);
                        particle.scale.set(scale, scale, scale);
                        
                        // 淡出效果
                        if (particleT > 0.7) {
                            const fadeT = (particleT - 0.7) / 0.3;
                            particle.material.opacity = particle.initialOpacity * (1.0 - fadeT);
                        }
                        
                        // 向外扩散运动
                        const moveSpeed = particle.speed || 5.0;
                        particle.position.x += particle.direction.x * moveSpeed;
                        particle.position.y += particle.direction.y * moveSpeed;
                        particle.position.z += particle.direction.z * moveSpeed;
                    }
                });
                
                // 清除已删除的粒子
                cosmicCollapseState.voidParticles = cosmicCollapseState.voidParticles.filter(p => p !== null);
            }
            
            // 阶段结束时，切换到恢复阶段
            if (voidT >= 1.0 && cosmicCollapseState.phase === 'void') {
                console.log("虚空阶段结束，开始恢复阶段");
                cosmicCollapseState.phase = 'restore';
                
                // 移除虚空球和光环
                cleanupVoidEffects();
                
                // 准备恢复原始状态
                startRestoreProcess();
            }
        }
        
        // 创建虚空能量冲击波
        function createVoidShockwave() {
            // 获取银河系中心位置
            const corePos = getGalaxyCoreWorldPosition();
            
            // 创建球面几何体
            const shockwaveGeometry = new THREE.SphereGeometry(1, 32, 32);
            
            // 创建自定义着色器材质
            const shockwaveMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x00FFFF) }, // 亮青色
                    color2: { value: new THREE.Color(0x0033FF) }  // 深蓝色
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    varying vec2 vUv;
                    
                    void main() {
                        // 创建脉冲波纹效果
                        float rings = abs(sin(vUv.y * 30.0 - time * 5.0)) * 0.5 + 0.5;
                        
                        // 边缘渐变
                        float edgeFactor = smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y);
                        
                        // 颜色混合
                        vec3 finalColor = mix(color1, color2, rings);
                        
                        // 设置透明度
                        float alpha = rings * edgeFactor * 0.8;
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            
            // 创建冲击波网格
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.position.copy(corePos);
            shockwave.scale.set(0.1, 0.1, 0.1); // 初始很小
            
            // 添加到场景
            scene.add(shockwave);
            
            // 存储到状态
            cosmicCollapseState.voidShockwave = shockwave;
        }
        
        // 创建虚空能量粒子
        function createVoidEnergyParticle() {
            // 获取银河系中心位置
            const corePos = getGalaxyCoreWorldPosition();
            
            // 随机决定粒子类型
            const particleType = Math.random() < 0.5 ? 'spark' : 'glow';
            
            let particle;
            if (particleType === 'spark') {
                // 创建光束状粒子
                const sparkGeometry = new THREE.BoxGeometry(10, 10, 10);
                const sparkMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                particle = new THREE.Mesh(sparkGeometry, sparkMaterial);
                
                // 随机拉伸、旋转
                const scaleX = 0.1 + Math.random() * 0.2;
                const scaleY = 0.1 + Math.random() * 0.2;
                const scaleZ = 2.0 + Math.random() * 5.0; // 长条状
                particle.scale.set(scaleX, scaleY, scaleZ);
                
                particle.rotation.x = Math.random() * Math.PI * 2;
                particle.rotation.y = Math.random() * Math.PI * 2;
                particle.rotation.z = Math.random() * Math.PI * 2;
                
                particle.initialScale = 1.0;
                particle.initialOpacity = 0.8;
            } else {
                // 创建球形发光粒子
                const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(Math.random() < 0.5 ? 0x0066FF : 0x00FFDD),
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending
                });
                
                particle = new THREE.Mesh(glowGeometry, glowMaterial);
                
                // 随机大小
                const scale = 0.5 + Math.random() * 1.5;
                particle.scale.set(scale, scale, scale);
                
                particle.initialScale = scale;
                particle.initialOpacity = 0.5;
            }
            
            // 位置在中心周围随机
            const offset = 200; // 粒子出现位置偏移量
            particle.position.set(
                corePos.x + (Math.random() - 0.5) * offset,
                corePos.y + (Math.random() - 0.5) * offset,
                corePos.z + (Math.random() - 0.5) * offset
            );
            
            // 设置随机运动方向
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            
            particle.direction = new THREE.Vector3(
                Math.sin(theta) * Math.cos(phi),
                Math.sin(theta) * Math.sin(phi),
                Math.cos(theta)
            );
            
            // 随机速度
            particle.speed = 2.0 + Math.random() * 8.0;
            
            // 设置生命周期
            particle.birthTime = cosmicCollapseState.startTime + 10000 + 12000 - cosmicCollapseState.startTime;
            particle.lifespan = 1000 + Math.random() * 3000; // 1-4秒
            
            // 添加到场景
            scene.add(particle);
            
            // 初始化粒子数组（如果需要）
            if (!cosmicCollapseState.voidParticles) {
                cosmicCollapseState.voidParticles = [];
            }
            
            // 存储到状态
            cosmicCollapseState.voidParticles.push(particle);
        }
        
        // 清理虚空效果
        function cleanupVoidEffects() {
            // 移除虚空球
            if (cosmicCollapseState.voidSphere) {
                scene.remove(cosmicCollapseState.voidSphere);
                cosmicCollapseState.voidSphere = null;
            }
            
            // 移除光环
            if (cosmicCollapseState.voidHalo) {
                scene.remove(cosmicCollapseState.voidHalo);
                cosmicCollapseState.voidHalo = null;
            }
            
            // 移除冲击波
            if (cosmicCollapseState.voidShockwave) {
                scene.remove(cosmicCollapseState.voidShockwave);
                cosmicCollapseState.voidShockwave = null;
            }
            
            // 移除所有粒子
            if (cosmicCollapseState.voidParticles) {
                cosmicCollapseState.voidParticles.forEach(particle => {
                    if (particle) scene.remove(particle);
                });
                cosmicCollapseState.voidParticles = [];
            }
            
            // 移除任何可能的restorationWave
            if (cosmicCollapseState.restorationWave) {
                scene.remove(cosmicCollapseState.restorationWave);
                cosmicCollapseState.restorationWave = null;
            }
            
            // 移除恢复核心
            if (cosmicCollapseState.restorationCore) {
                scene.remove(cosmicCollapseState.restorationCore);
                cosmicCollapseState.restorationCore = null;
            }
            
            // 移除光束
            if (cosmicCollapseState.restorationBeams) {
                scene.remove(cosmicCollapseState.restorationBeams);
                cosmicCollapseState.restorationBeams = null;
            }
            
            // 移除小光束
            if (cosmicCollapseState.smallBeams) {
                scene.remove(cosmicCollapseState.smallBeams);
                cosmicCollapseState.smallBeams = null;
            }
            
            // 移除粒子系统
            if (cosmicCollapseState.restorationParticles) {
                scene.remove(cosmicCollapseState.restorationParticles.system);
                cosmicCollapseState.restorationParticles = null;
            }
        }

        // 开始恢复过程
        function startRestoreProcess() {
            // 恢复银河系可见性
            galaxy.visible = true;
            
            // 银河系初始化为不可见，稍后淡入
            galaxy.children.forEach(child => {
                if (child.material && typeof child.material.opacity !== 'undefined') {
                    child.material.opacity = 0;
                }
                if (child.children) {
                    child.children.forEach(subchild => {
                        if (subchild.material && typeof subchild.material.opacity !== 'undefined') {
                            subchild.material.opacity = 0;
                        }
                    });
                }
            });
            
            // 重置银河系位置和旋转
            if (cosmicCollapseState.originalState) {
                galaxy.position.copy(cosmicCollapseState.originalState.galaxyPosition);
                galaxy.rotation.x = cosmicCollapseState.originalState.galaxyRotation.x;
                galaxy.rotation.y = cosmicCollapseState.originalState.galaxyRotation.y;
                galaxy.rotation.z = cosmicCollapseState.originalState.galaxyRotation.z;
            }
            
            // 创建恢复特效
            createRestorationEffects();
        }
        
        // 创建恢复特效
        function createRestorationEffects() {
            // 获取银河系中心位置
            const corePos = getGalaxyCoreWorldPosition();
            
            // 创建一个能量爆发核心
            createEnergyCore(corePos);
            
            // 创建能量扩散光束
            createRestorationBeams(corePos);
            
            // 创建扩散波
            createRestorationWave(corePos);
            
            // 创建星系重生粒子
            createRestorationParticles(corePos);
        }
        
        // 创建重生能量核心
        function createEnergyCore(position) {
            // 创建几何体
            const coreGeometry = new THREE.SphereGeometry(300, 64, 64);
            
            // 创建自发光材质
            const coreMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x00FFFF) },
                    color2: { value: new THREE.Color(0xFFFFFF) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    
                    // 噪声函数
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }
                    
                    void main() {
                        // 法线效果
                        vec3 normal = normalize(vNormal);
                        float rim = pow(1.0 - abs(dot(normal, vec3(0.0, 0.0, 1.0))), 2.0);
                        
                        // 波纹效果
                        float rings = abs(sin(length(vUv - vec2(0.5)) * 20.0 - time * 5.0));
                        
                        // 噪声效果
                        float noiseVal = noise(vUv * 5.0 + time * 0.2);
                        
                        // 组合效果
                        float intensity = rim * 0.8 + rings * 0.4 + noiseVal * 0.2;
                        
                        // 颜色混合
                        vec3 finalColor = mix(color1, color2, intensity);
                        
                        gl_FragColor = vec4(finalColor, 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建核心网格
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.copy(position);
            
            // 添加内部光源
            const light = new THREE.PointLight(0x00FFFF, 5.0, 3000);
            core.add(light);
            
            // 添加到场景
            scene.add(core);
            
            // 存储到状态中
            cosmicCollapseState.restorationCore = core;
        }
        
        // 创建恢复特效光束
        function createRestorationBeams(position) {
            // 创建能量扩散效果
            const beamCount = 36; // 增加光束数量
            const beamGeometry = new THREE.BufferGeometry();
            const beamPositions = [];
            const beamColors = [];
            
            for (let i = 0; i < beamCount; i++) {
                const angle = (i / beamCount) * Math.PI * 2;
                
                // 起点在中心
                beamPositions.push(
                    position.x, position.y, position.z,
                    position.x + Math.cos(angle) * 10000,
                    position.y + (Math.random() - 0.5) * 2000,
                    position.z + Math.sin(angle) * 10000
                );
                
                // 使用中心暖色调和边缘冷色调
                const colorCenter = new THREE.Color(0x88FFFF);
                const colorEdge = new THREE.Color(0x0088FF);
                beamColors.push(
                    colorCenter.r, colorCenter.g, colorCenter.b,
                    colorEdge.r, colorEdge.g, colorEdge.b
                );
            }
            
            beamGeometry.setAttribute('position', new THREE.Float32BufferAttribute(beamPositions, 3));
            beamGeometry.setAttribute('color', new THREE.Float32BufferAttribute(beamColors, 3));
            
            const beamMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.0, // 初始不可见
                blending: THREE.AdditiveBlending,
                linewidth: 2
            });
            
            const beams = new THREE.LineSegments(beamGeometry, beamMaterial);
            
            // 添加到场景
            scene.add(beams);
            
            // 存储到状态中
            cosmicCollapseState.restorationBeams = beams;
            
            // 创建辅助光束 - 随机小光束
            const smallBeamCount = 200; // 大量小光束
            const smallBeams = new THREE.Group();
            
            for (let i = 0; i < smallBeamCount; i++) {
                // 随机方向
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                // 方向向量
                const dirX = Math.sin(theta) * Math.cos(phi);
                const dirY = Math.sin(theta) * Math.sin(phi);
                const dirZ = Math.cos(theta);
                
                // 长度
                const length = 1000 + Math.random() * 5000;
                
                // 创建几何体
                const smallBeamGeometry = new THREE.BufferGeometry();
                smallBeamGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                    position.x, position.y, position.z,
                    position.x + dirX * length,
                    position.y + dirY * length,
                    position.z + dirZ * length
                ], 3));
                
                // 颜色
                const hue = 0.5 + Math.random() * 0.15; // 蓝-青色范围
                const color = new THREE.Color().setHSL(hue, 1.0, 0.7);
                
                // 材质
                const smallBeamMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.0, // 初始不可见
                    blending: THREE.AdditiveBlending
                });
                
                const smallBeam = new THREE.Line(smallBeamGeometry, smallBeamMaterial);
                smallBeam.userData = {
                    delay: Math.random() * 1000, // 随机延迟
                    duration: 500 + Math.random() * 1000, // 随机持续时间
                    active: false,
                    startTime: 0
                };
                
                // 添加到组
                smallBeams.add(smallBeam);
            }
            
            // 添加到场景
            scene.add(smallBeams);
            
            // 存储到状态中
            cosmicCollapseState.smallBeams = smallBeams;
        }
        
        // 创建恢复扩散波
        function createRestorationWave(position) {
            // 创建扩散波几何体
            const waveGeometry = new THREE.RingGeometry(0.1, 0.5, 64);
            
            // 创建自定义着色器材质
            const waveMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0x00FFFF) },
                    radius: { value: 0.1 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    uniform float radius;
                    
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec2 vUv;
                    
                    void main() {
                        // 计算到中心的距离
                        vec2 center = vec2(0.5);
                        float dist = length(vUv - center) * 2.0;
                        
                        // 创建波纹效果
                        float wave = abs(sin(dist * 20.0 - time * 3.0)) * 0.5 + 0.5;
                        
                        // 径向渐变
                        float alpha = smoothstep(1.0, 0.7, dist) * 0.7 * wave;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // 创建网格
            const wave = new THREE.Mesh(waveGeometry, waveMaterial);
            wave.position.copy(position);
            wave.rotation.x = Math.PI / 2; // 水平放置
            
            // 初始比例
            wave.scale.set(0.1, 0.1, 0.1);
            
            // 添加到场景
            scene.add(wave);
            
            // 存储到状态中
            cosmicCollapseState.restorationWave = wave;
        }
        
        // 创建恢复粒子系统
        function createRestorationParticles(position) {
            // 创建大量恢复粒子
            const particleCount = 50000;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            
            // 初始都在中心位置
            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = position.x;
                particlePositions[i * 3 + 1] = position.y;
                particlePositions[i * 3 + 2] = position.z;
                
                // 使用与银河系匹配的颜色
                let hue, saturation, lightness;
                const colorType = Math.random();
                
                if (colorType < 0.3) { // 30%是蓝色系
                    hue = 0.6 + (Math.random() - 0.5) * 0.1;
                    saturation = 0.8 + Math.random() * 0.2;
                    lightness = 0.5 + Math.random() * 0.3;
                } else if (colorType < 0.7) { // 40%是青色系
                    hue = 0.5 + (Math.random() - 0.5) * 0.1;
                    saturation = 0.7 + Math.random() * 0.3;
                    lightness = 0.4 + Math.random() * 0.3;
                } else { // 30%是金色系
                    hue = 0.15 + (Math.random() - 0.5) * 0.1;
                    saturation = 0.7 + Math.random() * 0.3;
                    lightness = 0.5 + Math.random() * 0.3;
                }
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
                
                // 随机大小
                particleSizes[i] = 5 + Math.random() * 15;
            }
            
            // 设置属性
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            
            // 创建材质
            const particleMaterial = new THREE.PointsMaterial({
                size: 10,
                vertexColors: true,
                transparent: true,
                opacity: 0.0, // 初始不可见
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // 创建粒子系统
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            
            // 添加到场景
            scene.add(particles);
            
            // 计算粒子目标位置 - 分散到银河系
            const targetPositions = new Float32Array(particleCount * 3);
            
            // 收集银河系中所有Point对象的位置
            const galaxyPositions = collectGalaxyPositions();
            const positionCount = galaxyPositions.length / 3;
            
            for (let i = 0; i < particleCount; i++) {
                // 随机选择银河系中的一个点作为目标
                const randomIndex = Math.floor(Math.random() * positionCount) * 3;
                targetPositions[i * 3] = galaxyPositions[randomIndex];
                targetPositions[i * 3 + 1] = galaxyPositions[randomIndex + 1];
                targetPositions[i * 3 + 2] = galaxyPositions[randomIndex + 2];
                
                // 添加一些随机扰动
                targetPositions[i * 3] += (Math.random() - 0.5) * 300;
                targetPositions[i * 3 + 1] += (Math.random() - 0.5) * 300;
                targetPositions[i * 3 + 2] += (Math.random() - 0.5) * 300;
            }
            
            // 存储到状态中
            cosmicCollapseState.restorationParticles = {
                system: particles,
                targetPositions: targetPositions
            };
        }
        
        // 收集银河系中所有粒子的位置
        function collectGalaxyPositions() {
            const positions = [];
            
            galaxy.children.forEach(child => {
                if (child.isPoints && child.geometry && child.geometry.attributes.position) {
                    const childPositions = child.geometry.attributes.position.array;
                    const matrix = new THREE.Matrix4().copy(child.matrixWorld);
                    
                    // 对每个位置应用变换
                    for (let i = 0; i < childPositions.length; i += 3) {
                        const pos = new THREE.Vector3(
                            childPositions[i],
                            childPositions[i + 1],
                            childPositions[i + 2]
                        );
                        
                        pos.applyMatrix4(matrix);
                        
                        // 每100个点取样一个，避免过多数据
                        if (Math.random() < 0.01) {
                            positions.push(pos.x, pos.y, pos.z);
                        }
                    }
                }
                
                // 递归检查子对象
                if (child.children) {
                    child.children.forEach(subchild => {
                        if (subchild.isPoints && subchild.geometry && subchild.geometry.attributes.position) {
                            const subPositions = subchild.geometry.attributes.position.array;
                            const matrix = new THREE.Matrix4().copy(subchild.matrixWorld);
                            
                            for (let i = 0; i < subPositions.length; i += 3) {
                                const pos = new THREE.Vector3(
                                    subPositions[i],
                                    subPositions[i + 1],
                                    subPositions[i + 2]
                                );
                                
                                pos.applyMatrix4(matrix);
                                
                                if (Math.random() < 0.01) {
                                    positions.push(pos.x, pos.y, pos.z);
                                }
                            }
                        }
                    });
                }
            });
            
            // 如果没有足够的点，创建一些随机点
            if (positions.length < 3000) {
                for (let i = 0; i < 10000; i++) {
                    const radius = Math.random() * galaxyParams.diskRadius;
                    const theta = Math.random() * Math.PI * 2;
                    const height = (Math.random() - 0.5) * galaxyParams.diskRadius * 0.1;
                    
                    positions.push(
                        radius * Math.cos(theta),
                        height,
                        radius * Math.sin(theta)
                    );
                }
            }
            
            return positions;
        }
        
        // 动画恢复阶段
        function animateRestore(elapsed) {
            // 恢复阶段开始时间：激光+坍缩+虚空后
            const restoreStartTime = 10000 + 12000 + 7000; // 总共29秒
            const restoreDuration = 6000; // 6秒恢复，再调长一秒
            
            // 恢复动画时间
            const restoreElapsed = elapsed - restoreStartTime;
            const restoreT = Math.min(1.0, restoreElapsed / restoreDuration);
            
            // 调整相机位置
            if (cosmicCollapseState.originalState) {
                const originalPos = cosmicCollapseState.originalState.cameraPosition;
                const currentPos = camera.position;
                const corePos = getGalaxyCoreWorldPosition();
                
                // 计算当前到中心的距离
                const currentDist = currentPos.distanceTo(corePos);
                // 目标距离
                const targetDist = originalPos.distanceTo(corePos);
                
                // 计算新的距离
                const newDist = currentDist + (targetDist - currentDist) * (restoreT < 0.5 ? restoreT * 0.1 : 0.05 + (restoreT - 0.5) * 0.4);
                
                // 方向矢量
                const dir = new THREE.Vector3().subVectors(currentPos, corePos).normalize();
                
                // 新位置
                const newPos = corePos.clone().add(dir.multiplyScalar(newDist));
                
                // 添加一些摇晃
                if (restoreT < 0.3) {
                    const shake = (1 - restoreT / 0.3) * 300;
                    newPos.x += (Math.random() - 0.5) * shake;
                    newPos.y += (Math.random() - 0.5) * shake;
                    newPos.z += (Math.random() - 0.5) * shake;
                }
                
                // 平滑过渡
                camera.position.lerp(newPos, 0.05);
            }
            
            // 动画能量核心
            if (cosmicCollapseState.restorationCore) {
                const core = cosmicCollapseState.restorationCore;
                
                // 更新着色器时间
                if (core.material.uniforms) {
                    core.material.uniforms.time.value = restoreElapsed * 0.001;
                }
                
                // 动画缩放
                if (restoreT < 0.3) {
                    // 前期迅速扩大
                    const scale = 1.0 + restoreT / 0.3 * 3.0;
                    core.scale.set(scale, scale, scale);
                    
                    // 内部光源强度增强
                    if (core.children[0] && core.children[0].isPointLight) {
                        core.children[0].intensity = 5.0 + restoreT / 0.3 * 10.0;
                    }
                } else {
                    // 后期迅速缩小
                    const fadeT = (restoreT - 0.3) / 0.3;
                    if (fadeT < 1.0) {
                        const scale = 4.0 * (1.0 - fadeT);
                        core.scale.set(scale, scale, scale);
                        
                        // 内部光源逐渐熄灭
                        if (core.children[0] && core.children[0].isPointLight) {
                            core.children[0].intensity = 15.0 * (1.0 - fadeT);
                        }
                    } else {
                        // 完全淡出后移除
                        scene.remove(core);
                        cosmicCollapseState.restorationCore = null;
                    }
                }
            }
            
            // 动画光束
            if (cosmicCollapseState.restorationBeams) {
                if (restoreT < 0.4) {
                    // 淡入光束
                    cosmicCollapseState.restorationBeams.material.opacity = restoreT / 0.4 * 0.7;
                } else {
                    // 淡出光束
                    const fadeT = (restoreT - 0.4) / 0.2;
                    if (fadeT < 1.0) {
                        cosmicCollapseState.restorationBeams.material.opacity = 0.7 * (1 - fadeT);
                    } else {
                        // 完全淡出后移除
                        scene.remove(cosmicCollapseState.restorationBeams);
                        cosmicCollapseState.restorationBeams = null;
                    }
                }
            }
            
            // 动画小光束
            if (cosmicCollapseState.smallBeams) {
                // 逐一更新每个小光束
                cosmicCollapseState.smallBeams.children.forEach(beam => {
                    // 检查是否应该激活
                    if (!beam.userData.active && restoreElapsed > beam.userData.delay && restoreT < 0.6) {
                        beam.userData.active = true;
                        beam.userData.startTime = restoreElapsed;
                    }
                    
                    // 如果激活，更新进度
                    if (beam.userData.active) {
                        const beamAge = restoreElapsed - beam.userData.startTime;
                        const beamT = beamAge / beam.userData.duration;
                        
                        if (beamT <= 1.0) {
                            // 光束淡入再淡出
                            const fadeT = beamT < 0.3 ? beamT / 0.3 : (1.0 - (beamT - 0.3) / 0.7);
                            beam.material.opacity = fadeT * 0.8;
                        } else {
                            // 生命周期结束，重置并等待下一个周期
                            beam.userData.active = false;
                            beam.userData.delay = restoreElapsed + Math.random() * 500;
                            beam.material.opacity = 0;
                        }
                    }
                });
                
                // 后期全部淡出
                if (restoreT > 0.6) {
                    const groupFadeT = (restoreT - 0.6) / 0.2;
                    if (groupFadeT >= 1.0) {
                        scene.remove(cosmicCollapseState.smallBeams);
                        cosmicCollapseState.smallBeams = null;
                    }
                }
            }
            
            // 动画扩散波
            if (cosmicCollapseState.restorationWave) {
                const wave = cosmicCollapseState.restorationWave;
                
                // 更新着色器时间
                if (wave.material.uniforms) {
                    wave.material.uniforms.time.value = restoreElapsed * 0.001;
                }
                
                // 动画缩放 - 持续扩大
                const scale = 20 * Math.pow(restoreT, 0.7) * 1.5; // 更快速扩大
                wave.scale.set(scale, scale, scale);
                
                // 调整透明度 - 逐渐淡出
                const opacity = 0.8 * (1.0 - Math.pow(restoreT, 2));
                wave.material.opacity = opacity;
                
                // 后期完全淡出
                if (restoreT > 0.7) {
                    scene.remove(wave);
                    cosmicCollapseState.restorationWave = null;
                }
            }
            
            // 动画恢复粒子
            if (cosmicCollapseState.restorationParticles) {
                const particles = cosmicCollapseState.restorationParticles.system;
                const targetPositions = cosmicCollapseState.restorationParticles.targetPositions;
                const positions = particles.geometry.attributes.position.array;
                
                // 更新透明度
                if (restoreT < 0.3) {
                    // 淡入
                    particles.material.opacity = restoreT / 0.3 * 0.8;
                } else if (restoreT > 0.7) {
                    // 后期淡出
                    const fadeT = (restoreT - 0.7) / 0.3;
                    particles.material.opacity = 0.8 * (1.0 - fadeT);
                }
                
                // 粒子向目标位置移动
                for (let i = 0; i < positions.length; i += 3) {
                    // 移动速度随时间变化
                    let moveT;
                    if (restoreT < 0.5) {
                        // 慢启动
                        moveT = Math.pow(restoreT / 0.5, 2) * 0.7;
                    } else {
                        // 加速到目标位置
                        moveT = 0.7 + Math.pow((restoreT - 0.5) / 0.5, 0.5) * 0.3;
                    }
                    
                    // 线性插值到目标位置
                    positions[i] = positions[i] * (1 - moveT) + targetPositions[i] * moveT;
                    positions[i + 1] = positions[i + 1] * (1 - moveT) + targetPositions[i + 1] * moveT;
                    positions[i + 2] = positions[i + 2] * (1 - moveT) + targetPositions[i + 2] * moveT;
                }
                
                // 更新几何体
                particles.geometry.attributes.position.needsUpdate = true;
            }
            
            // 动画银河系淡入（从30%时间开始）
            if (restoreT > 0.3) {
                const galaxyFadeInT = (restoreT - 0.3) / 0.7; // 归一化到[0,1]
                
                galaxy.children.forEach(child => {
                    if (child.material && typeof child.material.opacity !== 'undefined') {
                        // 获取原始不透明度（如果有记录）
                        let originalOpacity = 0.7; // 默认值
                        if (child.userData && child.userData.originalOpacity !== undefined) {
                            originalOpacity = child.userData.originalOpacity;
                        }
                        child.material.opacity = originalOpacity * galaxyFadeInT;
                    }
                    
                    if (child.children) {
                        child.children.forEach(subchild => {
                            if (subchild.material && typeof subchild.material.opacity !== 'undefined') {
                                // 获取原始不透明度（如果有记录）
                                let originalOpacity = 0.7; // 默认值
                                if (subchild.userData && subchild.userData.originalOpacity !== undefined) {
                                    originalOpacity = subchild.userData.originalOpacity;
                                }
                                subchild.material.opacity = originalOpacity * galaxyFadeInT;
                            }
                        });
                    }
                });
            }
            
            // 阶段结束时，完全恢复原状
            if (restoreT >= 1.0 && cosmicCollapseState.phase === 'restore') {
                console.log("恢复阶段结束，特效完成");
                
                // 确保银河系的所有材质恢复到原始的不透明度
                galaxy.children.forEach(child => {
                    if (child.material && typeof child.material.opacity !== 'undefined' && 
                        child.userData && typeof child.userData.originalOpacity !== 'undefined') {
                        child.material.opacity = child.userData.originalOpacity;
                    }
                    
                    if (child.children) {
                        child.children.forEach(subchild => {
                            if (subchild.material && typeof subchild.material.opacity !== 'undefined' && 
                                subchild.userData && typeof subchild.userData.originalOpacity !== 'undefined') {
                                subchild.material.opacity = subchild.userData.originalOpacity;
                            }
                        });
                    }
                });
                
                // 清理所有剩余的恢复特效
                if (cosmicCollapseState.restorationCore) {
                    scene.remove(cosmicCollapseState.restorationCore);
                    cosmicCollapseState.restorationCore = null;
                }
                
                if (cosmicCollapseState.restorationBeams) {
                    scene.remove(cosmicCollapseState.restorationBeams);
                    cosmicCollapseState.restorationBeams = null;
                }
                
                if (cosmicCollapseState.smallBeams) {
                    scene.remove(cosmicCollapseState.smallBeams);
                    cosmicCollapseState.smallBeams = null;
                }
                
                if (cosmicCollapseState.restorationWave) {
                    scene.remove(cosmicCollapseState.restorationWave);
                    cosmicCollapseState.restorationWave = null;
                }
                
                if (cosmicCollapseState.restorationParticles) {
                    scene.remove(cosmicCollapseState.restorationParticles.system);
                    cosmicCollapseState.restorationParticles = null;
                }
                
                // 恢复控制器 - 修复特效结束后控制器无效的问题
                controls.enabled = true; // 始终确保启用
                controls.autoRotate = true; // 始终确保自动旋转
                
                if (cosmicCollapseState.originalState) {
                    // 如果原始状态存在，则使用保存的值
                    controls.enabled = cosmicCollapseState.originalState.controlsEnabled;
                    controls.autoRotate = cosmicCollapseState.originalState.controlsAutoRotate;
                }
                
                // 重置状态
                cosmicCollapseState.active = false;
                cosmicCollapseState.phase = 'none';
                
                // 额外检查：确保控制器最终处于启用状态
                setTimeout(() => {
                    controls.enabled = true;
                    controls.autoRotate = true;
                }, 100);
            }
        }

        // 主动画函数
        function animateCosmicCollapse() {
            if (!cosmicCollapseState.active) return;
            
            // 计算经过的时间
            const elapsed = performance.now() - cosmicCollapseState.startTime;
            
            // 根据当前阶段执行相应的动画
            switch (cosmicCollapseState.phase) {
                case 'laser':
                    animateVerticalLasers(elapsed);
                    break;
                case 'collapse':
                    animateCollapse(elapsed);
                    break;
                case 'void':
                    animateVoid(elapsed);
                    break;
                case 'restore':
                    animateRestore(elapsed);
                    break;
            }
        }
        
        // 在主动画循环中插入
        const oldAnimate = animate;
        animate = function() {
            oldAnimate();
            animateGalaxyLightRays();
            animateCosmicCollapse(); // 添加宇宙坍缩动画
        };

        // 动画激光射线效果
        function animateVerticalLasers(elapsed) {
            // 激光阶段持续时间：从10秒延长到15秒，更长以展示更多细节
            const laserDuration = 15000;
            const laserT = Math.min(1.0, elapsed / laserDuration);
            
            // 激光逐渐显现 - 先出现径向激光，后出现垂直激光
            // 修改径向激光淡入：降低开始时的不透明度，使得淡入更加平滑
            const radialFadeInT = Math.min(1.0, laserT * 3); // 前33%时间径向激光完成淡入
            const verticalFadeInStart = 0.05; // 在5%时间点就开始垂直激光淡入（比原来提前）
            const verticalFadeInT = laserT < verticalFadeInStart ? 0 : Math.min(1.0, (laserT - verticalFadeInStart) * 1.5); // 垂直激光淡入变慢
            
            // 动画银河系发光盘面
            if (cosmicCollapseState.galaxyDisk) {
                const disk = cosmicCollapseState.galaxyDisk;
                
                // 淡入盘面 - 开始时更高的不透明度，确保过渡更平滑
                disk.material.opacity = (0.22 + radialFadeInT * 0.58);
                
                // 更新着色器时间
                disk.material.uniforms.time.value = elapsed * 0.001;
                
                // 盘面脉冲效果
                const diskScale = 1.0 + Math.sin(elapsed * 0.0015) * 0.05;
                disk.scale.set(diskScale, diskScale, diskScale);
                
                // 后期逐渐淡出盘面
                if (laserT > 0.7) {
                    const diskFadeT = (laserT - 0.7) / 0.3;
                    disk.material.opacity = 0.8 * (1 - diskFadeT);
                }
            }
            
            // 动画径向激光
            if (cosmicCollapseState.radialLasers) {
                cosmicCollapseState.radialLasers.forEach((laser, index) => {
                    if (!laser) return;
                    
                    // 淡入径向激光 - 从中心向外依次淡入，初始透明度更高，提供更平滑过渡
                    const segmentIndex = index % 5; // 每条径向激光的段索引(0-4)
                    const delayFactor = segmentIndex * 0.03; // 每段延迟时间
                    // 把初始不透明度设为0.25，确保从上一个效果过渡更平滑
                    const segmentT = 0.25 + Math.max(0, Math.min(0.75, (radialFadeInT - delayFactor) * 2));
                    
                    if (laser.userData.lineMaterial) {
                        laser.userData.lineMaterial.opacity = segmentT * 0.7 * laser.userData.opacityFactor;
                    }
                    
                    if (laser.userData.glowMaterial) {
                        laser.userData.glowMaterial.uniforms.opacity.value = segmentT * 0.3 * laser.userData.opacityFactor;
                    }
                    
                    // 脉冲效果 - 不同段有不同脉冲相位
                    const pulseOffset = index * 0.1;
                    const pulse = Math.sin((elapsed * 0.003) + pulseOffset) * 0.2 + 0.8;
                    
                    if (laser.userData.lineMaterial) {
                        laser.userData.lineMaterial.opacity *= pulse;
                    }
                    
                    if (laser.userData.glowMaterial) {
                        laser.userData.glowMaterial.uniforms.opacity.value *= pulse;
                    }
                    
                    // 后期逐渐淡出径向激光 - 延长淡出时间
                    if (laserT > 0.65) {
                        const fadeT = (laserT - 0.65) / 0.35;
                        
                        if (laser.userData.lineMaterial) {
                            laser.userData.lineMaterial.opacity *= (1 - fadeT);
                        }
                        
                        if (laser.userData.glowMaterial) {
                            laser.userData.glowMaterial.uniforms.opacity.value *= (1 - fadeT);
                        }
                    }
                });
            }
            
            // 对垂直激光应用动画效果
            cosmicCollapseState.verticalLasers.forEach(laser => {
                if (!laser) return;
                
                // 淡入垂直激光 - 应用亮度因子，并加入更高的初始透明度使过渡更平滑
                if (laser.userData.lineMaterial) {
                    // 初始透明度提高到0.22，确保与前一效果无缝过渡
                    laser.userData.lineMaterial.opacity = (0.22 + verticalFadeInT * 0.48) * laser.userData.opacityFactor;
                }
                
                // 淡入发光效果
                if (laser.userData.glowMaterial) {
                    // 初始透明度提高到0.12，确保与前一效果无缝过渡
                    laser.userData.glowMaterial.uniforms.opacity.value = (0.12 + verticalFadeInT * 0.18) * laser.userData.opacityFactor;
                }
                
                // 垂直激光脉冲效果
                if (verticalFadeInT > 0) {
                    // 根据到中心距离计算不同脉冲频率
                    const dist = laser.userData.startPos.distanceTo(getGalaxyCoreWorldPosition());
                    const pulseFreq = 8 + (dist / 10000); // 距离越远脉冲频率越高
                    const pulse = Math.sin(elapsed * 0.001 * pulseFreq + dist * 0.001) * 0.2 + 0.8;
                    
                    if (laser.userData.lineMaterial) {
                        laser.userData.lineMaterial.opacity *= pulse;
                    }
                    
                    if (laser.userData.glowMaterial) {
                        laser.userData.glowMaterial.uniforms.opacity.value *= pulse;
                    }
                }
                
                // 激光闪烁效果 - 增强动态感
                if (Math.random() < 0.01) {
                    const flashIntensity = 1.2 + Math.random() * 0.3;
                    if (laser.userData.lineMaterial) {
                        laser.userData.lineMaterial.opacity *= flashIntensity;
                    }
                    
                    if (laser.userData.glowMaterial) {
                        laser.userData.glowMaterial.uniforms.opacity.value *= flashIntensity;
                    }
                }
                
                // 后期逐渐淡出垂直激光
                if (laserT > 0.7) {
                    const fadeT = (laserT - 0.7) / 0.3;
                    
                    if (laser.userData.lineMaterial) {
                        laser.userData.lineMaterial.opacity *= (1 - fadeT);
                    }
                    
                    if (laser.userData.glowMaterial) {
                        laser.userData.glowMaterial.uniforms.opacity.value *= (1 - fadeT);
                    }
                }
            });
            
            // 动画中心能量球
            if (cosmicCollapseState.energySphere) {
                const sphere = cosmicCollapseState.energySphere;
                
                // 淡入中心球
                const energyFadeIn = Math.min(1.0, laserT * 5); // 0-20%时间内完成淡入
                
                // 更新着色器时间
                sphere.material.uniforms.time.value = elapsed * 0.001;
                
                // 脉冲效果
                const pulse = Math.sin(elapsed * 0.002) * 0.3 + 0.7;
                const scale = 1.0 + pulse * 0.2 + laserT * 0.5; // 缓慢增大
                sphere.scale.set(scale, scale, scale);
                
                // 内部光源强度随脉冲变化
                if (sphere.children[0] && sphere.children[0].isPointLight) {
                    sphere.children[0].intensity = 2.0 * pulse;
                }
                
                // 激光阶段后期，能量球变得更加活跃
                if (laserT > 0.7) {
                    const activeFactor = (laserT - 0.7) / 0.3;
                    const activeScale = scale * (1 + activeFactor * 0.5); // 变得更大
                    sphere.scale.set(activeScale, activeScale, activeScale);
                    
                    // 更快的着色器动画
                    sphere.material.uniforms.time.value = elapsed * (0.001 + activeFactor * 0.002);
                    
                    // 增强内部光源
                    if (sphere.children[0] && sphere.children[0].isPointLight) {
                        sphere.children[0].intensity = 2.0 * pulse * (1 + activeFactor);
                    }
                }
            }
            
            // 阶段结束时，创建坍缩粒子并切换到坍缩阶段
            if (laserT >= 1.0 && cosmicCollapseState.phase === 'laser') {
                console.log("激光阶段结束，开始坍缩阶段");
                cosmicCollapseState.phase = 'collapse';
                
                // 创建坍缩粒子
                createCollapseParticles();
                
                // 不立即隐藏银河系，而是在粒子动画过程中逐渐淡出
                // galaxy.visible = false;
                
                // 保存银河系所有子物体的原始不透明度，用于后续恢复
                galaxy.children.forEach(child => {
                    if (child.material && typeof child.material.opacity !== 'undefined') {
                        child.userData.originalOpacity = child.material.opacity;
                    }
                    if (child.children) {
                        child.children.forEach(subchild => {
                            if (subchild.material && typeof subchild.material.opacity !== 'undefined') {
                                subchild.userData.originalOpacity = subchild.material.opacity;
                            }
                        });
                    }
                });
            }
        }
        
        // 动画坍缩效果
        function animateCollapse(elapsed) {
            // 坍缩阶段开始时间：激光阶段后
            const collapseStartTime = 10000; // 由于激光阶段延长到10秒，所以这里对应调整
            const collapseDuration = 12000; // 增加到12秒坍缩过程，更宏大
            
            // 坍缩动画时间
            const collapseElapsed = elapsed - collapseStartTime;
            const collapseT = Math.min(1.0, collapseElapsed / collapseDuration);
            
            // 动画所有坍缩粒子
            cosmicCollapseState.collapseParticles.forEach((particleData, index) => {
                const system = particleData.system;
                const positions = system.geometry.attributes.position.array;
                const originalPositions = particleData.originalPositions;
                const targetPositions = particleData.targetPositions;
                const particleType = particleData.type || 'main'; // 默认为main类型
                
                // 根据粒子类型使用不同的动画效果
                switch (particleType) {
                    case 'main': // 主坍缩粒子
                        animateMainParticles(system, positions, originalPositions, targetPositions, collapseT, collapseElapsed);
                        break;
                        
                    case 'wave': // 螺旋能量波动粒子
                        animateWaveParticles(system, positions, originalPositions, targetPositions, collapseT, collapseElapsed);
                        break;
                        
                    case 'shockwave': // 冲击波粒子
                        animateShockwaveParticles(system, positions, originalPositions, targetPositions, collapseT, collapseElapsed);
                        break;
                        
                    case 'rift': // 空间撕裂粒子
                        animateRiftParticles(system, positions, originalPositions, targetPositions, collapseT, collapseElapsed);
                        break;
                        
                    case 'trail': // 能量残影粒子
                        animateTrailParticles(system, positions, originalPositions, targetPositions, collapseT, collapseElapsed);
                        break;
                        
                    case 'quantum': // 量子波动粒子
                        animateQuantumParticles(system, positions, originalPositions, targetPositions, collapseT, collapseElapsed);
                        break;
                        
                    default:
                        // 默认动画 - 线性插值
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] = originalPositions[i] + (targetPositions[i] - originalPositions[i]) * collapseT;
                            positions[i + 1] = originalPositions[i + 1] + (targetPositions[i + 1] - originalPositions[i + 1]) * collapseT;
                            positions[i + 2] = originalPositions[i + 2] + (targetPositions[i + 2] - originalPositions[i + 2]) * collapseT;
                        }
                }
                
                // 更新粒子透明度 - 先淡入，后减弱
                // 第一类粒子（main, wave）先出现 - 0-30%时间淡入
                if (particleType === 'main' || particleType === 'wave') {
                    if (collapseT < 0.3) {
                        system.material.opacity = collapseT / 0.3 * 0.8;
                    } else if (collapseT > 0.7) {
                        const fadeT = (collapseT - 0.7) / 0.3;
                        system.material.opacity = 0.8 * (1 - fadeT * 0.6); // 不完全消失
                    } else {
                        system.material.opacity = 0.8;
                    }
                }
                // 第二类粒子（shockwave, rift）延迟出现 - 20-50%时间淡入
                else if (particleType === 'shockwave' || particleType === 'rift') {
                    if (collapseT < 0.2) {
                        system.material.opacity = 0;
                    } else if (collapseT < 0.5) {
                        system.material.opacity = (collapseT - 0.2) / 0.3 * 0.8;
                    } else if (collapseT > 0.8) {
                        const fadeT = (collapseT - 0.8) / 0.2;
                        system.material.opacity = 0.8 * (1 - fadeT * 0.7); // 不完全消失
                    } else {
                        system.material.opacity = 0.8;
                    }
                    
                    // 更新自定义着色器时间（如果有）
                    if (system.material.uniforms && system.material.uniforms.time) {
                        system.material.uniforms.time.value = collapseElapsed * 0.001;
                        system.material.uniforms.opacity.value = system.material.opacity;
                    }
                }
                // 第三类粒子（trail, quantum）在最后出现 - 50-70%时间淡入
                else {
                    if (collapseT < 0.5) {
                        system.material.opacity = 0;
                    } else if (collapseT < 0.7) {
                        system.material.opacity = (collapseT - 0.5) / 0.2 * 0.8;
                    } else if (collapseT > 0.9) {
                        const fadeT = (collapseT - 0.9) / 0.1;
                        system.material.opacity = 0.8 * (1 - fadeT * 0.4); // 基本保持可见
                    } else {
                        system.material.opacity = 0.8;
                    }
                    
                    // 更新自定义着色器时间（如果有）
                    if (system.material.uniforms && system.material.uniforms.time) {
                        system.material.uniforms.time.value = collapseElapsed * 0.001;
                        system.material.uniforms.opacity.value = system.material.opacity;
                    }
                }
                
                // 标记位置需要更新
                system.geometry.attributes.position.needsUpdate = true;
            });
            
            // 在粒子完全显示后，开始让银河系淡出（30%-70%时间）
            if (collapseT >= 0.3 && collapseT < 0.7) {
                const galaxyFadeT = (collapseT - 0.3) / 0.4; // 归一化到[0,1]
                
                // 逐渐降低银河系透明度
                galaxy.children.forEach(child => {
                    if (child.material && typeof child.material.opacity !== 'undefined') {
                        const originalOpacity = child.userData.originalOpacity !== undefined ? 
                            child.userData.originalOpacity : 0.7;
                        child.material.opacity = originalOpacity * (1 - galaxyFadeT);
                    }
                    
                    if (child.children) {
                        child.children.forEach(subchild => {
                            if (subchild.material && typeof subchild.material.opacity !== 'undefined') {
                                const originalOpacity = subchild.userData.originalOpacity !== undefined ? 
                                    subchild.userData.originalOpacity : 0.7;
                                subchild.material.opacity = originalOpacity * (1 - galaxyFadeT);
                            }
                        });
                    }
                });
                
                // 银河系完全淡出后，隐藏它（但不删除，以便后续恢复）
                if (galaxyFadeT >= 0.99) {
                    galaxy.visible = false;
                }
            }
            
            // 动画中心能量球
            if (cosmicCollapseState.energySphere) {
                // 更新着色器时间
                cosmicCollapseState.energySphere.material.uniforms.time.value = collapseElapsed * 0.001;
                
                if (collapseT < 0.6) {
                    // 前60%时间继续脉冲
                    const pulse = Math.sin(collapseElapsed * 0.002) * 0.3 + 0.7;
                    const scale = 2.5 + pulse * 0.5 + collapseT * 2.0; // 逐渐增大
                    cosmicCollapseState.energySphere.scale.set(scale, scale, scale);
                    
                    // 内部光源强度脉动
                    if (cosmicCollapseState.energySphere.children[0] && cosmicCollapseState.energySphere.children[0].isPointLight) {
                        cosmicCollapseState.energySphere.children[0].intensity = 2.0 * pulse * (1 + collapseT * 2);
                    }
                } else {
                    // 后40%时间逐渐缩小消失
                    const fadeT = (collapseT - 0.6) / 0.4; // 归一化到[0,1]
                    const scale = 5.0 * (1 - fadeT); // 从5.0逐渐缩小到0
                    cosmicCollapseState.energySphere.scale.set(scale, scale, scale);
                    
                    // 内部光源也逐渐消失
                    if (cosmicCollapseState.energySphere.children[0] && cosmicCollapseState.energySphere.children[0].isPointLight) {
                        cosmicCollapseState.energySphere.children[0].intensity = 4.0 * (1 - fadeT);
                    }
                }
            }
            
            // 激光射线淡出
            if (cosmicCollapseState.verticalLasers) {
                cosmicCollapseState.verticalLasers.forEach(laser => {
                    if (!laser) return;
                    
                    // 在坍缩初期就快速淡出激光
                    const laserFadeT = Math.min(1.0, collapseT * 3);
                    
                    if (laser.userData.lineMaterial) {
                        laser.userData.lineMaterial.opacity = 0.7 * (1 - laserFadeT);
                    }
                    
                    if (laser.userData.glowMaterial) {
                        laser.userData.glowMaterial.uniforms.opacity.value = 0.3 * (1 - laserFadeT);
                    }
                });
            }
            
            // 径向激光淡出
            if (cosmicCollapseState.radialLasers) {
                cosmicCollapseState.radialLasers.forEach(laser => {
                    if (!laser) return;
                    
                    // 在坍缩初期就快速淡出激光
                    const laserFadeT = Math.min(1.0, collapseT * 2);
                    
                    if (laser.userData.lineMaterial) {
                        laser.userData.lineMaterial.opacity = 0.7 * (1 - laserFadeT);
                    }
                    
                    if (laser.userData.glowMaterial) {
                        laser.userData.glowMaterial.uniforms.opacity.value = 0.3 * (1 - laserFadeT);
                    }
                });
            }
            
            // 坍缩阶段即将结束时，创建虚空球体
            if (collapseT > 0.85 && !cosmicCollapseState.voidSphere) {
                createVoidSphere();
            }
            
            // 如果虚空球体存在，动画其生长
            if (cosmicCollapseState.voidSphere) {
                const growthT = (collapseT - 0.85) / 0.15; // 归一化到[0,1]，仅在最后15%时间内生长
                if (growthT > 0) {
                    // 非线性增长
                    const scale = Math.pow(growthT, 2) * 1.5; // 逐渐加速增长
                    cosmicCollapseState.voidSphere.scale.set(scale, scale, scale);
                    
                    // 更新着色器时间
                    cosmicCollapseState.voidSphere.material.uniforms.time.value = elapsed * 0.001;
                }
            }
            
            // 控制相机位置 - 随着坍缩推进，逐渐靠近中心
            if (collapseT > 0.4) {
                const cameraT = (collapseT - 0.4) / 0.6; // 归一化到[0,1]
                const corePos = getGalaxyCoreWorldPosition();
                const originalDistance = cosmicCollapseState.originalState.cameraPosition.distanceTo(corePos);
                const targetDistance = originalDistance * 0.6; // 最终距离为原来的60%
                
                const currentDistance = originalDistance - (originalDistance - targetDistance) * Math.pow(cameraT, 2);
                
                // 计算从当前位置到中心的方向
                const direction = new THREE.Vector3()
                    .subVectors(camera.position, corePos)
                    .normalize();
                
                // 新位置 = 中心 + 方向 * 当前距离
                const newPosition = corePos.clone().add(direction.multiplyScalar(currentDistance));
                
                // 柔和地靠近
                camera.position.lerp(newPosition, 0.03);
            }
            
            // 阶段结束时，切换到虚空阶段
            if (collapseT >= 1.0 && cosmicCollapseState.phase === 'collapse') {
                console.log("坍缩阶段结束，开始虚空阶段");
                cosmicCollapseState.phase = 'void';
                
                // 清理激光和粒子
                cleanupLasersAndParticles();
            }
        }
        
        // 动画主坍缩粒子
        function animateMainParticles(system, positions, originalPositions, targetPositions, t, elapsed) {
            // 指数曲线，开始慢后来快
            const movementT = Math.pow(t, 3);
            
            // 更新每个粒子位置
            for (let i = 0; i < positions.length; i += 3) {
                // 在原始位置和目标位置之间插值
                positions[i] = originalPositions[i] + (targetPositions[i] - originalPositions[i]) * movementT;
                positions[i + 1] = originalPositions[i + 1] + (targetPositions[i + 1] - originalPositions[i + 1]) * movementT;
                positions[i + 2] = originalPositions[i + 2] + (targetPositions[i + 2] - originalPositions[i + 2]) * movementT;
                
                // 增加一些湍流效果（越靠近中心越强）
                if (t > 0.2) {
                    const distFactor = 1.0 - movementT; // 越接近中心，扰动越小
                    const turb = Math.sin(elapsed * 0.0005 * (i % 10)) * 500 * distFactor;
                    positions[i] += (Math.random() - 0.5) * turb;
                    positions[i + 1] += (Math.random() - 0.5) * turb;
                    positions[i + 2] += (Math.random() - 0.5) * turb;
                }
            }
            
            // 粒子大小随坍缩过程变化
            if (t > 0.5) {
                // 主粒子在后半段逐渐变小
                const sizeT = (t - 0.5) * 2; // 归一化到[0,1]
                system.material.size = 40 * (1 - sizeT * 0.8); // 逐渐缩小到原始大小的20%
            }
        }
        
        // 动画螺旋能量波动粒子
        function animateWaveParticles(system, positions, originalPositions, targetPositions, t, elapsed) {
            // 线性动画
            const movementT = t;
            
            // 创建波动和旋转效果
            for (let i = 0; i < positions.length; i += 3) {
                const idx = i / 3;
                const angleOffset = elapsed * 0.0005 + idx * 0.01;
                const waveAmp = Math.max(0, 1 - t) * 500;
                const waveFactor = Math.sin(angleOffset) * waveAmp;
                
                // 应用波动效果（原位置和目标位置之间的插值）
                positions[i] = originalPositions[i] + (targetPositions[i] - originalPositions[i]) * movementT +
                    Math.cos(angleOffset * 2) * waveFactor;
                positions[i + 1] = originalPositions[i + 1] + (targetPositions[i + 1] - originalPositions[i + 1]) * movementT +
                    Math.sin(angleOffset * 3) * waveFactor * 0.5;
                positions[i + 2] = originalPositions[i + 2] + (targetPositions[i + 2] - originalPositions[i + 2]) * movementT +
                    Math.sin(angleOffset * 2.5) * waveFactor;
            }
            
            // 波动粒子逐渐变小
            system.material.size = 30 * (1 - t * 0.8);
        }
        
        // 动画冲击波粒子
        function animateShockwaveParticles(system, positions, originalPositions, targetPositions, t, elapsed) {
            // 冲击波先向外膨胀，然后收缩
            const expansionPeak = 0.4; // 膨胀峰值时间点
            const expansionFactor = 1.5; // 最大膨胀系数
            
            let currentExpansion;
            if (t < expansionPeak) {
                // 膨胀阶段
                currentExpansion = (t / expansionPeak) * expansionFactor;
            } else {
                // 收缩阶段
                currentExpansion = expansionFactor - ((t - expansionPeak) / (1 - expansionPeak)) * expansionFactor;
            }
            
            // 更新每个粒子
            const corePos = getGalaxyCoreWorldPosition();
            for (let i = 0; i < positions.length; i += 3) {
                // 计算到中心的向量
                const dx = originalPositions[i] - corePos.x;
                const dy = originalPositions[i + 1] - corePos.y;
                const dz = originalPositions[i + 2] - corePos.z;
                
                // 根据膨胀系数调整位置
                positions[i] = corePos.x + dx * currentExpansion;
                positions[i + 1] = corePos.y + dy * currentExpansion;
                positions[i + 2] = corePos.z + dz * currentExpansion;
                
                // 添加脉冲波动
                const waveIntensity = 200 * (1 - Math.pow(t, 2));
                const wave = Math.sin(elapsed * 0.002 + (i / 3) * 0.1) * waveIntensity;
                const dir = new THREE.Vector3(dx, dy, dz).normalize();
                
                positions[i] += dir.x * wave;
                positions[i + 1] += dir.y * wave;
                positions[i + 2] += dir.z * wave;
                
                // 如果接近末尾，添加一些坍缩效果
                if (t > 0.7) {
                    const collapseT = (t - 0.7) / 0.3;
                    positions[i] = positions[i] * (1 - collapseT) + corePos.x * collapseT;
                    positions[i + 1] = positions[i + 1] * (1 - collapseT) + corePos.y * collapseT;
                    positions[i + 2] = positions[i + 2] * (1 - collapseT) + corePos.z * collapseT;
                }
            }
            
            // 大小随时间变化 - 先增大后减小
            if (t < 0.5) {
                system.material.size = 100 * (1 + t);
            } else {
                system.material.size = 200 * (1 - (t - 0.5) / 0.5 * 0.8);
            }
        }
        
        // 动画空间撕裂粒子
        function animateRiftParticles(system, positions, originalPositions, targetPositions, t, elapsed) {
            // 撕裂效果 - 先扩展，然后不规则收缩
            const corePos = getGalaxyCoreWorldPosition();
            
            for (let i = 0; i < positions.length; i += 3) {
                // 计算到中心的距离和方向
                const dx = originalPositions[i] - corePos.x;
                const dy = originalPositions[i + 1] - corePos.y;
                const dz = originalPositions[i + 2] - corePos.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                let newDist;
                if (t < 0.3) {
                    // 初始阶段 - 扩展
                    newDist = dist * (1 + t * 0.5);
                } else if (t < 0.7) {
                    // 中间阶段 - 保持不变并波动
                    const waveT = (t - 0.3) / 0.4;
                    const waveFactor = Math.sin(waveT * Math.PI * 3) * 0.2 + 1.0;
                    newDist = dist * 1.15 * waveFactor;
                } else {
                    // 最终阶段 - 收缩
                    const collapseT = (t - 0.7) / 0.3;
                    newDist = dist * 1.15 * (1 - collapseT);
                }
                
                // 添加扭曲
                const twistFactor = Math.sin(elapsed * 0.0005 + dist * 0.001) * Math.PI * 0.2;
                const twistMatrix = new THREE.Matrix4().makeRotationY(twistFactor);
                
                // 方向向量
                const dir = new THREE.Vector3(dx / dist, dy / dist, dz / dist);
                dir.applyMatrix4(twistMatrix); // 应用扭曲
                
                // 设置新位置
                positions[i] = corePos.x + dir.x * newDist;
                positions[i + 1] = corePos.y + dir.y * newDist;
                positions[i + 2] = corePos.z + dir.z * newDist;
                
                // 最后快速坍缩
                if (t > 0.9) {
                    const finalT = (t - 0.9) / 0.1;
                    positions[i] = positions[i] * (1 - finalT) + corePos.x * finalT;
                    positions[i + 1] = positions[i + 1] * (1 - finalT) + corePos.y * finalT;
                    positions[i + 2] = positions[i + 2] * (1 - finalT) + corePos.z * finalT;
                }
            }
            
            // 大小变化
            if (t < 0.6) {
                system.material.size = 40 * (1 + t * 0.5);
            } else {
                system.material.size = 40 * (1 + 0.3) * (1 - (t - 0.6) / 0.4 * 0.8);
            }
        }
        
        // 动画能量残影粒子
        function animateTrailParticles(system, positions, originalPositions, targetPositions, t, elapsed) {
            // 残影效果 - 先平缓移动，中后期加速
            const moveT = t < 0.7 ? t * 0.7 : t * 0.7 + Math.pow((t - 0.7) / 0.3, 2) * 0.3;
            
            // 缩短拖尾长度（如果是自定义着色器）
            if (system.material.uniforms && system.material.uniforms.trailLength) {
                system.material.uniforms.trailLength.value = 1.0 - Math.pow(t, 2) * 0.8;
            }
            
            // 更新位置
            const corePos = getGalaxyCoreWorldPosition();
            for (let i = 0; i < positions.length; i += 3) {
                // 计算到中心的向量
                const dx = originalPositions[i] - corePos.x;
                const dy = originalPositions[i + 1] - corePos.y;
                const dz = originalPositions[i + 2] - corePos.z;
                
                // 流线效果 - 沿着螺旋轨迹向中心移动
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                const direction = new THREE.Vector3(dx / dist, dy / dist, dz / dist);
                
                // 增加螺旋效应
                const spiralFactor = t * Math.PI * 2; // 随时间增加旋转
                const rotMatrix = new THREE.Matrix4().makeRotationY(spiralFactor);
                direction.applyMatrix4(rotMatrix);
                
                // 计算当前距离中心的距离
                const currentDist = dist * (1 - moveT);
                
                // 设置新位置
                positions[i] = corePos.x + direction.x * currentDist;
                positions[i + 1] = corePos.y + direction.y * currentDist;
                positions[i + 2] = corePos.z + direction.z * currentDist;
                
                // 添加波动
                const waveFactor = Math.sin(elapsed * 0.002 + (i / 3) * 0.1) * 200 * (1 - t);
                positions[i] += direction.x * waveFactor;
                positions[i + 1] += direction.y * waveFactor;
                positions[i + 2] += direction.z * waveFactor;
            }
            
            // 更新着色器参数
            if (system.material.uniforms) {
                system.material.uniforms.time.value = elapsed * 0.001;
            }
        }
        
        // 动画量子波动粒子
        function animateQuantumParticles(system, positions, originalPositions, targetPositions, t, elapsed) {
            // 量子粒子表现随机波动，不是简单移动
            const corePos = getGalaxyCoreWorldPosition();
            
            for (let i = 0; i < positions.length; i += 3) {
                // 在最初阶段，粒子表现为量子随机波动（布朗运动）
                if (t < 0.6) {
                    const brownianT = t / 0.6;
                    
                    // 混合原始位置与量子波动
                    const randomFactor = 2000 * (1 - brownianT); // 初期波动幅度大，后期减小
                    
                    // 添加随机波动
                    positions[i] = originalPositions[i] + (Math.random() - 0.5) * randomFactor;
                    positions[i + 1] = originalPositions[i + 1] + (Math.random() - 0.5) * randomFactor;
                    positions[i + 2] = originalPositions[i + 2] + (Math.random() - 0.5) * randomFactor;
                    
                    // 同时缓慢向中心移动
                    const moveT = brownianT * 0.3;
                    
                    positions[i] = positions[i] * (1 - moveT) + corePos.x * moveT;
                    positions[i + 1] = positions[i + 1] * (1 - moveT) + corePos.y * moveT;
                    positions[i + 2] = positions[i + 2] * (1 - moveT) + corePos.z * moveT;
                } 
                // 后期，粒子开始坍缩到中心
                else {
                    const collapseT = (t - 0.6) / 0.4;
                    
                    // 非线性坍缩，带有微小随机性
                    const moveT = Math.pow(collapseT, 3);
                    const jitter = 200 * (1 - collapseT); // 随坍缩程度减小的抖动
                    
                    positions[i] = originalPositions[i] * (1 - moveT) + corePos.x * moveT + (Math.random() - 0.5) * jitter;
                    positions[i + 1] = originalPositions[i + 1] * (1 - moveT) + corePos.y * moveT + (Math.random() - 0.5) * jitter;
                    positions[i + 2] = originalPositions[i + 2] * (1 - moveT) + corePos.z * moveT + (Math.random() - 0.5) * jitter;
                }
            }
            
            // 粒子大小随坍缩过程变化
            if (t < 0.8) {
                // 前期逐渐增大
                system.material.size = 10 * (1 + t * 2);
            } else {
                // 后期快速缩小
                system.material.size = 10 * (1 + 1.6) * (1 - (t - 0.8) / 0.2);
            }
        }
        
        // 清理激光和粒子
        function cleanupLasersAndParticles() {
            // 移除激光
            if (cosmicCollapseState.verticalLasers) {
                cosmicCollapseState.verticalLasers.forEach(laser => {
                    if (laser) scene.remove(laser);
                });
                cosmicCollapseState.verticalLasers = [];
            }
            
            // 移除径向激光
            if (cosmicCollapseState.radialLasers) {
                cosmicCollapseState.radialLasers.forEach(laser => {
                    if (laser) scene.remove(laser);
                });
                cosmicCollapseState.radialLasers = [];
            }
            
            // 移除能量球
            if (cosmicCollapseState.energySphere) {
                scene.remove(cosmicCollapseState.energySphere);
                cosmicCollapseState.energySphere = null;
            }
            
            // 移除银河发光盘
            if (cosmicCollapseState.galaxyDisk) {
                scene.remove(cosmicCollapseState.galaxyDisk);
                cosmicCollapseState.galaxyDisk = null;
            }
            
            // 移除坍缩粒子
            if (cosmicCollapseState.collapseParticles) {
                cosmicCollapseState.collapseParticles.forEach(particleData => {
                    if (particleData.system) scene.remove(particleData.system);
                });
                cosmicCollapseState.collapseParticles = [];
            }
            
            // 清理旧的光线特效
            if (galaxyLightRays.length > 0) {
                galaxyLightRays.forEach(ray => {
                    if (ray && ray.mesh) scene.remove(ray.mesh);
                });
                galaxyLightRays = [];
                galaxyLightRayAnimating = false;
            }
        }
    </script>
    <script src="my-cursor.js"></script>
    <script src="galaxy-hold-2.js"></script>
    <!-- 双击特效脚本 - 为galaxy元素添加id以便更容易被脚本找到 -->
    <script>
        // 确保galaxy对象可被脚本找到
        if (galaxy) {
            galaxy.id = 'galaxy';
            console.log('为银河系添加ID: galaxy');
        }
        
        // 确保THREE.js对象可被特效脚本访问
        (function() {
            console.log('暴露THREE.js对象给特效脚本');
            
            // 检查主要THREE.js对象是否存在
            if (typeof scene !== 'undefined') {
                console.log('暴露场景对象到全局作用域');
                window.scene = scene;
            }
            
            if (typeof camera !== 'undefined') {
                console.log('暴露相机对象到全局作用域');
                window.camera = camera;
            }
            
            if (typeof renderer !== 'undefined') {
                console.log('暴露渲染器对象到全局作用域');
                window.renderer = renderer;
            }
            
            if (typeof controls !== 'undefined') {
                console.log('暴露控制器对象到全局作用域');
                window.controls = controls;
            }
        })();
        
        // 添加鼠标中键点击事件监听器
        (function() {
            console.log('添加鼠标中键点击和长按事件监听器');
            
            // 长按计时器和状态变量
            let middleMouseDownTimer = null;
            const LONG_PRESS_DURATION = 800; // 长按时间阈值（毫秒）
            let middleMouseDownTime = 0;
            let middleMouseDown = false;
            
            // 监听鼠标按下
            document.addEventListener('mousedown', function(event) {
                // 检查是否点击了鼠标中键（通常是滚轮按下，button值为1）
                if (event.button === 1) {
                    console.log('鼠标中键按下');
                    
                    // 阻止默认的中键滚动行为
                    event.preventDefault();
                    
                    // 记录按下状态和时间
                    middleMouseDown = true;
                    middleMouseDownTime = Date.now();
                    
                    // 设置长按计时器
                    middleMouseDownTimer = setTimeout(function() {
                        console.log('检测到鼠标中键长按，跳转到index.html');
                        middleMouseDown = false;
                        window.location.href = 'index.html';
                    }, LONG_PRESS_DURATION);
                }
            });
            
            // 监听鼠标松开
            document.addEventListener('mouseup', function(event) {
                // 检查是否松开了鼠标中键
                if (event.button === 1 && middleMouseDown) {
                    // 清除长按计时器
                    if (middleMouseDownTimer) {
                        clearTimeout(middleMouseDownTimer);
                        middleMouseDownTimer = null;
                    }
                    
                    // 计算按下时间
                    const pressDuration = Date.now() - middleMouseDownTime;
                    
                    // 如果按下时间小于长按阈值，则视为点击
                    if (pressDuration < LONG_PRESS_DURATION) {
                        console.log('检测到鼠标中键点击，跳转到cursorburst.html');
                        window.location.href = 'cursorburst.html';
                    }
                    
                    middleMouseDown = false;
                }
            });
            
            // 确保鼠标移出窗口时也能取消长按计时器
            document.addEventListener('mouseleave', function() {
                if (middleMouseDownTimer) {
                    clearTimeout(middleMouseDownTimer);
                    middleMouseDownTimer = null;
                }
                middleMouseDown = false;
            });
        })();
    </script>

    <script src="my-function.js"></script>
</body>
</html>